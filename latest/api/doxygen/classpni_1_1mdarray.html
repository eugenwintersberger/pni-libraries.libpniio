<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PNI NeXus Library: pni::mdarray&lt; StorageT, IndexMapT, InplaceArithmeticT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-bizflat.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PNI NeXus Library
   &#160;<span id="projectnumber">3.0.4</span>
   </div>
   <div id="projectbrief">NeXus library for Photon Neutron Ion Science</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpni_1_1mdarray.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">pni::mdarray&lt; StorageT, IndexMapT, InplaceArithmeticT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>template for a multi-dimensional array class  
 <a href="classpni_1_1mdarray.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mdarray_8hpp_source.html">mdarray.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for pni::mdarray&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpni_1_1mdarray__coll__graph.png" border="0" usemap="#apni_1_1mdarray_3_01StorageT_00_01IndexMapT_00_01InplaceArithmeticT_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="apni_1_1mdarray_3_01StorageT_00_01IndexMapT_00_01InplaceArithmeticT_01_4_coll__map" id="apni_1_1mdarray_3_01StorageT_00_01IndexMapT_00_01InplaceArithmeticT_01_4_coll__map">
<area shape="rect" title="template for a multi&#45;dimensional array class" alt="" coords="5,109,224,151"/>
<area shape="rect" href="classpni_1_1index__map.html" title="dynamic general index map template" alt="" coords="19,5,210,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af3a30e89ff106212e2ab184ea376bef4"><td class="memItemLeft" align="right" valign="top">typedef StorageT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#af3a30e89ff106212e2ab184ea376bef4">storage_type</a></td></tr>
<tr class="memdesc:af3a30e89ff106212e2ab184ea376bef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the buffer object  <a href="classpni_1_1mdarray.html#af3a30e89ff106212e2ab184ea376bef4">More...</a><br /></td></tr>
<tr class="separator:af3a30e89ff106212e2ab184ea376bef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71faeff6d1fbee3f1eeac7be96607e0"><td class="memItemLeft" align="right" valign="top">typedef storage_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a></td></tr>
<tr class="memdesc:aa71faeff6d1fbee3f1eeac7be96607e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">arrays element type  <a href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">More...</a><br /></td></tr>
<tr class="separator:aa71faeff6d1fbee3f1eeac7be96607e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8b23db379e1d1499a654f037ae82be"><td class="memItemLeft" align="right" valign="top">typedef IndexMapT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a6f8b23db379e1d1499a654f037ae82be">map_type</a></td></tr>
<tr class="memdesc:a6f8b23db379e1d1499a654f037ae82be"><td class="mdescLeft">&#160;</td><td class="mdescRight">index map type  <a href="classpni_1_1mdarray.html#a6f8b23db379e1d1499a654f037ae82be">More...</a><br /></td></tr>
<tr class="separator:a6f8b23db379e1d1499a654f037ae82be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d76ec63ea6bfa121b4bcd52fad2f387"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; <a class="el" href="classpni_1_1mdarray.html#af3a30e89ff106212e2ab184ea376bef4">storage_type</a>, <a class="el" href="classpni_1_1mdarray.html#a6f8b23db379e1d1499a654f037ae82be">map_type</a>, InplaceArithmeticT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a></td></tr>
<tr class="memdesc:a5d76ec63ea6bfa121b4bcd52fad2f387"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the array  <a href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">More...</a><br /></td></tr>
<tr class="separator:a5d76ec63ea6bfa121b4bcd52fad2f387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cbc89285ca249720d4a3f0c837ecab"><td class="memItemLeft" align="right" valign="top">typedef storage_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a11cbc89285ca249720d4a3f0c837ecab">iterator</a></td></tr>
<tr class="memdesc:a11cbc89285ca249720d4a3f0c837ecab"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator type  <a href="classpni_1_1mdarray.html#a11cbc89285ca249720d4a3f0c837ecab">More...</a><br /></td></tr>
<tr class="separator:a11cbc89285ca249720d4a3f0c837ecab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172bff769b6ff00fbd2d6f4d558a9f4e"><td class="memItemLeft" align="right" valign="top">typedef storage_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a172bff769b6ff00fbd2d6f4d558a9f4e">const_iterator</a></td></tr>
<tr class="memdesc:a172bff769b6ff00fbd2d6f4d558a9f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">const iterator type  <a href="classpni_1_1mdarray.html#a172bff769b6ff00fbd2d6f4d558a9f4e">More...</a><br /></td></tr>
<tr class="separator:a172bff769b6ff00fbd2d6f4d558a9f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a8699831d19fe1f8411b81f3b5d391"><td class="memItemLeft" align="right" valign="top">typedef storage_type::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a16a8699831d19fe1f8411b81f3b5d391">reverse_iterator</a></td></tr>
<tr class="memdesc:a16a8699831d19fe1f8411b81f3b5d391"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse iterator  <a href="classpni_1_1mdarray.html#a16a8699831d19fe1f8411b81f3b5d391">More...</a><br /></td></tr>
<tr class="separator:a16a8699831d19fe1f8411b81f3b5d391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9975a93934fb93fb22cf09cf64e3eded"><td class="memItemLeft" align="right" valign="top">typedef storage_type::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a9975a93934fb93fb22cf09cf64e3eded">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a9975a93934fb93fb22cf09cf64e3eded"><td class="mdescLeft">&#160;</td><td class="mdescRight">const reverse iterator  <a href="classpni_1_1mdarray.html#a9975a93934fb93fb22cf09cf64e3eded">More...</a><br /></td></tr>
<tr class="separator:a9975a93934fb93fb22cf09cf64e3eded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03166651be3e4156e63877507c02f906"><td class="memItemLeft" align="right" valign="top">typedef InplaceArithmeticT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a03166651be3e4156e63877507c02f906">inplace_arithmetic</a></td></tr>
<tr class="memdesc:a03166651be3e4156e63877507c02f906"><td class="mdescLeft">&#160;</td><td class="mdescRight">inplace arithmetics type  <a href="classpni_1_1mdarray.html#a03166651be3e4156e63877507c02f906">More...</a><br /></td></tr>
<tr class="separator:a03166651be3e4156e63877507c02f906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8519a22fe3d427952c6251a5123cb2b8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; <a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a8519a22fe3d427952c6251a5123cb2b8">view_type</a></td></tr>
<tr class="memdesc:a8519a22fe3d427952c6251a5123cb2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">view type  <a href="classpni_1_1mdarray.html#a8519a22fe3d427952c6251a5123cb2b8">More...</a><br /></td></tr>
<tr class="separator:a8519a22fe3d427952c6251a5123cb2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c0cbb74fc2914e1cbc39bfdeca838b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; const <a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#af4c0cbb74fc2914e1cbc39bfdeca838b">const_view_type</a></td></tr>
<tr class="memdesc:af4c0cbb74fc2914e1cbc39bfdeca838b"><td class="mdescLeft">&#160;</td><td class="mdescRight">const view type  <a href="classpni_1_1mdarray.html#af4c0cbb74fc2914e1cbc39bfdeca838b">More...</a><br /></td></tr>
<tr class="separator:af4c0cbb74fc2914e1cbc39bfdeca838b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb727086fe4e46f5bfe74e454c48cce"><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#abeb727086fe4e46f5bfe74e454c48cce">size_type</a></td></tr>
<tr class="memdesc:abeb727086fe4e46f5bfe74e454c48cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">type used for size  <a href="classpni_1_1mdarray.html#abeb727086fe4e46f5bfe74e454c48cce">More...</a><br /></td></tr>
<tr class="separator:abeb727086fe4e46f5bfe74e454c48cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea1c1288c822dc4a9df19eeb7cc8124c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#aea1c1288c822dc4a9df19eeb7cc8124c">mdarray</a> ()</td></tr>
<tr class="memdesc:aea1c1288c822dc4a9df19eeb7cc8124c"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="classpni_1_1mdarray.html#aea1c1288c822dc4a9df19eeb7cc8124c">More...</a><br /></td></tr>
<tr class="separator:aea1c1288c822dc4a9df19eeb7cc8124c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc845cfb040c9b62e71eb652fc4cebdf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#abc845cfb040c9b62e71eb652fc4cebdf">mdarray</a> (const <a class="el" href="classpni_1_1mdarray.html#a6f8b23db379e1d1499a654f037ae82be">map_type</a> &amp;<a class="el" href="classpni_1_1mdarray.html#a61eddbcfd86784a9af1de805490e7b58">map</a>, const <a class="el" href="classpni_1_1mdarray.html#af3a30e89ff106212e2ab184ea376bef4">storage_type</a> &amp;s)</td></tr>
<tr class="memdesc:abc845cfb040c9b62e71eb652fc4cebdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct from map and storage  <a href="classpni_1_1mdarray.html#abc845cfb040c9b62e71eb652fc4cebdf">More...</a><br /></td></tr>
<tr class="separator:abc845cfb040c9b62e71eb652fc4cebdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962caac8724a12050b4d7876ac1ed75f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a962caac8724a12050b4d7876ac1ed75f">mdarray</a> (<a class="el" href="classpni_1_1mdarray.html#a6f8b23db379e1d1499a654f037ae82be">map_type</a> &amp;&amp;<a class="el" href="classpni_1_1mdarray.html#a61eddbcfd86784a9af1de805490e7b58">map</a>, <a class="el" href="classpni_1_1mdarray.html#af3a30e89ff106212e2ab184ea376bef4">storage_type</a> &amp;&amp;s)</td></tr>
<tr class="memdesc:a962caac8724a12050b4d7876ac1ed75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">move construct from map and storage  <a href="classpni_1_1mdarray.html#a962caac8724a12050b4d7876ac1ed75f">More...</a><br /></td></tr>
<tr class="separator:a962caac8724a12050b4d7876ac1ed75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb290a320cc9a39af115506be412460"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:aebb290a320cc9a39af115506be412460"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#aebb290a320cc9a39af115506be412460">mdarray</a> (const <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; ArrayT &gt; &amp;view)</td></tr>
<tr class="memdesc:aebb290a320cc9a39af115506be412460"><td class="mdescLeft">&#160;</td><td class="mdescRight">constrcut from a view  <a href="classpni_1_1mdarray.html#aebb290a320cc9a39af115506be412460">More...</a><br /></td></tr>
<tr class="separator:aebb290a320cc9a39af115506be412460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cccd050053e594d32f419cd9bf72c1"><td class="memTemplParams" colspan="2">template&lt;typename ... MDArrayArgsT&gt; </td></tr>
<tr class="memitem:a55cccd050053e594d32f419cd9bf72c1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a55cccd050053e594d32f419cd9bf72c1">mdarray</a> (const <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; MDArrayArgsT... &gt; &amp;<a class="el" href="classpni_1_1array.html">array</a>)</td></tr>
<tr class="memdesc:a55cccd050053e594d32f419cd9bf72c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction from an other array  <a href="classpni_1_1mdarray.html#a55cccd050053e594d32f419cd9bf72c1">More...</a><br /></td></tr>
<tr class="separator:a55cccd050053e594d32f419cd9bf72c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ace9770e3431e9743b9e14f75136978"><td class="memTemplParams" colspan="2">template&lt;typename ... MDArrayArgsT&gt; </td></tr>
<tr class="memitem:a3ace9770e3431e9743b9e14f75136978"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a3ace9770e3431e9743b9e14f75136978">operator=</a> (const <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; MDArrayArgsT... &gt; &amp;<a class="el" href="classpni_1_1array.html">array</a>)</td></tr>
<tr class="memdesc:a3ace9770e3431e9743b9e14f75136978"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment from a different array type  <a href="classpni_1_1mdarray.html#a3ace9770e3431e9743b9e14f75136978">More...</a><br /></td></tr>
<tr class="separator:a3ace9770e3431e9743b9e14f75136978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad306df88a1e1e18f8c71ad8e43f07be4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#ad306df88a1e1e18f8c71ad8e43f07be4">operator=</a> (const std::initializer_list&lt; <a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> &gt; &amp;l)</td></tr>
<tr class="memdesc:ad306df88a1e1e18f8c71ad8e43f07be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment from an initializer list  <a href="classpni_1_1mdarray.html#ad306df88a1e1e18f8c71ad8e43f07be4">More...</a><br /></td></tr>
<tr class="separator:ad306df88a1e1e18f8c71ad8e43f07be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61eddbcfd86784a9af1de805490e7b58"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpni_1_1mdarray.html#a6f8b23db379e1d1499a654f037ae82be">map_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a61eddbcfd86784a9af1de805490e7b58">map</a> () const</td></tr>
<tr class="memdesc:a61eddbcfd86784a9af1de805490e7b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">get index map  <a href="classpni_1_1mdarray.html#a61eddbcfd86784a9af1de805490e7b58">More...</a><br /></td></tr>
<tr class="separator:a61eddbcfd86784a9af1de805490e7b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9f2d71a9a2d28299a82a3ff8d96cda"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT &gt; </td></tr>
<tr class="memitem:aea9f2d71a9a2d28299a82a3ff8d96cda"><td class="memTemplItemLeft" align="right" valign="top">ContainerT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#aea9f2d71a9a2d28299a82a3ff8d96cda">shape</a> () const</td></tr>
<tr class="memdesc:aea9f2d71a9a2d28299a82a3ff8d96cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">shape to container  <a href="classpni_1_1mdarray.html#aea9f2d71a9a2d28299a82a3ff8d96cda">More...</a><br /></td></tr>
<tr class="separator:aea9f2d71a9a2d28299a82a3ff8d96cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7e0e4aeca161de80f5076a4419dc4a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a4f7e0e4aeca161de80f5076a4419dc4a">size</a> () const</td></tr>
<tr class="memdesc:a4f7e0e4aeca161de80f5076a4419dc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get size of array  <a href="classpni_1_1mdarray.html#a4f7e0e4aeca161de80f5076a4419dc4a">More...</a><br /></td></tr>
<tr class="separator:a4f7e0e4aeca161de80f5076a4419dc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe86195700af504aa2759c0cab6fcac"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#abfe86195700af504aa2759c0cab6fcac">rank</a> () const</td></tr>
<tr class="memdesc:abfe86195700af504aa2759c0cab6fcac"><td class="mdescLeft">&#160;</td><td class="mdescRight">get number of dimensions  <a href="classpni_1_1mdarray.html#abfe86195700af504aa2759c0cab6fcac">More...</a><br /></td></tr>
<tr class="separator:abfe86195700af504aa2759c0cab6fcac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487e5545b9baf7e9d97d2654266be1a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a487e5545b9baf7e9d97d2654266be1a5">operator[]</a> (size_t i)</td></tr>
<tr class="memdesc:a487e5545b9baf7e9d97d2654266be1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">get referece to element i  <a href="classpni_1_1mdarray.html#a487e5545b9baf7e9d97d2654266be1a5">More...</a><br /></td></tr>
<tr class="separator:a487e5545b9baf7e9d97d2654266be1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12686356aecb7470e1438490cff232aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a12686356aecb7470e1438490cff232aa">operator[]</a> (size_t i) const</td></tr>
<tr class="memdesc:a12686356aecb7470e1438490cff232aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">get value at i  <a href="classpni_1_1mdarray.html#a12686356aecb7470e1438490cff232aa">More...</a><br /></td></tr>
<tr class="separator:a12686356aecb7470e1438490cff232aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfa5712ad7ee7277d866ad152692682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a9bfa5712ad7ee7277d866ad152692682">at</a> (size_t i)</td></tr>
<tr class="memdesc:a9bfa5712ad7ee7277d866ad152692682"><td class="mdescLeft">&#160;</td><td class="mdescRight">get value at i  <a href="classpni_1_1mdarray.html#a9bfa5712ad7ee7277d866ad152692682">More...</a><br /></td></tr>
<tr class="separator:a9bfa5712ad7ee7277d866ad152692682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef66662e199ae12d53064d5fafe6fb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a7ef66662e199ae12d53064d5fafe6fb3">at</a> (size_t i) const</td></tr>
<tr class="memdesc:a7ef66662e199ae12d53064d5fafe6fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">get value at i  <a href="classpni_1_1mdarray.html#a7ef66662e199ae12d53064d5fafe6fb3">More...</a><br /></td></tr>
<tr class="separator:a7ef66662e199ae12d53064d5fafe6fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac066b3daec063c704a67f389d21426cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#ac066b3daec063c704a67f389d21426cf">insert</a> (size_t i, const <a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> &amp;<a class="el" href="classpni_1_1value.html">value</a>)</td></tr>
<tr class="memdesc:ac066b3daec063c704a67f389d21426cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert value at index i  <a href="classpni_1_1mdarray.html#ac066b3daec063c704a67f389d21426cf">More...</a><br /></td></tr>
<tr class="separator:ac066b3daec063c704a67f389d21426cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de63a0f257e5ae19f41f4729e4c0355"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename  = typename enable_element_cont&lt;ContainerT&gt;::type&gt; </td></tr>
<tr class="memitem:a5de63a0f257e5ae19f41f4729e4c0355"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a5de63a0f257e5ae19f41f4729e4c0355">operator()</a> (const ContainerT &amp;index)</td></tr>
<tr class="memdesc:a5de63a0f257e5ae19f41f4729e4c0355"><td class="mdescLeft">&#160;</td><td class="mdescRight">return element reference  <a href="classpni_1_1mdarray.html#a5de63a0f257e5ae19f41f4729e4c0355">More...</a><br /></td></tr>
<tr class="separator:a5de63a0f257e5ae19f41f4729e4c0355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b74af574265775b7588ce52d7ff268a"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename  = typename enable_element_cont&lt;ContainerT&gt;::type&gt; </td></tr>
<tr class="memitem:a0b74af574265775b7588ce52d7ff268a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a0b74af574265775b7588ce52d7ff268a">operator()</a> (const ContainerT &amp;index) const</td></tr>
<tr class="memdesc:a0b74af574265775b7588ce52d7ff268a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return element value  <a href="classpni_1_1mdarray.html#a0b74af574265775b7588ce52d7ff268a">More...</a><br /></td></tr>
<tr class="separator:a0b74af574265775b7588ce52d7ff268a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1fef775ce3937bf943f0262cbd2429"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename  = typename enable_view_cont&lt;ContainerT&gt;::type&gt; </td></tr>
<tr class="memitem:a2b1fef775ce3937bf943f0262cbd2429"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; const <a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a2b1fef775ce3937bf943f0262cbd2429">operator()</a> (const ContainerT &amp;slices) const</td></tr>
<tr class="memdesc:a2b1fef775ce3937bf943f0262cbd2429"><td class="mdescLeft">&#160;</td><td class="mdescRight">return array view  <a href="classpni_1_1mdarray.html#a2b1fef775ce3937bf943f0262cbd2429">More...</a><br /></td></tr>
<tr class="separator:a2b1fef775ce3937bf943f0262cbd2429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a4637c5baffe7938f8f913a04f691d"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename  = typename enable_view_cont&lt;ContainerT&gt;::type&gt; </td></tr>
<tr class="memitem:a88a4637c5baffe7938f8f913a04f691d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; <a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a88a4637c5baffe7938f8f913a04f691d">operator()</a> (const ContainerT &amp;slices)</td></tr>
<tr class="memdesc:a88a4637c5baffe7938f8f913a04f691d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return array view  <a href="classpni_1_1mdarray.html#a88a4637c5baffe7938f8f913a04f691d">More...</a><br /></td></tr>
<tr class="separator:a88a4637c5baffe7938f8f913a04f691d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd9772eb5fb8cf5debb420a44e8a0be"><td class="memTemplParams" colspan="2">template&lt;typename... IndicesT, typename  = typename enable_valid_index&lt;IndicesT...&gt;::type&gt; </td></tr>
<tr class="memitem:a6dd9772eb5fb8cf5debb420a44e8a0be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacepni.html#ab2add101c915d69fa25c2910e928ec64">view_type_trait</a>&lt; <a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>, IndicesT... &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a6dd9772eb5fb8cf5debb420a44e8a0be">operator()</a> (IndicesT... indexes)</td></tr>
<tr class="memdesc:a6dd9772eb5fb8cf5debb420a44e8a0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiindex access  <a href="classpni_1_1mdarray.html#a6dd9772eb5fb8cf5debb420a44e8a0be">More...</a><br /></td></tr>
<tr class="separator:a6dd9772eb5fb8cf5debb420a44e8a0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad139d4c7fb6506459042fdc0cc75f1de"><td class="memTemplParams" colspan="2">template&lt;typename... IndicesT, typename  = typename enable_valid_index&lt;IndicesT...&gt;::type&gt; </td></tr>
<tr class="memitem:ad139d4c7fb6506459042fdc0cc75f1de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacepni.html#ab2add101c915d69fa25c2910e928ec64">view_type_trait</a>&lt; const <a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>, IndicesT... &gt;::const_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#ad139d4c7fb6506459042fdc0cc75f1de">operator()</a> (IndicesT ...indexes) const</td></tr>
<tr class="memdesc:ad139d4c7fb6506459042fdc0cc75f1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiindex access  <a href="classpni_1_1mdarray.html#ad139d4c7fb6506459042fdc0cc75f1de">More...</a><br /></td></tr>
<tr class="separator:ad139d4c7fb6506459042fdc0cc75f1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb8391496feb326cd8d13cfc786e51a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a8eb8391496feb326cd8d13cfc786e51a">data</a> () const</td></tr>
<tr class="memdesc:a8eb8391496feb326cd8d13cfc786e51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return const pointer  <a href="classpni_1_1mdarray.html#a8eb8391496feb326cd8d13cfc786e51a">More...</a><br /></td></tr>
<tr class="separator:a8eb8391496feb326cd8d13cfc786e51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d49c7abdfd545153cb809ee6e7806f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#aa9d49c7abdfd545153cb809ee6e7806f">data</a> ()</td></tr>
<tr class="memdesc:aa9d49c7abdfd545153cb809ee6e7806f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return pointer  <a href="classpni_1_1mdarray.html#aa9d49c7abdfd545153cb809ee6e7806f">More...</a><br /></td></tr>
<tr class="separator:aa9d49c7abdfd545153cb809ee6e7806f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2281db18f6a4b02278f265efb80d198f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a2281db18f6a4b02278f265efb80d198f">front</a> ()</td></tr>
<tr class="memdesc:a2281db18f6a4b02278f265efb80d198f"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference to first element  <a href="classpni_1_1mdarray.html#a2281db18f6a4b02278f265efb80d198f">More...</a><br /></td></tr>
<tr class="separator:a2281db18f6a4b02278f265efb80d198f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8acca7d89af09a5bf8f878e50c5d68c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#af8acca7d89af09a5bf8f878e50c5d68c">front</a> () const</td></tr>
<tr class="memdesc:af8acca7d89af09a5bf8f878e50c5d68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">value of first element  <a href="classpni_1_1mdarray.html#af8acca7d89af09a5bf8f878e50c5d68c">More...</a><br /></td></tr>
<tr class="separator:af8acca7d89af09a5bf8f878e50c5d68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd6c4344ac04ef24199e917be578e9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#aecd6c4344ac04ef24199e917be578e9b">back</a> ()</td></tr>
<tr class="memdesc:aecd6c4344ac04ef24199e917be578e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference to last element  <a href="classpni_1_1mdarray.html#aecd6c4344ac04ef24199e917be578e9b">More...</a><br /></td></tr>
<tr class="separator:aecd6c4344ac04ef24199e917be578e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dd1c0517090ba6361df9cd65170299"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#ab0dd1c0517090ba6361df9cd65170299">back</a> () const</td></tr>
<tr class="memdesc:ab0dd1c0517090ba6361df9cd65170299"><td class="mdescLeft">&#160;</td><td class="mdescRight">value of last element  <a href="classpni_1_1mdarray.html#ab0dd1c0517090ba6361df9cd65170299">More...</a><br /></td></tr>
<tr class="separator:ab0dd1c0517090ba6361df9cd65170299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41186efb5d55f05cdff488045c327144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a11cbc89285ca249720d4a3f0c837ecab">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a41186efb5d55f05cdff488045c327144">begin</a> ()</td></tr>
<tr class="memdesc:a41186efb5d55f05cdff488045c327144"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator to first element  <a href="classpni_1_1mdarray.html#a41186efb5d55f05cdff488045c327144">More...</a><br /></td></tr>
<tr class="separator:a41186efb5d55f05cdff488045c327144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc9c0fd225508b75ea45f907acb7d3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a11cbc89285ca249720d4a3f0c837ecab">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a0dc9c0fd225508b75ea45f907acb7d3b">end</a> ()</td></tr>
<tr class="memdesc:a0dc9c0fd225508b75ea45f907acb7d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator to last element  <a href="classpni_1_1mdarray.html#a0dc9c0fd225508b75ea45f907acb7d3b">More...</a><br /></td></tr>
<tr class="separator:a0dc9c0fd225508b75ea45f907acb7d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5801c256afd07c28bf8e8ac717c6176"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a172bff769b6ff00fbd2d6f4d558a9f4e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#aa5801c256afd07c28bf8e8ac717c6176">begin</a> () const</td></tr>
<tr class="memdesc:aa5801c256afd07c28bf8e8ac717c6176"><td class="mdescLeft">&#160;</td><td class="mdescRight">const-iterator to first element  <a href="classpni_1_1mdarray.html#aa5801c256afd07c28bf8e8ac717c6176">More...</a><br /></td></tr>
<tr class="separator:aa5801c256afd07c28bf8e8ac717c6176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f347e3e56a91c74606213bdc92bf0d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a172bff769b6ff00fbd2d6f4d558a9f4e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a6f347e3e56a91c74606213bdc92bf0d0">end</a> () const</td></tr>
<tr class="memdesc:a6f347e3e56a91c74606213bdc92bf0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">const-iterator to last element  <a href="classpni_1_1mdarray.html#a6f347e3e56a91c74606213bdc92bf0d0">More...</a><br /></td></tr>
<tr class="separator:a6f347e3e56a91c74606213bdc92bf0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa824b69144b8ccabde121d74842f1286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a16a8699831d19fe1f8411b81f3b5d391">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#aa824b69144b8ccabde121d74842f1286">rbegin</a> ()</td></tr>
<tr class="memdesc:aa824b69144b8ccabde121d74842f1286"><td class="mdescLeft">&#160;</td><td class="mdescRight">return reverse iterator to last element  <a href="classpni_1_1mdarray.html#aa824b69144b8ccabde121d74842f1286">More...</a><br /></td></tr>
<tr class="separator:aa824b69144b8ccabde121d74842f1286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b1aebaa1633d525a90fb42d00c3b53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a9975a93934fb93fb22cf09cf64e3eded">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a77b1aebaa1633d525a90fb42d00c3b53">rbegin</a> () const</td></tr>
<tr class="memdesc:a77b1aebaa1633d525a90fb42d00c3b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">return const reverse iterator to last element  <a href="classpni_1_1mdarray.html#a77b1aebaa1633d525a90fb42d00c3b53">More...</a><br /></td></tr>
<tr class="separator:a77b1aebaa1633d525a90fb42d00c3b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3c286c7107f74a48406cd3e13d987b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a16a8699831d19fe1f8411b81f3b5d391">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a0d3c286c7107f74a48406cd3e13d987b">rend</a> ()</td></tr>
<tr class="memdesc:a0d3c286c7107f74a48406cd3e13d987b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return reverse iterator to 0-1 element  <a href="classpni_1_1mdarray.html#a0d3c286c7107f74a48406cd3e13d987b">More...</a><br /></td></tr>
<tr class="separator:a0d3c286c7107f74a48406cd3e13d987b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca6325e5537be9969428a4524e96185"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a9975a93934fb93fb22cf09cf64e3eded">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a4ca6325e5537be9969428a4524e96185">rend</a> () const</td></tr>
<tr class="memdesc:a4ca6325e5537be9969428a4524e96185"><td class="mdescLeft">&#160;</td><td class="mdescRight">return const reverse iterator to 0-1 element  <a href="classpni_1_1mdarray.html#a4ca6325e5537be9969428a4524e96185">More...</a><br /></td></tr>
<tr class="separator:a4ca6325e5537be9969428a4524e96185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a44f2eb2810494d5ca7ba8d9eef3ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a78a44f2eb2810494d5ca7ba8d9eef3ce">operator+=</a> (<a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> s)</td></tr>
<tr class="memdesc:a78a44f2eb2810494d5ca7ba8d9eef3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">unary addition of a scalar  <a href="classpni_1_1mdarray.html#a78a44f2eb2810494d5ca7ba8d9eef3ce">More...</a><br /></td></tr>
<tr class="separator:a78a44f2eb2810494d5ca7ba8d9eef3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27267077d112550b888b33e2bfe5c509"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a27267077d112550b888b33e2bfe5c509"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a27267077d112550b888b33e2bfe5c509">operator+=</a> (const ArrayT &amp;v)</td></tr>
<tr class="memdesc:a27267077d112550b888b33e2bfe5c509"><td class="mdescLeft">&#160;</td><td class="mdescRight">unary addition of an array <br  />
  <a href="classpni_1_1mdarray.html#a27267077d112550b888b33e2bfe5c509">More...</a><br /></td></tr>
<tr class="separator:a27267077d112550b888b33e2bfe5c509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ec6ef0087f17fa4e035a08d69f5375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a64ec6ef0087f17fa4e035a08d69f5375">operator-=</a> (<a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> s)</td></tr>
<tr class="memdesc:a64ec6ef0087f17fa4e035a08d69f5375"><td class="mdescLeft">&#160;</td><td class="mdescRight">unary subtraction of a scalar  <a href="classpni_1_1mdarray.html#a64ec6ef0087f17fa4e035a08d69f5375">More...</a><br /></td></tr>
<tr class="separator:a64ec6ef0087f17fa4e035a08d69f5375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d1cbdc381d9a0408e0257f2a0bc83d"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a02d1cbdc381d9a0408e0257f2a0bc83d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a02d1cbdc381d9a0408e0257f2a0bc83d">operator-=</a> (const ArrayT &amp;v)</td></tr>
<tr class="memdesc:a02d1cbdc381d9a0408e0257f2a0bc83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">unary subtraction of an array  <a href="classpni_1_1mdarray.html#a02d1cbdc381d9a0408e0257f2a0bc83d">More...</a><br /></td></tr>
<tr class="separator:a02d1cbdc381d9a0408e0257f2a0bc83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91003d248c9c922f5b562e1424f391d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#ae91003d248c9c922f5b562e1424f391d">operator*=</a> (<a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> s)</td></tr>
<tr class="memdesc:ae91003d248c9c922f5b562e1424f391d"><td class="mdescLeft">&#160;</td><td class="mdescRight">unary multiplication of a scalar  <a href="classpni_1_1mdarray.html#ae91003d248c9c922f5b562e1424f391d">More...</a><br /></td></tr>
<tr class="separator:ae91003d248c9c922f5b562e1424f391d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e80f4a4ed65e1bd42bd6a4c1d7d8be2"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a6e80f4a4ed65e1bd42bd6a4c1d7d8be2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a6e80f4a4ed65e1bd42bd6a4c1d7d8be2">operator*=</a> (const ArrayT &amp;v)</td></tr>
<tr class="memdesc:a6e80f4a4ed65e1bd42bd6a4c1d7d8be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">unary multiplication of an array  <a href="classpni_1_1mdarray.html#a6e80f4a4ed65e1bd42bd6a4c1d7d8be2">More...</a><br /></td></tr>
<tr class="separator:a6e80f4a4ed65e1bd42bd6a4c1d7d8be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4533de2160b8677783fa88aa4c17266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#aa4533de2160b8677783fa88aa4c17266">operator/=</a> (<a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> s)</td></tr>
<tr class="memdesc:aa4533de2160b8677783fa88aa4c17266"><td class="mdescLeft">&#160;</td><td class="mdescRight">unary division of a scalar  <a href="classpni_1_1mdarray.html#aa4533de2160b8677783fa88aa4c17266">More...</a><br /></td></tr>
<tr class="separator:aa4533de2160b8677783fa88aa4c17266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacbd25681c102dd0144018dd18117bd"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:aeacbd25681c102dd0144018dd18117bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#aeacbd25681c102dd0144018dd18117bd">operator/=</a> (const ArrayT &amp;v)</td></tr>
<tr class="memdesc:aeacbd25681c102dd0144018dd18117bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">unary division of an array  <a href="classpni_1_1mdarray.html#aeacbd25681c102dd0144018dd18117bd">More...</a><br /></td></tr>
<tr class="separator:aeacbd25681c102dd0144018dd18117bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab923f58a5bb3aa10f519a9493d8f4954"><td class="memTemplParams" colspan="2">template&lt;typename ... ArrayArgsT&gt; </td></tr>
<tr class="memitem:ab923f58a5bb3aa10f519a9493d8f4954"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#ab923f58a5bb3aa10f519a9493d8f4954">create</a> (ArrayArgsT... arguments)</td></tr>
<tr class="memdesc:ab923f58a5bb3aa10f519a9493d8f4954"><td class="mdescLeft">&#160;</td><td class="mdescRight">generic construction function  <a href="classpni_1_1mdarray.html#ab923f58a5bb3aa10f519a9493d8f4954">More...</a><br /></td></tr>
<tr class="separator:ab923f58a5bb3aa10f519a9493d8f4954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1a8662edb310a19b83eb2c83d5e482"><td class="memTemplParams" colspan="2">template&lt;typename Element1T , typename Element2T &gt; </td></tr>
<tr class="memitem:a6c1a8662edb310a19b83eb2c83d5e482"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a6c1a8662edb310a19b83eb2c83d5e482">create</a> (const std::initializer_list&lt; Element1T &gt; &amp;l1, const std::initializer_list&lt; Element2T &gt; &amp;l2)</td></tr>
<tr class="memdesc:a6c1a8662edb310a19b83eb2c83d5e482"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction from initializer list  <a href="classpni_1_1mdarray.html#a6c1a8662edb310a19b83eb2c83d5e482">More...</a><br /></td></tr>
<tr class="separator:a6c1a8662edb310a19b83eb2c83d5e482"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae214e54b31cdebefd65af6f02505c894"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#ae214e54b31cdebefd65af6f02505c894">type_id</a> = <a class="el" href="structpni_1_1type__id__map.html">type_id_map</a>&lt;<a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>&gt;::type_id</td></tr>
<tr class="memdesc:ae214e54b31cdebefd65af6f02505c894"><td class="mdescLeft">&#160;</td><td class="mdescRight">type ID of the element type  <a href="classpni_1_1mdarray.html#ae214e54b31cdebefd65af6f02505c894">More...</a><br /></td></tr>
<tr class="separator:ae214e54b31cdebefd65af6f02505c894"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4599bc937e6f06303697d544a2bf4f72"><td class="memItemLeft" align="right" valign="top">StorageT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a4599bc937e6f06303697d544a2bf4f72">_data</a></td></tr>
<tr class="memdesc:a4599bc937e6f06303697d544a2bf4f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">instance of StorageT  <a href="classpni_1_1mdarray.html#a4599bc937e6f06303697d544a2bf4f72">More...</a><br /></td></tr>
<tr class="separator:a4599bc937e6f06303697d544a2bf4f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4a01d7fb1d96d3deda4a327feb5a25"><td class="memItemLeft" align="right" valign="top">IndexMapT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html#a9b4a01d7fb1d96d3deda4a327feb5a25">_imap</a></td></tr>
<tr class="memdesc:a9b4a01d7fb1d96d3deda4a327feb5a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index map of the array.  <a href="classpni_1_1mdarray.html#a9b4a01d7fb1d96d3deda4a327feb5a25">More...</a><br /></td></tr>
<tr class="separator:a9b4a01d7fb1d96d3deda4a327feb5a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename StorageT, typename IndexMapT = dynamic_cindex_map, typename InplaceArithmeticT = inplace_arithmetics&gt;<br />
class pni::mdarray&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;</h3>

<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StorageT</td><td>storage object to use to keep the data </td></tr>
    <tr><td class="paramname">IndexMapT</td><td>the index map </td></tr>
    <tr><td class="paramname">InplaceArithmeticT</td><td>unary (inplace) arithmetics implementation </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5d76ec63ea6bfa121b4bcd52fad2f387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d76ec63ea6bfa121b4bcd52fad2f387">&#9670;&nbsp;</a></span>array_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt;<a class="el" href="classpni_1_1mdarray.html#af3a30e89ff106212e2ab184ea376bef4">storage_type</a>,<a class="el" href="classpni_1_1mdarray.html#a6f8b23db379e1d1499a654f037ae82be">map_type</a>,InplaceArithmeticT&gt; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a172bff769b6ff00fbd2d6f4d558a9f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172bff769b6ff00fbd2d6f4d558a9f4e">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef storage_type::const_iterator <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html#a172bff769b6ff00fbd2d6f4d558a9f4e">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9975a93934fb93fb22cf09cf64e3eded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9975a93934fb93fb22cf09cf64e3eded">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef storage_type::const_reverse_iterator <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html#a9975a93934fb93fb22cf09cf64e3eded">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4c0cbb74fc2914e1cbc39bfdeca838b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c0cbb74fc2914e1cbc39bfdeca838b">&#9670;&nbsp;</a></span>const_view_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt;const <a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>&gt; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html#af4c0cbb74fc2914e1cbc39bfdeca838b">const_view_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03166651be3e4156e63877507c02f906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03166651be3e4156e63877507c02f906">&#9670;&nbsp;</a></span>inplace_arithmetic</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef InplaceArithmeticT <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html#a03166651be3e4156e63877507c02f906">inplace_arithmetic</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11cbc89285ca249720d4a3f0c837ecab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cbc89285ca249720d4a3f0c837ecab">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef storage_type::iterator <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html#a11cbc89285ca249720d4a3f0c837ecab">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f8b23db379e1d1499a654f037ae82be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8b23db379e1d1499a654f037ae82be">&#9670;&nbsp;</a></span>map_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef IndexMapT <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html#a6f8b23db379e1d1499a654f037ae82be">map_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16a8699831d19fe1f8411b81f3b5d391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a8699831d19fe1f8411b81f3b5d391">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef storage_type::reverse_iterator <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html#a16a8699831d19fe1f8411b81f3b5d391">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abeb727086fe4e46f5bfe74e454c48cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb727086fe4e46f5bfe74e454c48cce">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html#abeb727086fe4e46f5bfe74e454c48cce">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3a30e89ff106212e2ab184ea376bef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a30e89ff106212e2ab184ea376bef4">&#9670;&nbsp;</a></span>storage_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef StorageT <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html#af3a30e89ff106212e2ab184ea376bef4">storage_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa71faeff6d1fbee3f1eeac7be96607e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71faeff6d1fbee3f1eeac7be96607e0">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef storage_type::value_type <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8519a22fe3d427952c6251a5123cb2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8519a22fe3d427952c6251a5123cb2b8">&#9670;&nbsp;</a></span>view_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt;<a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>&gt; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html#a8519a22fe3d427952c6251a5123cb2b8">view_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aea1c1288c822dc4a9df19eeb7cc8124c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1c1288c822dc4a9df19eeb7cc8124c">&#9670;&nbsp;</a></span>mdarray() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html">mdarray</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc845cfb040c9b62e71eb652fc4cebdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc845cfb040c9b62e71eb652fc4cebdf">&#9670;&nbsp;</a></span>mdarray() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html">mdarray</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1mdarray.html#a6f8b23db379e1d1499a654f037ae82be">map_type</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1mdarray.html#af3a30e89ff106212e2ab184ea376bef4">storage_type</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct an array from an index map and a storage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>the index map instance </td></tr>
    <tr><td class="paramname">s</td><td>array storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a962caac8724a12050b4d7876ac1ed75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962caac8724a12050b4d7876ac1ed75f">&#9670;&nbsp;</a></span>mdarray() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html">mdarray</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpni_1_1mdarray.html#a6f8b23db379e1d1499a654f037ae82be">map_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpni_1_1mdarray.html#af3a30e89ff106212e2ab184ea376bef4">storage_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move construct an array from rvalue refernces to an index map and a storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>rvalue reference to the index map </td></tr>
    <tr><td class="paramname">s</td><td>rvalue reference to the storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebb290a320cc9a39af115506be412460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb290a320cc9a39af115506be412460">&#9670;&nbsp;</a></span>mdarray() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html">mdarray</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; ArrayT &gt; &amp;&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This constructor creates a new array from an array view instance. The resulting array object has the same shape as the view.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayT</td><td>storage type of the view </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>reference to the view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55cccd050053e594d32f419cd9bf72c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cccd050053e594d32f419cd9bf72c1">&#9670;&nbsp;</a></span>mdarray() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<div class="memtemplate">
template&lt;typename ... MDArrayArgsT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::<a class="el" href="classpni_1_1mdarray.html">mdarray</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; MDArrayArgsT... &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This constructor can be used for instance along with expression templates in order to construct an array from an expression.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MDArrayArgsT</td><td>template parameters of mdarray </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>reference to the source array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9bfa5712ad7ee7277d866ad152692682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfa5712ad7ee7277d866ad152692682">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>&amp; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the value at linear index i. This method performs index checking.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1index__error.html" title="index error">index_error</a></td><td>if i exceeds array size </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>linear index of element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the value at i </dd></dl>

</div>
</div>
<a id="a7ef66662e199ae12d53064d5fafe6fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef66662e199ae12d53064d5fafe6fb3">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of element i. This method performs index checking. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1index__error.html" title="index error">index_error</a></td><td>if i exceeds array size </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>linear index of element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value at i </dd></dl>

</div>
</div>
<a id="aecd6c4344ac04ef24199e917be578e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd6c4344ac04ef24199e917be578e9b">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>&amp; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the last element in the linear view of the array.</p>
<dl class="section return"><dt>Returns</dt><dd>reference to last element </dd></dl>

</div>
</div>
<a id="ab0dd1c0517090ba6361df9cd65170299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dd1c0517090ba6361df9cd65170299">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the last element in the linear view of the array.</p>
<dl class="section return"><dt>Returns</dt><dd>value of last element </dd></dl>

</div>
</div>
<a id="a41186efb5d55f05cdff488045c327144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41186efb5d55f05cdff488045c327144">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a11cbc89285ca249720d4a3f0c837ecab">iterator</a> <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a non-const iterator to the first element in the array. </p><dl class="section return"><dt>Returns</dt><dd>iterator to first element </dd></dl>

</div>
</div>
<a id="aa5801c256afd07c28bf8e8ac717c6176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5801c256afd07c28bf8e8ac717c6176">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a172bff769b6ff00fbd2d6f4d558a9f4e">const_iterator</a> <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const-iterator to the first element in the array. </p><dl class="section return"><dt>Returns</dt><dd>iterator to first element </dd></dl>

</div>
</div>
<a id="ab923f58a5bb3aa10f519a9493d8f4954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab923f58a5bb3aa10f519a9493d8f4954">&#9670;&nbsp;</a></span>create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<div class="memtemplate">
template&lt;typename ... ArrayArgsT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::create </td>
          <td>(</td>
          <td class="paramtype">ArrayArgsT...&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function can be used for easy array construction. It uses the <a class="el" href="structpni_1_1array__factory.html" title="array factory">array_factory</a> template in the background.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayArgsT</td><td>variadic argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arguments</td><td>variadic argument list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array instance </dd></dl>

</div>
</div>
<a id="a6c1a8662edb310a19b83eb2c83d5e482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1a8662edb310a19b83eb2c83d5e482">&#9670;&nbsp;</a></span>create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<div class="memtemplate">
template&lt;typename Element1T , typename Element2T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::create </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; Element1T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Element2T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This version of the static create function uses an initializer list. The first initializer list holds shape information while the second holds the data which will be stored in the array.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Element1T</td><td>element type of shape list </td></tr>
    <tr><td class="paramname">Element2T</td><td>element type of data list </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l1</td><td>instance of shape list </td></tr>
    <tr><td class="paramname">l2</td><td>instance of data list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>instance of array_type </dd></dl>

</div>
</div>
<a id="aa9d49c7abdfd545153cb809ee6e7806f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d49c7abdfd545153cb809ee6e7806f">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>* <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the data stored in the array.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to data </dd></dl>

</div>
</div>
<a id="a8eb8391496feb326cd8d13cfc786e51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb8391496feb326cd8d13cfc786e51a">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>* <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a const pointer to the data stored in the array.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to data </dd></dl>

</div>
</div>
<a id="a0dc9c0fd225508b75ea45f907acb7d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc9c0fd225508b75ea45f907acb7d3b">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a11cbc89285ca249720d4a3f0c837ecab">iterator</a> <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a non-const iterator to the last element in the array.</p>
<dl class="section return"><dt>Returns</dt><dd>iterator to last element </dd></dl>

</div>
</div>
<a id="a6f347e3e56a91c74606213bdc92bf0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f347e3e56a91c74606213bdc92bf0d0">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a172bff769b6ff00fbd2d6f4d558a9f4e">const_iterator</a> <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const-iterator to the last element in the array.</p>
<dl class="section return"><dt>Returns</dt><dd>iterator to last element </dd></dl>

</div>
</div>
<a id="a2281db18f6a4b02278f265efb80d198f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2281db18f6a4b02278f265efb80d198f">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>&amp; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the first element in the linear view of the array.</p>
<dl class="section return"><dt>Returns</dt><dd>reference to first element </dd></dl>

</div>
</div>
<a id="af8acca7d89af09a5bf8f878e50c5d68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8acca7d89af09a5bf8f878e50c5d68c">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the first element in the linear view of the array.</p>
<dl class="section return"><dt>Returns</dt><dd>value of the first element </dd></dl>

</div>
</div>
<a id="ac066b3daec063c704a67f389d21426cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac066b3daec063c704a67f389d21426cf">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert value at index i.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1index__error.html" title="index error">index_error</a></td><td>if i exceeds the size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>linear index of the element </td></tr>
    <tr><td class="paramname">value</td><td>the value to store at index i </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61eddbcfd86784a9af1de805490e7b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61eddbcfd86784a9af1de805490e7b58">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpni_1_1mdarray.html#a6f8b23db379e1d1499a654f037ae82be">map_type</a>&amp; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const reference to the index map of the array. </p><dl class="section return"><dt>Returns</dt><dd>reference to index map </dd></dl>

</div>
</div>
<a id="a5de63a0f257e5ae19f41f4729e4c0355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de63a0f257e5ae19f41f4729e4c0355">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<div class="memtemplate">
template&lt;typename ContainerT , typename  = typename enable_element_cont&lt;ContainerT&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>&amp; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the reference to a single elemnt of the array determined by a multidimensional index of unsigned integers stored in a container of type ContainerT. This method performs no range checking.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>index container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>reference to index container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the element </dd></dl>

</div>
</div>
<a id="a0b74af574265775b7588ce52d7ff268a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b74af574265775b7588ce52d7ff268a">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<div class="memtemplate">
template&lt;typename ContainerT , typename  = typename enable_element_cont&lt;ContainerT&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of a single elemnt of the array determined by a multidimensional index of unsigned integers stored in a container of type ContainerT. This method performs no range checking.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>index container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>reference to index container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the element </dd></dl>

</div>
</div>
<a id="a88a4637c5baffe7938f8f913a04f691d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a4637c5baffe7938f8f913a04f691d">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<div class="memtemplate">
template&lt;typename ContainerT , typename  = typename enable_view_cont&lt;ContainerT&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1array__view.html">array_view</a>&lt;<a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>&gt; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>slices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a view on the array determined by a set of slices stored in a container type ContainerT.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>slice container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slices</td><td>reference to the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpni_1_1array__view.html" title="provides a view on a part of an array">array_view</a> instance </dd></dl>

</div>
</div>
<a id="a2b1fef775ce3937bf943f0262cbd2429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1fef775ce3937bf943f0262cbd2429">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<div class="memtemplate">
template&lt;typename ContainerT , typename  = typename enable_view_cont&lt;ContainerT&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1array__view.html">array_view</a>&lt;const <a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>&gt; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>slices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a view on the array determined by a set of slices stored in a container type ContainerT.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>slice container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slices</td><td>reference to the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpni_1_1array__view.html" title="provides a view on a part of an array">array_view</a> instance </dd></dl>

</div>
</div>
<a id="ad139d4c7fb6506459042fdc0cc75f1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad139d4c7fb6506459042fdc0cc75f1de">&#9670;&nbsp;</a></span>operator()() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<div class="memtemplate">
template&lt;typename... IndicesT, typename  = typename enable_valid_index&lt;IndicesT...&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepni.html#ab2add101c915d69fa25c2910e928ec64">view_type_trait</a>&lt;const <a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>,IndicesT...&gt;::const_type <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">IndicesT ...&#160;</td>
          <td class="paramname"><em>indexes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The () operator allows multindex access to the data stored in the array. Like the [] operator it does not perform any checks of index ranges and should thus be used with care. However, due to the missign checks it is extremely fast. If index checking is required have a look the corresponding <a class="el" href="classpni_1_1mdarray.html#a9bfa5712ad7ee7277d866ad152692682" title="get value at i">at()</a> member function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndicesT</td><td>index types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>list of index values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value at the given index </dd></dl>

</div>
</div>
<a id="a6dd9772eb5fb8cf5debb420a44e8a0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd9772eb5fb8cf5debb420a44e8a0be">&#9670;&nbsp;</a></span>operator()() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<div class="memtemplate">
template&lt;typename... IndicesT, typename  = typename enable_valid_index&lt;IndicesT...&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepni.html#ab2add101c915d69fa25c2910e928ec64">view_type_trait</a>&lt;<a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>,IndicesT...&gt;::type <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">IndicesT...&#160;</td>
          <td class="paramname"><em>indexes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The () operator allows multindex access to the data stored in the array. Like the [] operator it does not perform any checks of index ranges and should thus be used with care. However, due to the missign checks it is extremely fast. If index checking is required have a look the corresponding <a class="el" href="classpni_1_1mdarray.html#a9bfa5712ad7ee7277d866ad152692682" title="get value at i">at()</a> member function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndicesT</td><td>index types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>list of index values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the value at the given index </dd></dl>

</div>
</div>
<a id="a6e80f4a4ed65e1bd42bd6a4c1d7d8be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e80f4a4ed65e1bd42bd6a4c1d7d8be2">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>&amp; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const ArrayT &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line">array_type1 a = ...;</div>
<div class="line">array_tyep2 b = ...;</div>
<div class="line"> </div>
<div class="line">a *= b;</div>
</div><!-- fragment --><p> ! </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayT</td><td>type of the array to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>reference to the array to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the original array </dd></dl>

</div>
</div>
<a id="ae91003d248c9c922f5b562e1424f391d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91003d248c9c922f5b562e1424f391d">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>&amp; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a class="code" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> a = ...;</div>
<div class="line"><a class="code" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">array_type::value_type</a> s = ...;</div>
<div class="line"> </div>
<div class="line">a *= s;</div>
<div class="ttc" id="aclasspni_1_1mdarray_html_a5d76ec63ea6bfa121b4bcd52fad2f387"><div class="ttname"><a href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">pni::mdarray::array_type</a></div><div class="ttdeci">mdarray&lt; storage_type, map_type, InplaceArithmeticT &gt; array_type</div><div class="ttdoc">type of the array</div><div class="ttdef"><b>Definition:</b> mdarray.hpp:77</div></div>
<div class="ttc" id="aclasspni_1_1mdarray_html_aa71faeff6d1fbee3f1eeac7be96607e0"><div class="ttname"><a href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">pni::mdarray::value_type</a></div><div class="ttdeci">storage_type::value_type value_type</div><div class="ttdoc">arrays element type</div><div class="ttdef"><b>Definition:</b> mdarray.hpp:73</div></div>
</div><!-- fragment --><p> ! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the scalar value to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array reference </dd></dl>

</div>
</div>
<a id="a27267077d112550b888b33e2bfe5c509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27267077d112550b888b33e2bfe5c509">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>&amp; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const ArrayT &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line">array_type1 a = ...;</div>
<div class="line">array_tyep2 b = ...;</div>
<div class="line"> </div>
<div class="line">a += b;</div>
</div><!-- fragment --><p> ! </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayT</td><td>type of the array to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>reference to the array to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the original array </dd></dl>

</div>
</div>
<a id="a78a44f2eb2810494d5ca7ba8d9eef3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a44f2eb2810494d5ca7ba8d9eef3ce">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>&amp; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a class="code" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> a = ...;</div>
<div class="line"><a class="code" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">array_type::value_type</a> s = ...;</div>
<div class="line"> </div>
<div class="line">a += s;</div>
</div><!-- fragment --><p> ! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the scalar value to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array reference </dd></dl>

</div>
</div>
<a id="a02d1cbdc381d9a0408e0257f2a0bc83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d1cbdc381d9a0408e0257f2a0bc83d">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>&amp; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const ArrayT &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line">array_type1 a = ...;</div>
<div class="line">array_tyep2 b = ...;</div>
<div class="line"> </div>
<div class="line">a -= b;</div>
</div><!-- fragment --><p> ! </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayT</td><td>type of the array to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>reference to the array to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the original array </dd></dl>

</div>
</div>
<a id="a64ec6ef0087f17fa4e035a08d69f5375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ec6ef0087f17fa4e035a08d69f5375">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>&amp; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a class="code" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> a = ...;</div>
<div class="line"><a class="code" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">array_type::value_type</a> s = ...;</div>
<div class="line"> </div>
<div class="line">a -= s;</div>
</div><!-- fragment --><p> ! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the scalar value to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array reference </dd></dl>

</div>
</div>
<a id="aeacbd25681c102dd0144018dd18117bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacbd25681c102dd0144018dd18117bd">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>&amp; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const ArrayT &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line">array_type1 a = ...;</div>
<div class="line">array_tyep2 b = ...;</div>
<div class="line"> </div>
<div class="line">a /= b;</div>
</div><!-- fragment --><p> ! </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayT</td><td>type of the array to divide by <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>reference to the array to divide by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the original array </dd></dl>

</div>
</div>
<a id="aa4533de2160b8677783fa88aa4c17266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4533de2160b8677783fa88aa4c17266">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>&amp; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a class="code" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a> a = ...;</div>
<div class="line"><a class="code" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">array_type::value_type</a> s = ...;</div>
<div class="line"> </div>
<div class="line">a /= s;</div>
</div><!-- fragment --><p> ! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the scalar value to divide by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array reference </dd></dl>

</div>
</div>
<a id="a3ace9770e3431e9743b9e14f75136978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ace9770e3431e9743b9e14f75136978">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<div class="memtemplate">
template&lt;typename ... MDArrayArgsT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>&amp; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; MDArrayArgsT... &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign the data from a different array type to this one.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1size__mismatch__error.html" title="Size mismatch error.">size_mismatch_error</a></td><td>if array sizes do not match </td></tr>
    <tr><td class="paramname"><a class="el" href="classpni_1_1shape__mismatch__error.html" title="Shape mismatch error.">shape_mismatch_error</a></td><td>if shapes do not match </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MDArrayArgsT</td><td>template parameters of the source type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>reference to the source array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the updated array </dd></dl>

</div>
</div>
<a id="ad306df88a1e1e18f8c71ad8e43f07be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad306df88a1e1e18f8c71ad8e43f07be4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a5d76ec63ea6bfa121b4bcd52fad2f387">array_type</a>&amp; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assigns the values given by an initializer list to an allocated array. If the number of elements in the list does not match the number of elements in the array an exception is thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1size__mismatch__error.html" title="Size mismatch error.">size_mismatch_error</a></td><td>if list size and array size do not match </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>reference to an initializer list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the array </dd></dl>

</div>
</div>
<a id="a487e5545b9baf7e9d97d2654266be1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487e5545b9baf7e9d97d2654266be1a5">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>&amp; <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the element at linear index i. No index checking is done! Thus use this operator with care.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>linear index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the element at linear index i </dd></dl>

</div>
</div>
<a id="a12686356aecb7470e1438490cff232aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12686356aecb7470e1438490cff232aa">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a> <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the element at the linar array index i. No index checking is done! Thus use this operator with care.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>linear index of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the element at linear index i </dd></dl>

</div>
</div>
<a id="abfe86195700af504aa2759c0cab6fcac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe86195700af504aa2759c0cab6fcac">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of dimensions of the array.</p>
<dl class="section return"><dt>Returns</dt><dd>number of dimensions </dd></dl>

</div>
</div>
<a id="aa824b69144b8ccabde121d74842f1286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa824b69144b8ccabde121d74842f1286">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a16a8699831d19fe1f8411b81f3b5d391">reverse_iterator</a> <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77b1aebaa1633d525a90fb42d00c3b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b1aebaa1633d525a90fb42d00c3b53">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a9975a93934fb93fb22cf09cf64e3eded">const_reverse_iterator</a> <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d3c286c7107f74a48406cd3e13d987b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3c286c7107f74a48406cd3e13d987b">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a16a8699831d19fe1f8411b81f3b5d391">reverse_iterator</a> <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ca6325e5537be9969428a4524e96185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca6325e5537be9969428a4524e96185">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html#a9975a93934fb93fb22cf09cf64e3eded">const_reverse_iterator</a> <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea9f2d71a9a2d28299a82a3ff8d96cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9f2d71a9a2d28299a82a3ff8d96cda">&#9670;&nbsp;</a></span>shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<div class="memtemplate">
template&lt;typename ContainerT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ContainerT <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This returns a container of type ContainerT with the number of elements stored in the array.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>instance of ContainerT with shape data </dd></dl>

</div>
</div>
<a id="a4f7e0e4aeca161de80f5076a4419dc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7e0e4aeca161de80f5076a4419dc4a">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the total number of elements stored in the array. </p><dl class="section return"><dt>Returns</dt><dd>total number of elements </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a4599bc937e6f06303697d544a2bf4f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4599bc937e6f06303697d544a2bf4f72">&#9670;&nbsp;</a></span>_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StorageT <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b4a01d7fb1d96d3deda4a327feb5a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4a01d7fb1d96d3deda4a327feb5a25">&#9670;&nbsp;</a></span>_imap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT  = dynamic_cindex_map, typename InplaceArithmeticT  = inplace_arithmetics&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IndexMapT <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::_imap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae214e54b31cdebefd65af6f02505c894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae214e54b31cdebefd65af6f02505c894">&#9670;&nbsp;</a></span>type_id</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT , typename InplaceArithmeticT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt;::type_id = <a class="el" href="structpni_1_1type__id__map.html">type_id_map</a>&lt;<a class="el" href="classpni_1_1mdarray.html#aa71faeff6d1fbee3f1eeac7be96607e0">value_type</a>&gt;::type_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="mdarray_8hpp_source.html">mdarray.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepni.html">pni</a></li><li class="navelem"><a class="el" href="classpni_1_1mdarray.html">mdarray</a></li>
    <li class="footer">Generated on Mon Feb 20 2023 11:30:48 for PNI NeXus Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
