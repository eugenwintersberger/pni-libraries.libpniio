<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PNI NeXus Library: pni Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-bizflat.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PNI NeXus Library
   &#160;<span id="projectnumber">3.0.4</span>
   </div>
   <div id="projectbrief">NeXus library for Photon Neutron Ion Science</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacepni.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pni Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepni_1_1cbf"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni_1_1cbf.html">cbf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepni_1_1nexus"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni_1_1nexus.html">nexus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepni_1_1nx"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni_1_1nx.html">nx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepni_1_1tiff"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni_1_1tiff.html">tiff</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1array__view.html">array_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">provides a view on a part of an array  <a href="classpni_1_1array__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1add__op.html">add_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">addition expression template  <a href="classpni_1_1add__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1div__op.html">div_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division expression template.  <a href="classpni_1_1div__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1inplace__arithmetics.html">inplace_arithmetics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">single threaded inplace arithmetics  <a href="structpni_1_1inplace__arithmetics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mult__op.html">mult_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication expression template.  <a href="classpni_1_1mult__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1op__trait.html">op_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator reference trait  <a href="structpni_1_1op__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1op__trait_3_01scalar_3_01GeneralT_01_4_01_4.html">op_trait&lt; scalar&lt; GeneralT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator trait for scalars  <a href="structpni_1_1op__trait_3_01scalar_3_01GeneralT_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1array__trait.html">array_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">array trait for expression templates  <a href="structpni_1_1array__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1array__trait_3_01Operand1T_00_01scalar_3_01ScalarOperandT_01_4_01_4.html">array_trait&lt; Operand1T, scalar&lt; ScalarOperandT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">array trait for expression templates  <a href="structpni_1_1array__trait_3_01Operand1T_00_01scalar_3_01ScalarOperandT_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1array__trait_3_01scalar_3_01ScalarOperandT_01_4_00_01Operand1T_01_4.html">array_trait&lt; scalar&lt; ScalarOperandT &gt;, Operand1T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">array trait for expression templates  <a href="structpni_1_1array__trait_3_01scalar_3_01ScalarOperandT_01_4_00_01Operand1T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1sub__op.html">sub_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtraction expression template  <a href="classpni_1_1sub__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1is__array.html">is_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct identifying a type as an array type  <a href="structpni_1_1is__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1array__factory.html">array_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">array factory  <a href="structpni_1_1array__factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1array__selection.html">array_selection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">selection from a multidimensional array  <a href="classpni_1_1array__selection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1container__trait_3_01array__view_3_01ArrayT_01_4_01_4.html">container_trait&lt; array_view&lt; ArrayT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structpni_1_1container__trait.html" title="container trait">container_trait</a> for an <a class="el" href="classpni_1_1array__view.html" title="provides a view on a part of an array">array_view</a>  <a href="structpni_1_1container__trait_3_01array__view_3_01ArrayT_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1array__view__trait.html">array_view_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">view trait  <a href="structpni_1_1array__view__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1array__view__trait_3_01ArrayT_00_01true_01_4.html">array_view_trait&lt; ArrayT, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">view trait for views  <a href="structpni_1_1array__view__trait_3_01ArrayT_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1array__view__trait_3_01ArrayT_00_01false_01_4.html">array_view_trait&lt; ArrayT, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">trait for single elements  <a href="structpni_1_1array__view__trait_3_01ArrayT_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1view__provider.html">view_provider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1view__provider_3_01ArrayT_00_01false_01_4.html">view_provider&lt; ArrayT, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">single value <a class="el" href="structpni_1_1view__provider.html">view_provider</a>  <a href="structpni_1_1view__provider_3_01ArrayT_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1view__provider_3_01ArrayT_00_01true_01_4.html">view_provider&lt; ArrayT, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">array view <a class="el" href="structpni_1_1view__provider.html">view_provider</a>  <a href="structpni_1_1view__provider_3_01ArrayT_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1index__iterator.html">index_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">index iterator  <a href="classpni_1_1index__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1c__index__map__imp.html">c_index_map_imp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C index map implementation.  <a href="classpni_1_1c__index__map__imp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1index__map.html">index_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">dynamic general index map template  <a href="classpni_1_1index__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1map__utils.html">map_utils</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility class for index maps  <a href="structpni_1_1map__utils.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1map__utils_3_01static__index__map_3_01PolicyT_00_01TDimsN_8_8_8_01_4_01_4.html">map_utils&lt; static_index_map&lt; PolicyT, TDimsN... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility class for static index maps  <a href="structpni_1_1map__utils_3_01static__index__map_3_01PolicyT_00_01TDimsN_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1static__index__map.html">static_index_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the static general index map template  <a href="classpni_1_1static__index__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1is__index__type.html">is_index_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if an index type is a valid index type  <a href="structpni_1_1is__index__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1is__index__types.html">is_index_types</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check a set of types for index  <a href="structpni_1_1is__index__types.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1is__valid__index.html">is_valid_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if valid index  <a href="structpni_1_1is__valid__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1is__view__index.html">is_view_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks for view index  <a href="structpni_1_1is__view__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1is__view__cont.html">is_view_cont</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if view index  <a href="structpni_1_1is__view__cont.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1is__view__cont_3_01std_1_1vector_3_01ElementT_01_4_01_4.html">is_view_cont&lt; std::vector&lt; ElementT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if view index  <a href="structpni_1_1is__view__cont_3_01std_1_1vector_3_01ElementT_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1is__view__cont_3_01std_1_1array_3_01ElementT_00_01TDimN_01_4_01_4.html">is_view_cont&lt; std::array&lt; ElementT, TDimN &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if view index  <a href="structpni_1_1is__view__cont_3_01std_1_1array_3_01ElementT_00_01TDimN_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1mdarray.html">mdarray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template for a multi-dimensional array class  <a href="classpni_1_1mdarray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1container__trait_3_01mdarray_3_01StorageT_00_01IndexMapT_00_01InplaceArithmeticT_01_4_01_4.html">container_trait&lt; mdarray&lt; StorageT, IndexMapT, InplaceArithmeticT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">container trait mdarray  <a href="structpni_1_1container__trait_3_01mdarray_3_01StorageT_00_01IndexMapT_00_01InplaceArithmeticT_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1scalar.html">scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar template for scalar values.  <a href="classpni_1_1scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">scalar iterator  <a href="classpni_1_1scalar__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1slice.html">slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">index slice  <a href="classpni_1_1slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1cbf__reader.html">cbf_reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base clase for CBF readers  <a href="classpni_1_1cbf__reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1column__info.html">column_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spreadsheet column information.  <a href="classpni_1_1column__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1container__io__config.html">container_io_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">container IO configuration  <a href="classpni_1_1container__io__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1data__reader.html">data_reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for data readers  <a href="classpni_1_1data__reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1exception__record.html">exception_record</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception record  <a href="classpni_1_1exception__record.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1exception.html">exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exceptions base class.  <a href="classpni_1_1exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1memory__allocation__error.html">memory_allocation_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory allocation error  <a href="classpni_1_1memory__allocation__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1memory__not__allocated__error.html">memory_not_allocated_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory not allocated error  <a href="classpni_1_1memory__not__allocated__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1shape__mismatch__error.html">shape_mismatch_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape mismatch error.  <a href="classpni_1_1shape__mismatch__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1size__mismatch__error.html">size_mismatch_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size mismatch error.  <a href="classpni_1_1size__mismatch__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1index__error.html">index_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">index error  <a href="classpni_1_1index__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1key__error.html">key_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">key error  <a href="classpni_1_1key__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1file__error.html">file_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">file IO fails  <a href="classpni_1_1file__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1type__error.html">type_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">data type error  <a href="classpni_1_1type__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1value__error.html">value_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">data value error  <a href="classpni_1_1value__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1range__error.html">range_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">data range error  <a href="classpni_1_1range__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1not__implemented__error.html">not_implemented_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">not implemented exception  <a href="classpni_1_1not__implemented__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1iterator__error.html">iterator_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator error  <a href="classpni_1_1iterator__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1cli__argument__error.html">cli_argument_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">command line argument error  <a href="classpni_1_1cli__argument__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1cli__option__error.html">cli_option_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">command line option error  <a href="classpni_1_1cli__option__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1cli__error.html">cli_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">general CLI error  <a href="classpni_1_1cli__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1cli__help__request.html">cli_help_request</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">help request  <a href="classpni_1_1cli__help__request.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1io__error.html">io_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">general IO error  <a href="classpni_1_1io__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1link__error.html">link_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">link error  <a href="classpni_1_1link__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1parser__error.html">parser_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">general parser related error  <a href="classpni_1_1parser__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1invalid__object__error.html">invalid_object_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">unexpected invalid object  <a href="classpni_1_1invalid__object__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1object__error.html">object_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">general error on IO objects  <a href="classpni_1_1object__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1fio__reader.html">fio_reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FIO data reader.  <a href="classpni_1_1fio__reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1format__config.html">format_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">describe numeric output format  <a href="classpni_1_1format__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1format__str.html">format_str</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1image__channel__info.html">image_channel_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">image channel information class  <a href="classpni_1_1image__channel__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1image__info.html">image_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">image information type  <a href="classpni_1_1image__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1image__reader.html">image_reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for image readers  <a href="classpni_1_1image__reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1parser_3_01pni_1_1bool__t_01_4.html">parser&lt; pni::bool_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser specialization for bool values  <a href="classpni_1_1parser_3_01pni_1_1bool__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1parser_3_01hdf5_1_1datatype_1_1EBool_01_4.html">parser&lt; hdf5::datatype::EBool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser specialization for bool values  <a href="classpni_1_1parser_3_01hdf5_1_1datatype_1_1EBool_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1parser_3_01std_1_1complex_3_01BaseT_01_4_01_4.html">parser&lt; std::complex&lt; BaseT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser specialization for complex numbers  <a href="classpni_1_1parser_3_01std_1_1complex_3_01BaseT_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1conversion__trait.html">conversion_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">default conversion trait  <a href="structpni_1_1conversion__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1conversion__trait_3_01pni_1_1uint8_01_4.html">conversion_trait&lt; pni::uint8 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">uint8 conversion trait  <a href="structpni_1_1conversion__trait_3_01pni_1_1uint8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1conversion__trait_3_01pni_1_1int8_01_4.html">conversion_trait&lt; pni::int8 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">int8 conversion trait  <a href="structpni_1_1conversion__trait_3_01pni_1_1int8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1parser.html">parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser for primitive types  <a href="classpni_1_1parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1parser_3_01pni_1_1slice_01_4.html">parser&lt; pni::slice &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1parser_3_01pni_1_1string_01_4.html">parser&lt; pni::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parsing strings  <a href="classpni_1_1parser_3_01pni_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1parser_3_01pni_1_1value_01_4.html">parser&lt; pni::value &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser for general values  <a href="classpni_1_1parser_3_01pni_1_1value_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1parser_3_01std_1_1vector_3_01ElementT_01_4_01_4.html">parser&lt; std::vector&lt; ElementT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::vector parser  <a href="classpni_1_1parser_3_01std_1_1vector_3_01ElementT_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1spreadsheet__reader.html">spreadsheet_reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for spreadsheet reader  <a href="classpni_1_1spreadsheet__reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1tiff__reader.html">tiff_reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TIFF file reader.  <a href="classpni_1_1tiff__reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">type erasure array types  <a href="classpni_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1array__holder.html">array_holder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">array holder template  <a href="classpni_1_1array__holder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1array__holder__interface.html">array_holder_interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">array holder interface  <a href="classpni_1_1array__holder__interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1array__iterator__types.html">array_iterator_types</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">type map for the <a class="el" href="classpni_1_1array__iterator.html" title="array iterator">array_iterator</a> template  <a href="structpni_1_1array__iterator__types.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1array__iterator__types_3_010_01_4.html">array_iterator_types&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">type map for a non-const <a class="el" href="classpni_1_1array__iterator.html" title="array iterator">array_iterator</a> instance  <a href="structpni_1_1array__iterator__types_3_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1array__iterator__types_3_011_01_4.html">array_iterator_types&lt; 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">type map for const <a class="el" href="classpni_1_1array__iterator.html" title="array iterator">array_iterator</a> instance  <a href="structpni_1_1array__iterator__types_3_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1array__iterator.html">array_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">array iterator  <a href="classpni_1_1array__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1value__converter.html">value_converter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">converter class  <a href="structpni_1_1value__converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1value__converter_3_01TargetT_00_01SourceT_00_01true_01_4.html">value_converter&lt; TargetT, SourceT, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">converter class specialization  <a href="structpni_1_1value__converter_3_01TargetT_00_01SourceT_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1value.html">value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">type erasure for POD data  <a href="classpni_1_1value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1is__reference__holder.html">is_reference_holder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if type is reference  <a href="structpni_1_1is__reference__holder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1is__reference__holder_3_01std_1_1reference__wrapper_3_01GeneralT_01_4_01_4.html">is_reference_holder&lt; std::reference_wrapper&lt; GeneralT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">chef if type is reference  <a href="structpni_1_1is__reference__holder_3_01std_1_1reference__wrapper_3_01GeneralT_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1get__reference__type.html">get_reference_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">get original type of reference  <a href="structpni_1_1get__reference__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1get__reference__type_3_01std_1_1reference__wrapper_3_01GeneralT_01_4_01_4.html">get_reference_type&lt; std::reference_wrapper&lt; GeneralT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the original type of reference  <a href="structpni_1_1get__reference__type_3_01std_1_1reference__wrapper_3_01GeneralT_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1value__holder.html">value_holder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of the holder interface  <a href="classpni_1_1value__holder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1value__holder__interface.html">value_holder_interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for data holder  <a href="classpni_1_1value__holder__interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1value__ref.html">value_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">type erasure for references to POD data  <a href="classpni_1_1value__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1binary__t.html">binary_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary data type.  <a href="classpni_1_1binary__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1bool__t.html">bool_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">boolean type  <a href="classpni_1_1bool__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1checked__convertible.html">checked_convertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if a type is unchecked convertible  <a href="structpni_1_1checked__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1container__trait.html">container_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">container trait  <a href="structpni_1_1container__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1container__trait_3_01std_1_1vector_3_01ArrayArgsT_8_8_8_01_4_01_4.html">container_trait&lt; std::vector&lt; ArrayArgsT... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">container trait for std::vector  <a href="structpni_1_1container__trait_3_01std_1_1vector_3_01ArrayArgsT_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1container__trait_3_01std_1_1array_3_01DataT_00_01TDimN_01_4_01_4.html">container_trait&lt; std::array&lt; DataT, TDimN &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">container trait for std::array  <a href="structpni_1_1container__trait_3_01std_1_1array_3_01DataT_00_01TDimN_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1container__trait_3_01std_1_1list_3_01ArrayArgsT_8_8_8_01_4_01_4.html">container_trait&lt; std::list&lt; ArrayArgsT... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">container trait for std::list  <a href="structpni_1_1container__trait_3_01std_1_1list_3_01ArrayArgsT_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1converter.html">converter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple numeric converter  <a href="structpni_1_1converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1converter_3_01TargetT_00_01TargetT_01_4.html">converter&lt; TargetT, TargetT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple numeric converter  <a href="structpni_1_1converter_3_01TargetT_00_01TargetT_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1converter_3_01std_1_1complex_3_01BaseT_01_4_00_01SourceT_01_4.html">converter&lt; std::complex&lt; BaseT &gt;, SourceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple to complex conversion  <a href="structpni_1_1converter_3_01std_1_1complex_3_01BaseT_01_4_00_01SourceT_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1converter_3_01std_1_1complex_3_01TargetBaseT_01_4_00_01std_1_1complex_3_01SourceBaseT_01_4_01_4.html">converter&lt; std::complex&lt; TargetBaseT &gt;, std::complex&lt; SourceBaseT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex to complex conversion  <a href="structpni_1_1converter_3_01std_1_1complex_3_01TargetBaseT_01_4_00_01std_1_1complex_3_01SourceBaseT_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1conversion__strategy.html">conversion_strategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple unchecked strategy  <a href="structpni_1_1conversion__strategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1conversion__strategy_3_01hdf5_1_1datatype_1_1EBool_00_01bool__t_00_01true_01_4.html">conversion_strategy&lt; hdf5::datatype::EBool, bool_t, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple unchecked strategy  <a href="structpni_1_1conversion__strategy_3_01hdf5_1_1datatype_1_1EBool_00_01bool__t_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1conversion__strategy_3_01TargetT_00_01SourceT_00_01false_01_4.html">conversion_strategy&lt; TargetT, SourceT, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">checked conversion strategy  <a href="structpni_1_1conversion__strategy_3_01TargetT_00_01SourceT_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1convertible.html">convertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if two types are convertible  <a href="structpni_1_1convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1id__type__map.html">id_type_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">map from type_id_t to type  <a href="structpni_1_1id__type__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1none.html">none</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">none type  <a href="structpni_1_1none.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1is__integer__type.html">is_integer_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check integer type  <a href="structpni_1_1is__integer__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1is__float__type.html">is_float_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check float type  <a href="structpni_1_1is__float__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1is__complex__type.html">is_complex_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check complex type  <a href="structpni_1_1is__complex__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1is__numeric__type.html">is_numeric_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check numeric type  <a href="structpni_1_1is__numeric__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1is__non__numeric__type.html">is_non_numeric_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check non numeric type  <a href="structpni_1_1is__non__numeric__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1is__primitive__type.html">is_primitive_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check primitive type  <a href="structpni_1_1is__primitive__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1type__class__map.html">type_class_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">type to class mapping  <a href="structpni_1_1type__class__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1type__id__map.html">type_id_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">map from a type to type_id  <a href="structpni_1_1type__id__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1min__max.html">min_max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">get minimum and maximum  <a href="structpni_1_1min__max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1min__max_3_01FloatT_00_01true_01_4.html">min_max&lt; FloatT, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">get minimum and maximum for floats  <a href="structpni_1_1min__max_3_01FloatT_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1type__info.html">type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">type information class  <a href="structpni_1_1type__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1unchecked__convertible.html">unchecked_convertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if a type is unchecked convertible  <a href="structpni_1_1unchecked__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1type__id__container__builder.html">type_id_container_builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">type id container builder  <a href="classpni_1_1type__id__container__builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpni_1_1container__iterator.html">container_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator type  <a href="classpni_1_1container__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1container__utils.html">container_utils</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">container utility  <a href="structpni_1_1container__utils.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1container__utils_3_01std_1_1array_3_01ElementT_00_01TDimN_01_4_01_4.html">container_utils&lt; std::array&lt; ElementT, TDimN &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">container utility for std::array  <a href="structpni_1_1container__utils_3_01std_1_1array_3_01ElementT_00_01TDimN_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1or__t.html">or_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">or type  <a href="structpni_1_1or__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1and__t.html">and_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">and type  <a href="structpni_1_1and__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpni_1_1not__t.html">not_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">logical not  <a href="structpni_1_1not__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa5cc1016cb8fd406cb452d43404b3d92"><td class="memTemplParams" colspan="2">template&lt;typename GeneralT &gt; </td></tr>
<tr class="memitem:aa5cc1016cb8fd406cb452d43404b3d92"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a> = typename GeneralT::map_type</td></tr>
<tr class="separator:aa5cc1016cb8fd406cb452d43404b3d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf6c4315f702282de1f3d497da35bdc"><td class="memTemplParams" colspan="2">template&lt;typename GeneralT &gt; </td></tr>
<tr class="memitem:a2bf6c4315f702282de1f3d497da35bdc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a> = typename GeneralT::inplace_arithmetic</td></tr>
<tr class="separator:a2bf6c4315f702282de1f3d497da35bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2add101c915d69fa25c2910e928ec64"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT , typename ... IndicesT&gt; </td></tr>
<tr class="memitem:ab2add101c915d69fa25c2910e928ec64"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#ab2add101c915d69fa25c2910e928ec64">view_type_trait</a> = <a class="el" href="structpni_1_1array__view__trait.html">array_view_trait</a>&lt; ArrayT, <a class="el" href="structpni_1_1is__view__index.html">is_view_index</a>&lt; IndicesT... &gt;::<a class="el" href="classpni_1_1value.html">value</a> &gt;</td></tr>
<tr class="separator:ab2add101c915d69fa25c2910e928ec64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f21710a0fe72bfafff2547b716f0cba"><td class="memTemplParams" colspan="2">template&lt;typename ... IndicesT&gt; </td></tr>
<tr class="memitem:a9f21710a0fe72bfafff2547b716f0cba"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a9f21710a0fe72bfafff2547b716f0cba">enable_valid_index</a> = std::enable_if&lt; <a class="el" href="structpni_1_1is__index__types.html">is_index_types</a>&lt; IndicesT... &gt;::<a class="el" href="classpni_1_1value.html">value</a> &gt;</td></tr>
<tr class="separator:a9f21710a0fe72bfafff2547b716f0cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1a82e22b12383c82b3999ea22ee743"><td class="memTemplParams" colspan="2">template&lt;size_t... TDimsN&gt; </td></tr>
<tr class="memitem:a1c1a82e22b12383c82b3999ea22ee743"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a1c1a82e22b12383c82b3999ea22ee743">static_cindex_map</a> = <a class="el" href="classpni_1_1static__index__map.html">static_index_map</a>&lt; <a class="el" href="classpni_1_1c__index__map__imp.html">c_index_map_imp</a>, TDimsN... &gt;</td></tr>
<tr class="memdesc:a1c1a82e22b12383c82b3999ea22ee743"><td class="mdescLeft">&#160;</td><td class="mdescRight">template for a static C map  <a href="namespacepni.html#a1c1a82e22b12383c82b3999ea22ee743">More...</a><br /></td></tr>
<tr class="separator:a1c1a82e22b12383c82b3999ea22ee743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3faaeeab1697a73b1c67aa3207b7a5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpni_1_1index__map.html">index_map</a>&lt; std::vector&lt; size_t &gt;, <a class="el" href="classpni_1_1c__index__map__imp.html">c_index_map_imp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#ace3faaeeab1697a73b1c67aa3207b7a5">dynamic_cindex_map</a></td></tr>
<tr class="memdesc:ace3faaeeab1697a73b1c67aa3207b7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">definition of a dynamic C index map  <a href="namespacepni.html#ace3faaeeab1697a73b1c67aa3207b7a5">More...</a><br /></td></tr>
<tr class="separator:ace3faaeeab1697a73b1c67aa3207b7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce756fde1af52ab903eb6791b25953f"><td class="memTemplParams" colspan="2">template&lt;size_t TDimN&gt; </td></tr>
<tr class="memitem:a7ce756fde1af52ab903eb6791b25953f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a7ce756fde1af52ab903eb6791b25953f">fixed_dim_cindex_map</a> = <a class="el" href="classpni_1_1index__map.html">index_map</a>&lt; std::array&lt; size_t, TDimN &gt;, <a class="el" href="classpni_1_1c__index__map__imp.html">c_index_map_imp</a> &gt;</td></tr>
<tr class="memdesc:a7ce756fde1af52ab903eb6791b25953f"><td class="mdescLeft">&#160;</td><td class="mdescRight">fixed dimension dynamic C index map  <a href="namespacepni.html#a7ce756fde1af52ab903eb6791b25953f">More...</a><br /></td></tr>
<tr class="separator:a7ce756fde1af52ab903eb6791b25953f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d92927e138276c273cdc7e98c6f09bb"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT &gt; </td></tr>
<tr class="memitem:a2d92927e138276c273cdc7e98c6f09bb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a2d92927e138276c273cdc7e98c6f09bb">enable_element_cont</a> = std::enable_if&lt;!<a class="el" href="structpni_1_1is__index__type.html">is_index_type</a>&lt; ContainerT &gt;::<a class="el" href="classpni_1_1value.html">value</a> &amp;&amp;!<a class="el" href="structpni_1_1is__view__cont.html">is_view_cont</a>&lt; ContainerT &gt;::<a class="el" href="classpni_1_1value.html">value</a> &gt;</td></tr>
<tr class="memdesc:a2d92927e138276c273cdc7e98c6f09bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINA - use for element access.  <a href="namespacepni.html#a2d92927e138276c273cdc7e98c6f09bb">More...</a><br /></td></tr>
<tr class="separator:a2d92927e138276c273cdc7e98c6f09bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecfeacffc28b66bbbdd7e27af38113b"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT &gt; </td></tr>
<tr class="memitem:aaecfeacffc28b66bbbdd7e27af38113b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#aaecfeacffc28b66bbbdd7e27af38113b">enable_view_cont</a> = std::enable_if&lt;!<a class="el" href="structpni_1_1is__index__type.html">is_index_type</a>&lt; ContainerT &gt;::<a class="el" href="classpni_1_1value.html">value</a> &amp;&amp;<a class="el" href="structpni_1_1is__view__cont.html">is_view_cont</a>&lt; ContainerT &gt;::<a class="el" href="classpni_1_1value.html">value</a> &gt;</td></tr>
<tr class="memdesc:aaecfeacffc28b66bbbdd7e27af38113b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINA - use for view access.  <a href="namespacepni.html#aaecfeacffc28b66bbbdd7e27af38113b">More...</a><br /></td></tr>
<tr class="separator:aaecfeacffc28b66bbbdd7e27af38113b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa0215db65153bfad1d6e8ea655bf4c"><td class="memTemplParams" colspan="2">template&lt;typename ElementT &gt; </td></tr>
<tr class="memitem:adfa0215db65153bfad1d6e8ea655bf4c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#adfa0215db65153bfad1d6e8ea655bf4c">dynamic_array</a> = <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; std::vector&lt; ElementT &gt;, <a class="el" href="namespacepni.html#ace3faaeeab1697a73b1c67aa3207b7a5">dynamic_cindex_map</a> &gt;</td></tr>
<tr class="memdesc:adfa0215db65153bfad1d6e8ea655bf4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">a dynamic array template  <a href="namespacepni.html#adfa0215db65153bfad1d6e8ea655bf4c">More...</a><br /></td></tr>
<tr class="separator:adfa0215db65153bfad1d6e8ea655bf4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3aea22461538ee4d1f82521b4959c3"><td class="memTemplParams" colspan="2">template&lt;typename ElementT , size_t TDimN&gt; </td></tr>
<tr class="memitem:a1f3aea22461538ee4d1f82521b4959c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a1f3aea22461538ee4d1f82521b4959c3">fixed_dim_array</a> = <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; std::vector&lt; ElementT &gt;, <a class="el" href="namespacepni.html#a7ce756fde1af52ab903eb6791b25953f">fixed_dim_cindex_map</a>&lt; TDimN &gt; &gt;</td></tr>
<tr class="memdesc:a1f3aea22461538ee4d1f82521b4959c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">array template with fixed dimension  <a href="namespacepni.html#a1f3aea22461538ee4d1f82521b4959c3">More...</a><br /></td></tr>
<tr class="separator:a1f3aea22461538ee4d1f82521b4959c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e1a86e625a986d556f76ccdfc64c39"><td class="memTemplParams" colspan="2">template&lt;typename ElementT , size_t... TDimsN&gt; </td></tr>
<tr class="memitem:ab7e1a86e625a986d556f76ccdfc64c39"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#ab7e1a86e625a986d556f76ccdfc64c39">static_array</a> = <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; std::array&lt; ElementT, boost::mpl::times&lt; boost::mpl::size_t&lt; 1 &gt;, boost::mpl::size_t&lt; TDimsN &gt;... &gt;::<a class="el" href="classpni_1_1value.html">value</a> &gt;, <a class="el" href="namespacepni.html#a1c1a82e22b12383c82b3999ea22ee743">static_cindex_map</a>&lt; TDimsN... &gt; &gt;</td></tr>
<tr class="memdesc:ab7e1a86e625a986d556f76ccdfc64c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">static array template  <a href="namespacepni.html#ab7e1a86e625a986d556f76ccdfc64c39">More...</a><br /></td></tr>
<tr class="separator:ab7e1a86e625a986d556f76ccdfc64c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ee4ed2a773d68844b7d9d68fc94066"><td class="memTemplParams" colspan="2">template&lt;typename TargetT , typename SourceT &gt; </td></tr>
<tr class="memitem:a08ee4ed2a773d68844b7d9d68fc94066"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a08ee4ed2a773d68844b7d9d68fc94066">strategy</a> = <a class="el" href="structpni_1_1value__converter.html">value_converter</a>&lt; TargetT, SourceT, <a class="el" href="structpni_1_1convertible.html">convertible</a>&lt; SourceT, TargetT &gt;::<a class="el" href="classpni_1_1value.html">value</a> &gt;</td></tr>
<tr class="separator:a08ee4ed2a773d68844b7d9d68fc94066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e71c9ac38fabb17416cef2f0e1b3d33"><td class="memTemplParams" colspan="2">template&lt;typename GeneralT &gt; </td></tr>
<tr class="memitem:a3e71c9ac38fabb17416cef2f0e1b3d33"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a3e71c9ac38fabb17416cef2f0e1b3d33">ref_type</a> = std::reference_wrapper&lt; GeneralT &gt;</td></tr>
<tr class="memdesc:a3e71c9ac38fabb17416cef2f0e1b3d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">alias for std::reference_wrapper  <a href="namespacepni.html#a3e71c9ac38fabb17416cef2f0e1b3d33">More...</a><br /></td></tr>
<tr class="separator:a3e71c9ac38fabb17416cef2f0e1b3d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471ed8f87fcfdf66db099a21b5e6d7cc"><td class="memItemLeft" align="right" valign="top">typedef boost::mpl::map&lt; boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>, <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>, <a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>, <a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>, <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>, <a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>, <a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>, <a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>, <a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>, <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>, <a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>, <a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>, <a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>, <a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>, <a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>, <a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>, <a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>, <a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>, <a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>, <a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>, <a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>, <a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>, <a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>, <a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>, <a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>, <a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>, <a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>, <a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>, boost::mpl::vector&lt;&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>, <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>, <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>, boost::mpl::vector&lt;&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>, <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">string</a>, boost::mpl::vector&lt;&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gab80fde605a35ad90da1651d7d3c67893">binary</a>, boost::mpl::vector&lt;&gt; &gt;, boost::mpl::pair&lt; hdf5::datatype::EBool, boost::mpl::vector&lt;&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="classpni_1_1bool__t.html">bool_t</a>, boost::mpl::vector&lt;&gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a471ed8f87fcfdf66db099a21b5e6d7cc">checked_type_vectors</a></td></tr>
<tr class="memdesc:a471ed8f87fcfdf66db099a21b5e6d7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">unchecked convertible map  <a href="namespacepni.html#a471ed8f87fcfdf66db099a21b5e6d7cc">More...</a><br /></td></tr>
<tr class="separator:a471ed8f87fcfdf66db099a21b5e6d7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc41483281916729dac71199de27a884"><td class="memItemLeft" align="right" valign="top">typedef int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a></td></tr>
<tr class="memdesc:gadc41483281916729dac71199de27a884"><td class="mdescLeft">&#160;</td><td class="mdescRight">8Bit signed integer type  <a href="group__type__classes.html#gadc41483281916729dac71199de27a884">More...</a><br /></td></tr>
<tr class="separator:gadc41483281916729dac71199de27a884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa09dcc7c9c6d956f63dc58e69b63beef"><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a></td></tr>
<tr class="memdesc:gaa09dcc7c9c6d956f63dc58e69b63beef"><td class="mdescLeft">&#160;</td><td class="mdescRight">8Bit unsigned integer type  <a href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">More...</a><br /></td></tr>
<tr class="separator:gaa09dcc7c9c6d956f63dc58e69b63beef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad97af124f0e4bca840c4b81c7c6f2bf9"><td class="memItemLeft" align="right" valign="top">typedef int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a></td></tr>
<tr class="memdesc:gad97af124f0e4bca840c4b81c7c6f2bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">16Bit signed integer type  <a href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">More...</a><br /></td></tr>
<tr class="separator:gad97af124f0e4bca840c4b81c7c6f2bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf02f3cfedbee1cd96303e05dfbd05071"><td class="memItemLeft" align="right" valign="top">typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a></td></tr>
<tr class="memdesc:gaf02f3cfedbee1cd96303e05dfbd05071"><td class="mdescLeft">&#160;</td><td class="mdescRight">16Bit unsigned integer type  <a href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">More...</a><br /></td></tr>
<tr class="separator:gaf02f3cfedbee1cd96303e05dfbd05071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaecf8173ee4a475c2bff223970df70a"><td class="memItemLeft" align="right" valign="top">typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a></td></tr>
<tr class="memdesc:gadaecf8173ee4a475c2bff223970df70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">32Bit signed integer type  <a href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">More...</a><br /></td></tr>
<tr class="separator:gadaecf8173ee4a475c2bff223970df70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10d54cdbcb0882e67496d0febe62a8f2"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a></td></tr>
<tr class="memdesc:ga10d54cdbcb0882e67496d0febe62a8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">32Bit unsigned integer type  <a href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">More...</a><br /></td></tr>
<tr class="separator:ga10d54cdbcb0882e67496d0febe62a8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92b286022d3b0449bce9604e3fda1041"><td class="memItemLeft" align="right" valign="top">typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a></td></tr>
<tr class="memdesc:ga92b286022d3b0449bce9604e3fda1041"><td class="mdescLeft">&#160;</td><td class="mdescRight">64Bit signed integer type  <a href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">More...</a><br /></td></tr>
<tr class="separator:ga92b286022d3b0449bce9604e3fda1041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06fcb67ea94591221414d48df372aa2b"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a></td></tr>
<tr class="memdesc:ga06fcb67ea94591221414d48df372aa2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">64Bit unsigned integer type  <a href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">More...</a><br /></td></tr>
<tr class="separator:ga06fcb67ea94591221414d48df372aa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga297fd4128dac28f23f2febf84de403d2"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a></td></tr>
<tr class="memdesc:ga297fd4128dac28f23f2febf84de403d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">64Bit IEEE floating point type  <a href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">More...</a><br /></td></tr>
<tr class="separator:ga297fd4128dac28f23f2febf84de403d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad937fd925b713d62317701414eb68508"><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a></td></tr>
<tr class="memdesc:gad937fd925b713d62317701414eb68508"><td class="mdescLeft">&#160;</td><td class="mdescRight">32Bit IEEE floating point type  <a href="group__type__classes.html#gad937fd925b713d62317701414eb68508">More...</a><br /></td></tr>
<tr class="separator:gad937fd925b713d62317701414eb68508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8196c51301aa89481579aa2486d34e28"><td class="memItemLeft" align="right" valign="top">typedef long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a></td></tr>
<tr class="memdesc:ga8196c51301aa89481579aa2486d34e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">128Bit IEEE floating point type  <a href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">More...</a><br /></td></tr>
<tr class="separator:ga8196c51301aa89481579aa2486d34e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f3e309490ff7ed71029d40375c5e46"><td class="memItemLeft" align="right" valign="top">typedef std::complex&lt; <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a></td></tr>
<tr class="memdesc:gaf4f3e309490ff7ed71029d40375c5e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">32Bit complex floating point type  <a href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">More...</a><br /></td></tr>
<tr class="separator:gaf4f3e309490ff7ed71029d40375c5e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga196dbc1a828935ea6fa75ff419f52686"><td class="memItemLeft" align="right" valign="top">typedef std::complex&lt; <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a></td></tr>
<tr class="memdesc:ga196dbc1a828935ea6fa75ff419f52686"><td class="mdescLeft">&#160;</td><td class="mdescRight">64Bit complex floating point type  <a href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">More...</a><br /></td></tr>
<tr class="separator:ga196dbc1a828935ea6fa75ff419f52686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93af677cfc058639b20efe51e82b0226"><td class="memItemLeft" align="right" valign="top">typedef std::complex&lt; <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a></td></tr>
<tr class="memdesc:ga93af677cfc058639b20efe51e82b0226"><td class="mdescLeft">&#160;</td><td class="mdescRight">128Bit complex floating point type  <a href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">More...</a><br /></td></tr>
<tr class="separator:ga93af677cfc058639b20efe51e82b0226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae86d1ac54b7b94227f4e32f2129bb534"><td class="memItemLeft" align="right" valign="top">typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">string</a></td></tr>
<tr class="memdesc:gae86d1ac54b7b94227f4e32f2129bb534"><td class="mdescLeft">&#160;</td><td class="mdescRight">String type.  <a href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">More...</a><br /></td></tr>
<tr class="separator:gae86d1ac54b7b94227f4e32f2129bb534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab80fde605a35ad90da1651d7d3c67893"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; <a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gab80fde605a35ad90da1651d7d3c67893">binary</a></td></tr>
<tr class="memdesc:gab80fde605a35ad90da1651d7d3c67893"><td class="mdescLeft">&#160;</td><td class="mdescRight">data type for binary data  <a href="group__type__classes.html#gab80fde605a35ad90da1651d7d3c67893">More...</a><br /></td></tr>
<tr class="separator:gab80fde605a35ad90da1651d7d3c67893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbd5a595aaf93f47266269949891c095"><td class="memItemLeft" align="right" valign="top">typedef boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>, <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>, <a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>, <a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>, <a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>, <a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>, <a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, <a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gacbd5a595aaf93f47266269949891c095">integer_types</a></td></tr>
<tr class="memdesc:gacbd5a595aaf93f47266269949891c095"><td class="mdescLeft">&#160;</td><td class="mdescRight">integer types vector  <a href="group__type__classes.html#gacbd5a595aaf93f47266269949891c095">More...</a><br /></td></tr>
<tr class="separator:gacbd5a595aaf93f47266269949891c095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cd12e7454f454f54cf60c73bcf1ac48"><td class="memItemLeft" align="right" valign="top">typedef boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>, <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>, <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga6cd12e7454f454f54cf60c73bcf1ac48">float_types</a></td></tr>
<tr class="memdesc:ga6cd12e7454f454f54cf60c73bcf1ac48"><td class="mdescLeft">&#160;</td><td class="mdescRight">floating point types vector  <a href="group__type__classes.html#ga6cd12e7454f454f54cf60c73bcf1ac48">More...</a><br /></td></tr>
<tr class="separator:ga6cd12e7454f454f54cf60c73bcf1ac48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80975620717157177504f25ebeb5bf42"><td class="memItemLeft" align="right" valign="top">typedef boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>, <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga80975620717157177504f25ebeb5bf42">complex_types</a></td></tr>
<tr class="memdesc:ga80975620717157177504f25ebeb5bf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex types vector  <a href="group__type__classes.html#ga80975620717157177504f25ebeb5bf42">More...</a><br /></td></tr>
<tr class="separator:ga80975620717157177504f25ebeb5bf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58fbe5d75590006cbac83b07014da1ba"><td class="memItemLeft" align="right" valign="top">typedef boost::mpl::joint_view&lt; boost::mpl::joint_view&lt; <a class="el" href="group__type__classes.html#gacbd5a595aaf93f47266269949891c095">integer_types</a>, <a class="el" href="group__type__classes.html#ga6cd12e7454f454f54cf60c73bcf1ac48">float_types</a> &gt;::type, <a class="el" href="group__type__classes.html#ga80975620717157177504f25ebeb5bf42">complex_types</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga58fbe5d75590006cbac83b07014da1ba">numeric_types</a></td></tr>
<tr class="memdesc:ga58fbe5d75590006cbac83b07014da1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">non numeric types vector  <a href="group__type__classes.html#ga58fbe5d75590006cbac83b07014da1ba">More...</a><br /></td></tr>
<tr class="separator:ga58fbe5d75590006cbac83b07014da1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9406166148f118a22958b77118fbdac6"><td class="memItemLeft" align="right" valign="top">typedef boost::mpl::vector&lt; <a class="el" href="structpni_1_1none.html">none</a>, <a class="el" href="classpni_1_1bool__t.html">bool_t</a>, hdf5::datatype::EBool, <a class="el" href="group__type__classes.html#gab80fde605a35ad90da1651d7d3c67893">binary</a>, <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga9406166148f118a22958b77118fbdac6">non_numeric_types</a></td></tr>
<tr class="memdesc:ga9406166148f118a22958b77118fbdac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">non numeric types  <a href="group__type__classes.html#ga9406166148f118a22958b77118fbdac6">More...</a><br /></td></tr>
<tr class="separator:ga9406166148f118a22958b77118fbdac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c2c225bf1677084f0b32e684726625"><td class="memItemLeft" align="right" valign="top">typedef boost::mpl::joint_view&lt; <a class="el" href="group__type__classes.html#ga58fbe5d75590006cbac83b07014da1ba">numeric_types</a>, <a class="el" href="group__type__classes.html#ga9406166148f118a22958b77118fbdac6">non_numeric_types</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga09c2c225bf1677084f0b32e684726625">primitive_types</a></td></tr>
<tr class="memdesc:ga09c2c225bf1677084f0b32e684726625"><td class="mdescLeft">&#160;</td><td class="mdescRight">all primitive types  <a href="group__type__classes.html#ga09c2c225bf1677084f0b32e684726625">More...</a><br /></td></tr>
<tr class="separator:ga09c2c225bf1677084f0b32e684726625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5c35e86d7bd211daf1b949d3e3fc8e"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a5b5c35e86d7bd211daf1b949d3e3fc8e">shape_t</a></td></tr>
<tr class="memdesc:a5b5c35e86d7bd211daf1b949d3e3fc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">standard type for array shapes  <a href="namespacepni.html#a5b5c35e86d7bd211daf1b949d3e3fc8e">More...</a><br /></td></tr>
<tr class="separator:a5b5c35e86d7bd211daf1b949d3e3fc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4d2e0269b02f54bd50ef1524bbd5ce"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#aeb4d2e0269b02f54bd50ef1524bbd5ce">shape_type</a></td></tr>
<tr class="memdesc:aeb4d2e0269b02f54bd50ef1524bbd5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">another alias for the standard shape type  <a href="namespacepni.html#aeb4d2e0269b02f54bd50ef1524bbd5ce">More...</a><br /></td></tr>
<tr class="separator:aeb4d2e0269b02f54bd50ef1524bbd5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d0bf11cc81f22d64c89a44a5143858"><td class="memItemLeft" align="right" valign="top">typedef boost::mpl::map&lt; boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>, <a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>, <a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>, <a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, <a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>, <a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>, <a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>, <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>, <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>, <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>, <a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>, <a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, <a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>, <a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>, <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>, <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>, <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>, <a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, <a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>, <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>, <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>, <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>, <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>, <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>, <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>, <a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>, <a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>, <a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>, <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>, <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>, <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>, <a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>, <a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>, <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>, <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>, <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>, <a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>, <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>, <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>, <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>, <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>, <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>, <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>, <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>, <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>, <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>, <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>, <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">string</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">string</a> &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="classpni_1_1bool__t.html">bool_t</a>, boost::mpl::vector&lt; <a class="el" href="classpni_1_1bool__t.html">bool_t</a>, hdf5::datatype::EBool &gt; &gt;, boost::mpl::pair&lt; hdf5::datatype::EBool, boost::mpl::vector&lt; <a class="el" href="classpni_1_1bool__t.html">bool_t</a>, hdf5::datatype::EBool &gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gab80fde605a35ad90da1651d7d3c67893">binary</a>, boost::mpl::vector&lt; <a class="el" href="group__type__classes.html#gab80fde605a35ad90da1651d7d3c67893">binary</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a42d0bf11cc81f22d64c89a44a5143858">unchecked_type_vectors</a></td></tr>
<tr class="memdesc:a42d0bf11cc81f22d64c89a44a5143858"><td class="mdescLeft">&#160;</td><td class="mdescRight">unchecked convertible map  <a href="namespacepni.html#a42d0bf11cc81f22d64c89a44a5143858">More...</a><br /></td></tr>
<tr class="separator:a42d0bf11cc81f22d64c89a44a5143858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a619e389a5e7f8600cf10857da88db"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a92a619e389a5e7f8600cf10857da88db">type_id_vector</a></td></tr>
<tr class="separator:a92a619e389a5e7f8600cf10857da88db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5ed7f9b2316a8c64ff063f59271574"><td class="memTemplParams" colspan="2">template&lt;typename MetafunctionT &gt; </td></tr>
<tr class="memitem:aaf5ed7f9b2316a8c64ff063f59271574"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#aaf5ed7f9b2316a8c64ff063f59271574">invoke</a> = typename MetafunctionT::type</td></tr>
<tr class="memdesc:aaf5ed7f9b2316a8c64ff063f59271574"><td class="mdescLeft">&#160;</td><td class="mdescRight">alias to invoke a metafunction  <a href="namespacepni.html#aaf5ed7f9b2316a8c64ff063f59271574">More...</a><br /></td></tr>
<tr class="separator:aaf5ed7f9b2316a8c64ff063f59271574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9ea31f62e69214bab4247566bc40b3"><td class="memTemplParams" colspan="2">template&lt;typename GeneralT &gt; </td></tr>
<tr class="memitem:aec9ea31f62e69214bab4247566bc40b3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#aec9ea31f62e69214bab4247566bc40b3">enable_if</a> = <a class="el" href="namespacepni.html#aaf5ed7f9b2316a8c64ff063f59271574">invoke</a>&lt; std::enable_if&lt; GeneralT::value &gt; &gt;</td></tr>
<tr class="memdesc:aec9ea31f62e69214bab4247566bc40b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">shortcut for std::enable_if  <a href="namespacepni.html#aec9ea31f62e69214bab4247566bc40b3">More...</a><br /></td></tr>
<tr class="separator:aec9ea31f62e69214bab4247566bc40b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2fe59951e962490d8ba70db87bccb4"><td class="memTemplParams" colspan="2">template&lt;typename GeneralT &gt; </td></tr>
<tr class="memitem:aeb2fe59951e962490d8ba70db87bccb4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#aeb2fe59951e962490d8ba70db87bccb4">is_pod</a> = std::is_pod&lt; GeneralT &gt;</td></tr>
<tr class="memdesc:aeb2fe59951e962490d8ba70db87bccb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">shortcut for std::is_pod  <a href="namespacepni.html#aeb2fe59951e962490d8ba70db87bccb4">More...</a><br /></td></tr>
<tr class="separator:aeb2fe59951e962490d8ba70db87bccb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d78931b0153c505233cf06f62a77958"><td class="memTemplParams" colspan="2">template&lt;typename GeneralT &gt; </td></tr>
<tr class="memitem:a3d78931b0153c505233cf06f62a77958"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a3d78931b0153c505233cf06f62a77958">is_ptr</a> = std::is_pointer&lt; GeneralT &gt;</td></tr>
<tr class="memdesc:a3d78931b0153c505233cf06f62a77958"><td class="mdescLeft">&#160;</td><td class="mdescRight">shortcut for std::is_pointer  <a href="namespacepni.html#a3d78931b0153c505233cf06f62a77958">More...</a><br /></td></tr>
<tr class="separator:a3d78931b0153c505233cf06f62a77958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b31ab9efef75d51b135757e7f80f74"><td class="memTemplParams" colspan="2">template&lt;typename GeneralT &gt; </td></tr>
<tr class="memitem:a55b31ab9efef75d51b135757e7f80f74"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a55b31ab9efef75d51b135757e7f80f74">is_cmplx</a> = <a class="el" href="structpni_1_1is__complex__type.html">is_complex_type</a>&lt; GeneralT &gt;</td></tr>
<tr class="memdesc:a55b31ab9efef75d51b135757e7f80f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">shortcut for is_complex  <a href="namespacepni.html#a55b31ab9efef75d51b135757e7f80f74">More...</a><br /></td></tr>
<tr class="separator:a55b31ab9efef75d51b135757e7f80f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2c8ca0de37c42914554a1a9e500b31cd"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> { <br />
&#160;&#160;<a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cda6adf97f83acf6453d4a6a4b1070f3754">None</a>
, <a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cda7d839b2c12bfd40ac121b4cc9e81c539">Int8</a>
, <a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cdab31df9c476d20e85ff898121efe11b5a">UInt8</a>
, <a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cda39bc2ae44b184207f560ff8619823208">Int16</a>
, <br />
&#160;&#160;<a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cda8bd950a9d7779b83f5c30046c9aaf1cf">UInt16</a>
, <a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cdac06129f6e6e15c09328365e553f1dc31">Int32</a>
, <a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cdae7956ed7be1c5025a27ed3cb42a396bd">UInt32</a>
, <a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cdafbde23b11d7e59af7828e81144c8b487">Int64</a>
, <br />
&#160;&#160;<a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cdaaf71234725f0470ccf993e263a8b820a">UInt64</a>
, <a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cda166495adc0d0f53bee6baecc577f5204">Float32</a>
, <a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cdad2b556d8a8f5c8ac323f51a4b82e79a0">Float64</a>
, <a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cdae74f68ddb36c1ed379de92ae3b589d34">Float128</a>
, <br />
&#160;&#160;<a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cda2ef2a9d5fdeebb762c9b0bc85c533ba1">Complex32</a>
, <a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cdad966dd0f6dc22b834b636fb9df4b756a">Complex64</a>
, <a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cdaee63a91375f038924d9671f9fec7059b">Complex128</a>
, <a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cda27118326006d3829667a400ad23d5d98">String</a>
, <br />
&#160;&#160;<a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cda6ce976e8f061b2b5cfe4d0c50c3405dd">Binary</a>
, <a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cdac26f15e86e3de4c398a8273272aba034">Bool</a>
, <a class="el" href="group__type__classes.html#gga2c8ca0de37c42914554a1a9e500b31cdae9ea9a7e4f8a765f1765d6f7a2ea187e">EBool</a>
<br />
 }</td></tr>
<tr class="memdesc:ga2c8ca0de37c42914554a1a9e500b31cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">type codes for PNI data types  <a href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">More...</a><br /></td></tr>
<tr class="separator:ga2c8ca0de37c42914554a1a9e500b31cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1642c8c1645f56b86fac5837490b408d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga1642c8c1645f56b86fac5837490b408d">type_class_t</a> { <br />
&#160;&#160;<a class="el" href="group__type__classes.html#gga1642c8c1645f56b86fac5837490b408da6adf97f83acf6453d4a6a4b1070f3754">None</a>
, <a class="el" href="group__type__classes.html#gga1642c8c1645f56b86fac5837490b408daa0faef0851b4294c06f2b94bb1cb2044">Integer</a>
, <a class="el" href="group__type__classes.html#gga1642c8c1645f56b86fac5837490b408da22ae0e2b89e5e3d477f988cc36d3272b">Float</a>
, <a class="el" href="group__type__classes.html#gga1642c8c1645f56b86fac5837490b408da6ce976e8f061b2b5cfe4d0c50c3405dd">Binary</a>
, <br />
&#160;&#160;<a class="el" href="group__type__classes.html#gga1642c8c1645f56b86fac5837490b408dac26f15e86e3de4c398a8273272aba034">Bool</a>
, <a class="el" href="group__type__classes.html#gga1642c8c1645f56b86fac5837490b408da10b4eb76294b70d7fd6df997ff06edb1">Complex</a>
, <a class="el" href="group__type__classes.html#gga1642c8c1645f56b86fac5837490b408da27118326006d3829667a400ad23d5d98">String</a>
<br />
 }</td></tr>
<tr class="memdesc:ga1642c8c1645f56b86fac5837490b408d"><td class="mdescLeft">&#160;</td><td class="mdescRight">type class definitions  <a href="group__type__classes.html#ga1642c8c1645f56b86fac5837490b408d">More...</a><br /></td></tr>
<tr class="separator:ga1642c8c1645f56b86fac5837490b408d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0b6c5498471b2c76b348ab3f7706c65c"><td class="memTemplParams" colspan="2">template&lt;typename LHSArrayT , typename RHSArrayT , typename  = enable_if&lt;and_t&lt;is_array&lt;LHSArrayT&gt;,is_array&lt;RHSArrayT&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a0b6c5498471b2c76b348ab3f7706c65c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; <a class="el" href="classpni_1_1add__op.html">add_op</a>&lt; LHSArrayT, RHSArrayT &gt;, <a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt; LHSArrayT &gt;, <a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt; LHSArrayT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a0b6c5498471b2c76b348ab3f7706c65c">operator+</a> (const LHSArrayT &amp;a, const RHSArrayT &amp;b)</td></tr>
<tr class="memdesc:a0b6c5498471b2c76b348ab3f7706c65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary addition operator  <a href="namespacepni.html#a0b6c5498471b2c76b348ab3f7706c65c">More...</a><br /></td></tr>
<tr class="separator:a0b6c5498471b2c76b348ab3f7706c65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd82bb004077c2d8e8b659f8c785ab95"><td class="memTemplParams" colspan="2">template&lt;typename LHSArrayT , typename ScalarT , typename  = enable_if&lt;and_t&lt;                        is_array&lt;LHSArrayT&gt;,not_t&lt;is_array&lt;ScalarT&gt;&gt;                         &gt;&gt;&gt; </td></tr>
<tr class="memitem:afd82bb004077c2d8e8b659f8c785ab95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; <a class="el" href="classpni_1_1add__op.html">add_op</a>&lt; LHSArrayT, <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ScalarT &gt; &gt;, <a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt; LHSArrayT &gt;, <a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt; LHSArrayT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#afd82bb004077c2d8e8b659f8c785ab95">operator+</a> (const LHSArrayT &amp;a, const ScalarT &amp;b)</td></tr>
<tr class="memdesc:afd82bb004077c2d8e8b659f8c785ab95"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary addition operator  <a href="namespacepni.html#afd82bb004077c2d8e8b659f8c785ab95">More...</a><br /></td></tr>
<tr class="separator:afd82bb004077c2d8e8b659f8c785ab95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2971f852e11c1816a17c185639f317"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT , typename RHSArrayT , typename  = enable_if&lt;and_t&lt;                        not_t&lt;is_array&lt;ScalarT&gt;&gt;,is_array&lt;RHSArrayT&gt;                        &gt;&gt;&gt; </td></tr>
<tr class="memitem:aab2971f852e11c1816a17c185639f317"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; <a class="el" href="classpni_1_1add__op.html">add_op</a>&lt; <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ScalarT &gt;, RHSArrayT &gt;, <a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt; RHSArrayT &gt;, <a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt; RHSArrayT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#aab2971f852e11c1816a17c185639f317">operator+</a> (const ScalarT &amp;a, const RHSArrayT &amp;b)</td></tr>
<tr class="memdesc:aab2971f852e11c1816a17c185639f317"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary addition operator  <a href="namespacepni.html#aab2971f852e11c1816a17c185639f317">More...</a><br /></td></tr>
<tr class="separator:aab2971f852e11c1816a17c185639f317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4359c75e22f6fbbf9276931208487a"><td class="memTemplParams" colspan="2">template&lt;typename LHSArrayT , typename RHSArrayT , typename  = enable_if&lt;and_t&lt;is_array&lt;LHSArrayT&gt;,is_array&lt;RHSArrayT&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:aab4359c75e22f6fbbf9276931208487a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; <a class="el" href="classpni_1_1sub__op.html">sub_op</a>&lt; LHSArrayT, RHSArrayT &gt;, <a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt; LHSArrayT &gt;, <a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt; LHSArrayT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#aab4359c75e22f6fbbf9276931208487a">operator-</a> (const LHSArrayT &amp;a, const RHSArrayT &amp;b)</td></tr>
<tr class="memdesc:aab4359c75e22f6fbbf9276931208487a"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary subtraction operator  <a href="namespacepni.html#aab4359c75e22f6fbbf9276931208487a">More...</a><br /></td></tr>
<tr class="separator:aab4359c75e22f6fbbf9276931208487a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa81e3e021e6bea1485dfbd89766c16"><td class="memTemplParams" colspan="2">template&lt;typename LHSArrayT , typename ScalarT , typename  = enable_if&lt;and_t&lt;                      is_array&lt;LHSArrayT&gt;,not_t&lt;is_array&lt;ScalarT&gt;&gt;                      &gt;&gt;&gt; </td></tr>
<tr class="memitem:a1fa81e3e021e6bea1485dfbd89766c16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; <a class="el" href="classpni_1_1sub__op.html">sub_op</a>&lt; LHSArrayT, <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ScalarT &gt; &gt;, <a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt; LHSArrayT &gt;, <a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt; LHSArrayT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a1fa81e3e021e6bea1485dfbd89766c16">operator-</a> (const LHSArrayT &amp;a, const ScalarT &amp;b)</td></tr>
<tr class="memdesc:a1fa81e3e021e6bea1485dfbd89766c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary subtraction operator  <a href="namespacepni.html#a1fa81e3e021e6bea1485dfbd89766c16">More...</a><br /></td></tr>
<tr class="separator:a1fa81e3e021e6bea1485dfbd89766c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1256ade88c32b279d334180817271e"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT , typename RHSArrayT , typename  = enable_if&lt;and_t&lt;                        not_t&lt;is_array&lt;ScalarT&gt;&gt;,is_array&lt;RHSArrayT&gt;                         &gt;&gt;&gt; </td></tr>
<tr class="memitem:aab1256ade88c32b279d334180817271e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; <a class="el" href="classpni_1_1sub__op.html">sub_op</a>&lt; <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ScalarT &gt;, RHSArrayT &gt;, <a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt; RHSArrayT &gt;, <a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt; RHSArrayT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#aab1256ade88c32b279d334180817271e">operator-</a> (const ScalarT &amp;a, const RHSArrayT &amp;b)</td></tr>
<tr class="memdesc:aab1256ade88c32b279d334180817271e"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary subtraction operator  <a href="namespacepni.html#aab1256ade88c32b279d334180817271e">More...</a><br /></td></tr>
<tr class="separator:aab1256ade88c32b279d334180817271e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1120ede515181be0e98425a74066ff59"><td class="memTemplParams" colspan="2">template&lt;typename LHSArrayT , typename RHSArrayT , typename  = enable_if&lt;and_t&lt;is_array&lt;LHSArrayT&gt;,is_array&lt;RHSArrayT&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a1120ede515181be0e98425a74066ff59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; <a class="el" href="classpni_1_1div__op.html">div_op</a>&lt; LHSArrayT, RHSArrayT &gt;, <a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt; LHSArrayT &gt;, <a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt; LHSArrayT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a1120ede515181be0e98425a74066ff59">operator/</a> (const LHSArrayT &amp;a, const RHSArrayT &amp;b)</td></tr>
<tr class="memdesc:a1120ede515181be0e98425a74066ff59"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary division operator  <a href="namespacepni.html#a1120ede515181be0e98425a74066ff59">More...</a><br /></td></tr>
<tr class="separator:a1120ede515181be0e98425a74066ff59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a5647b79b9095fb4fe5c7fab77f09e"><td class="memTemplParams" colspan="2">template&lt;typename LHSArrayT , typename ScalarT , typename  = enable_if&lt;and_t&lt;                        is_array&lt;LHSArrayT&gt;,not_t&lt;is_array&lt;ScalarT&gt;&gt;                        &gt;&gt;&gt; </td></tr>
<tr class="memitem:ab7a5647b79b9095fb4fe5c7fab77f09e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; <a class="el" href="classpni_1_1div__op.html">div_op</a>&lt; LHSArrayT, <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ScalarT &gt; &gt;, <a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt; LHSArrayT &gt;, <a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt; LHSArrayT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#ab7a5647b79b9095fb4fe5c7fab77f09e">operator/</a> (const LHSArrayT &amp;a, const ScalarT &amp;b)</td></tr>
<tr class="memdesc:ab7a5647b79b9095fb4fe5c7fab77f09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary division operator  <a href="namespacepni.html#ab7a5647b79b9095fb4fe5c7fab77f09e">More...</a><br /></td></tr>
<tr class="separator:ab7a5647b79b9095fb4fe5c7fab77f09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bd9762cc8ca7d0fa0d8577700cba07"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT , typename RHSArrayT , typename  = enable_if&lt;and_t&lt;                        not_t&lt;is_array&lt;ScalarT&gt;&gt;,is_array&lt;RHSArrayT&gt;                        &gt;&gt;&gt; </td></tr>
<tr class="memitem:af7bd9762cc8ca7d0fa0d8577700cba07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; <a class="el" href="classpni_1_1div__op.html">div_op</a>&lt; <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ScalarT &gt;, RHSArrayT &gt;, <a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt; RHSArrayT &gt;, <a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt; RHSArrayT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#af7bd9762cc8ca7d0fa0d8577700cba07">operator/</a> (const ScalarT &amp;a, const RHSArrayT &amp;b)</td></tr>
<tr class="memdesc:af7bd9762cc8ca7d0fa0d8577700cba07"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary division operator  <a href="namespacepni.html#af7bd9762cc8ca7d0fa0d8577700cba07">More...</a><br /></td></tr>
<tr class="separator:af7bd9762cc8ca7d0fa0d8577700cba07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0340474c3b874c46d329f1effabc67a3"><td class="memTemplParams" colspan="2">template&lt;typename LHSArrayT , typename RHSArrayT , typename  = enable_if&lt;and_t&lt;is_array&lt;LHSArrayT&gt;,is_array&lt;RHSArrayT&gt; &gt;&gt;&gt; </td></tr>
<tr class="memitem:a0340474c3b874c46d329f1effabc67a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; <a class="el" href="classpni_1_1mult__op.html">mult_op</a>&lt; LHSArrayT, RHSArrayT &gt;, <a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt; LHSArrayT &gt;, <a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt; LHSArrayT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a0340474c3b874c46d329f1effabc67a3">operator*</a> (const LHSArrayT &amp;a, const RHSArrayT &amp;b)</td></tr>
<tr class="memdesc:a0340474c3b874c46d329f1effabc67a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary multiplication operator  <a href="namespacepni.html#a0340474c3b874c46d329f1effabc67a3">More...</a><br /></td></tr>
<tr class="separator:a0340474c3b874c46d329f1effabc67a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144f6659404172ea695d92e195feed98"><td class="memTemplParams" colspan="2">template&lt;typename LHSArrayT , typename ScalarT , typename  = enable_if&lt;and_t&lt;                        is_array&lt;LHSArrayT&gt;,not_t&lt;is_array&lt;ScalarT&gt;&gt;                        &gt;&gt;&gt; </td></tr>
<tr class="memitem:a144f6659404172ea695d92e195feed98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; <a class="el" href="classpni_1_1mult__op.html">mult_op</a>&lt; LHSArrayT, <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ScalarT &gt; &gt;, <a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt; LHSArrayT &gt;, <a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt; LHSArrayT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a144f6659404172ea695d92e195feed98">operator*</a> (const LHSArrayT &amp;a, const ScalarT &amp;b)</td></tr>
<tr class="memdesc:a144f6659404172ea695d92e195feed98"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary multiplication operator  <a href="namespacepni.html#a144f6659404172ea695d92e195feed98">More...</a><br /></td></tr>
<tr class="separator:a144f6659404172ea695d92e195feed98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aed25b24d6de34dd371ce47ea916086"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT , typename RHSArrayT , typename  = enable_if&lt;and_t&lt;                        not_t&lt;is_array&lt;ScalarT&gt;&gt;,is_array&lt;RHSArrayT&gt;                        &gt;&gt;&gt; </td></tr>
<tr class="memitem:a2aed25b24d6de34dd371ce47ea916086"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; <a class="el" href="classpni_1_1mult__op.html">mult_op</a>&lt; <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ScalarT &gt;, RHSArrayT &gt;, <a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt; RHSArrayT &gt;, <a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt; RHSArrayT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a2aed25b24d6de34dd371ce47ea916086">operator*</a> (const ScalarT &amp;a, const RHSArrayT &amp;b)</td></tr>
<tr class="memdesc:a2aed25b24d6de34dd371ce47ea916086"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary multiplication operator  <a href="namespacepni.html#a2aed25b24d6de34dd371ce47ea916086">More...</a><br /></td></tr>
<tr class="separator:a2aed25b24d6de34dd371ce47ea916086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af247befacee5f08f154a57549d49a024"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:af247befacee5f08f154a57549d49a024"><td class="memTemplItemLeft" align="right" valign="top">ArrayT::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#af247befacee5f08f154a57549d49a024">min</a> (const ArrayT &amp;a)</td></tr>
<tr class="memdesc:af247befacee5f08f154a57549d49a024"><td class="mdescLeft">&#160;</td><td class="mdescRight">get minimum value of an array type  <a href="namespacepni.html#af247befacee5f08f154a57549d49a024">More...</a><br /></td></tr>
<tr class="separator:af247befacee5f08f154a57549d49a024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6051257c3e8f5fd56df8983d6b294c"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:aab6051257c3e8f5fd56df8983d6b294c"><td class="memTemplItemLeft" align="right" valign="top">ArrayT::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#aab6051257c3e8f5fd56df8983d6b294c">max</a> (const ArrayT &amp;a)</td></tr>
<tr class="memdesc:aab6051257c3e8f5fd56df8983d6b294c"><td class="mdescLeft">&#160;</td><td class="mdescRight">get maximum value of an array type  <a href="namespacepni.html#aab6051257c3e8f5fd56df8983d6b294c">More...</a><br /></td></tr>
<tr class="separator:aab6051257c3e8f5fd56df8983d6b294c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e878bd8d1bab28d03548793ffc257d"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a93e878bd8d1bab28d03548793ffc257d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a93e878bd8d1bab28d03548793ffc257d">min_max</a> (const ArrayT &amp;a, typename ArrayT::value_type &amp;<a class="el" href="namespacepni.html#af247befacee5f08f154a57549d49a024">min</a>, typename ArrayT::value_type &amp;<a class="el" href="namespacepni.html#aab6051257c3e8f5fd56df8983d6b294c">max</a>)</td></tr>
<tr class="memdesc:a93e878bd8d1bab28d03548793ffc257d"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimum and maximum in the array  <a href="namespacepni.html#a93e878bd8d1bab28d03548793ffc257d">More...</a><br /></td></tr>
<tr class="separator:a93e878bd8d1bab28d03548793ffc257d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2d54fea440036b011cb36507d021bf"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:aab2d54fea440036b011cb36507d021bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#aab2d54fea440036b011cb36507d021bf">clip</a> (ArrayT &amp;a, typename ArrayT::value_type minth, typename ArrayT::value_type maxth)</td></tr>
<tr class="memdesc:aab2d54fea440036b011cb36507d021bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">clip the array data  <a href="namespacepni.html#aab2d54fea440036b011cb36507d021bf">More...</a><br /></td></tr>
<tr class="separator:aab2d54fea440036b011cb36507d021bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eed1f1233d443621d7b9990651cf14c"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a8eed1f1233d443621d7b9990651cf14c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a8eed1f1233d443621d7b9990651cf14c">clip</a> (ArrayT &amp;a, typename ArrayT::value_type minth, typename ArrayT::value_type maxth, typename ArrayT::value_type minval, typename ArrayT::value_type maxval)</td></tr>
<tr class="memdesc:a8eed1f1233d443621d7b9990651cf14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">clip the array data  <a href="namespacepni.html#a8eed1f1233d443621d7b9990651cf14c">More...</a><br /></td></tr>
<tr class="separator:a8eed1f1233d443621d7b9990651cf14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c0c01cb831e072fd113cf21f7a7240"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a22c0c01cb831e072fd113cf21f7a7240"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a22c0c01cb831e072fd113cf21f7a7240">min_clip</a> (ArrayT &amp;a, typename ArrayT::value_type threshold)</td></tr>
<tr class="memdesc:a22c0c01cb831e072fd113cf21f7a7240"><td class="mdescLeft">&#160;</td><td class="mdescRight">clip minimum values  <a href="namespacepni.html#a22c0c01cb831e072fd113cf21f7a7240">More...</a><br /></td></tr>
<tr class="separator:a22c0c01cb831e072fd113cf21f7a7240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc04f66da0ae02e5fa0862264ac2f72"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:afdc04f66da0ae02e5fa0862264ac2f72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#afdc04f66da0ae02e5fa0862264ac2f72">min_clip</a> (ArrayT &amp;a, typename ArrayT::value_type threshold, typename ArrayT::value_type <a class="el" href="classpni_1_1value.html">value</a>)</td></tr>
<tr class="memdesc:afdc04f66da0ae02e5fa0862264ac2f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">clip minimum values  <a href="namespacepni.html#afdc04f66da0ae02e5fa0862264ac2f72">More...</a><br /></td></tr>
<tr class="separator:afdc04f66da0ae02e5fa0862264ac2f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4657cf3b2ef437b8c75652a3e4bc2cc0"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a4657cf3b2ef437b8c75652a3e4bc2cc0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a4657cf3b2ef437b8c75652a3e4bc2cc0">max_clip</a> (ArrayT &amp;a, typename ArrayT::value_type threshold)</td></tr>
<tr class="memdesc:a4657cf3b2ef437b8c75652a3e4bc2cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">clip maximum values  <a href="namespacepni.html#a4657cf3b2ef437b8c75652a3e4bc2cc0">More...</a><br /></td></tr>
<tr class="separator:a4657cf3b2ef437b8c75652a3e4bc2cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbb029e5f23318f938e75904855eb3d"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a1fbb029e5f23318f938e75904855eb3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a1fbb029e5f23318f938e75904855eb3d">max_clip</a> (ArrayT &amp;a, typename ArrayT::value_type threshold, typename ArrayT::value_type <a class="el" href="classpni_1_1value.html">value</a>)</td></tr>
<tr class="memdesc:a1fbb029e5f23318f938e75904855eb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">clip maximum values  <a href="namespacepni.html#a1fbb029e5f23318f938e75904855eb3d">More...</a><br /></td></tr>
<tr class="separator:a1fbb029e5f23318f938e75904855eb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0c5c8e113fd09cc3afb46172652080"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a7a0c5c8e113fd09cc3afb46172652080"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a7a0c5c8e113fd09cc3afb46172652080">max_offset</a> (const ArrayT &amp;a)</td></tr>
<tr class="memdesc:a7a0c5c8e113fd09cc3afb46172652080"><td class="mdescLeft">&#160;</td><td class="mdescRight">get linear offset of maximum  <a href="namespacepni.html#a7a0c5c8e113fd09cc3afb46172652080">More...</a><br /></td></tr>
<tr class="separator:a7a0c5c8e113fd09cc3afb46172652080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8851ae21594f631fe0ec5b80563efe0a"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ArrayT &gt; </td></tr>
<tr class="memitem:a8851ae21594f631fe0ec5b80563efe0a"><td class="memTemplItemLeft" align="right" valign="top">ContainerT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a8851ae21594f631fe0ec5b80563efe0a">max_index</a> (const ArrayT &amp;a)</td></tr>
<tr class="memdesc:a8851ae21594f631fe0ec5b80563efe0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get index of maximum  <a href="namespacepni.html#a8851ae21594f631fe0ec5b80563efe0a">More...</a><br /></td></tr>
<tr class="separator:a8851ae21594f631fe0ec5b80563efe0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaec01a7ab6eb54ec96fa29ab98acc49"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:abaec01a7ab6eb54ec96fa29ab98acc49"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#abaec01a7ab6eb54ec96fa29ab98acc49">min_offset</a> (const ArrayT &amp;a)</td></tr>
<tr class="memdesc:abaec01a7ab6eb54ec96fa29ab98acc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">get linear offset of minimum  <a href="namespacepni.html#abaec01a7ab6eb54ec96fa29ab98acc49">More...</a><br /></td></tr>
<tr class="separator:abaec01a7ab6eb54ec96fa29ab98acc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3bbd86477799cabaed10cf9bff143b"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ArrayT &gt; </td></tr>
<tr class="memitem:a3b3bbd86477799cabaed10cf9bff143b"><td class="memTemplItemLeft" align="right" valign="top">ContainerT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a3b3bbd86477799cabaed10cf9bff143b">min_index</a> (const ArrayT &amp;a)</td></tr>
<tr class="memdesc:a3b3bbd86477799cabaed10cf9bff143b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get index of minimum  <a href="namespacepni.html#a3b3bbd86477799cabaed10cf9bff143b">More...</a><br /></td></tr>
<tr class="separator:a3b3bbd86477799cabaed10cf9bff143b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a1ebbf6e5ba0b68ea3d9a523ed2228"><td class="memTemplParams" colspan="2">template&lt;typename MapT , typename ContainerT &gt; </td></tr>
<tr class="memitem:ae7a1ebbf6e5ba0b68ea3d9a523ed2228"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#ae7a1ebbf6e5ba0b68ea3d9a523ed2228">offset</a> (const MapT &amp;map, const <a class="el" href="classpni_1_1array__selection.html">array_selection</a> &amp;s, const ContainerT &amp;index)</td></tr>
<tr class="memdesc:ae7a1ebbf6e5ba0b68ea3d9a523ed2228"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute offset  <a href="namespacepni.html#ae7a1ebbf6e5ba0b68ea3d9a523ed2228">More...</a><br /></td></tr>
<tr class="separator:ae7a1ebbf6e5ba0b68ea3d9a523ed2228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01896ba81995c4540b4230baa6e13cc"><td class="memTemplParams" colspan="2">template&lt;typename MapT &gt; </td></tr>
<tr class="memitem:ab01896ba81995c4540b4230baa6e13cc"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#ab01896ba81995c4540b4230baa6e13cc">start_offset</a> (const MapT &amp;map, const <a class="el" href="classpni_1_1array__selection.html">array_selection</a> &amp;s)</td></tr>
<tr class="memdesc:ab01896ba81995c4540b4230baa6e13cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute first element offset  <a href="namespacepni.html#ab01896ba81995c4540b4230baa6e13cc">More...</a><br /></td></tr>
<tr class="separator:ab01896ba81995c4540b4230baa6e13cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b5f93cbfde86db957f65e220d84980"><td class="memTemplParams" colspan="2">template&lt;typename MapT &gt; </td></tr>
<tr class="memitem:a93b5f93cbfde86db957f65e220d84980"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a93b5f93cbfde86db957f65e220d84980">last_offset</a> (const MapT &amp;map, const <a class="el" href="classpni_1_1array__selection.html">array_selection</a> &amp;s)</td></tr>
<tr class="memdesc:a93b5f93cbfde86db957f65e220d84980"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute last element offset  <a href="namespacepni.html#a93b5f93cbfde86db957f65e220d84980">More...</a><br /></td></tr>
<tr class="separator:a93b5f93cbfde86db957f65e220d84980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c13016075a9210809a9c8bf866b214"><td class="memTemplParams" colspan="2">template&lt;typename MapT &gt; </td></tr>
<tr class="memitem:a50c13016075a9210809a9c8bf866b214"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a50c13016075a9210809a9c8bf866b214">is_contiguous</a> (const MapT &amp;map, const <a class="el" href="classpni_1_1array__selection.html">array_selection</a> &amp;s)</td></tr>
<tr class="memdesc:a50c13016075a9210809a9c8bf866b214"><td class="mdescLeft">&#160;</td><td class="mdescRight">check continuity of a selection  <a href="namespacepni.html#a50c13016075a9210809a9c8bf866b214">More...</a><br /></td></tr>
<tr class="separator:a50c13016075a9210809a9c8bf866b214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga412ff238d4e52823dca381dc6122177f"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:ga412ff238d4e52823dca381dc6122177f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga412ff238d4e52823dca381dc6122177f">type_id</a> (const <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; ArrayT &gt; &amp;)</td></tr>
<tr class="memdesc:ga412ff238d4e52823dca381dc6122177f"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization for type_id  <a href="group__type__classes.html#ga412ff238d4e52823dca381dc6122177f">More...</a><br /></td></tr>
<tr class="separator:ga412ff238d4e52823dca381dc6122177f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c943c72378fafdd22174b5fd7562a7"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a30c943c72378fafdd22174b5fd7562a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a30c943c72378fafdd22174b5fd7562a7">operator==</a> (const <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; ArrayT &gt; &amp;a, const <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; ArrayT &gt; &amp;b)</td></tr>
<tr class="memdesc:a30c943c72378fafdd22174b5fd7562a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare two array views  <a href="namespacepni.html#a30c943c72378fafdd22174b5fd7562a7">More...</a><br /></td></tr>
<tr class="separator:a30c943c72378fafdd22174b5fd7562a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fc6717e6275e8bedb48e8f0b1b37a7"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a31fc6717e6275e8bedb48e8f0b1b37a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a31fc6717e6275e8bedb48e8f0b1b37a7">operator!=</a> (const <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; ArrayT &gt; &amp;a, const <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; ArrayT &gt; &amp;b)</td></tr>
<tr class="memdesc:a31fc6717e6275e8bedb48e8f0b1b37a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare two array views  <a href="namespacepni.html#a31fc6717e6275e8bedb48e8f0b1b37a7">More...</a><br /></td></tr>
<tr class="separator:a31fc6717e6275e8bedb48e8f0b1b37a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ee966073630add8e2830bc712c1455"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:ac1ee966073630add8e2830bc712c1455"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#ac1ee966073630add8e2830bc712c1455">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; ArrayT &gt; &amp;v)</td></tr>
<tr class="memdesc:ac1ee966073630add8e2830bc712c1455"><td class="mdescLeft">&#160;</td><td class="mdescRight">output operator for view  <a href="namespacepni.html#ac1ee966073630add8e2830bc712c1455">More...</a><br /></td></tr>
<tr class="separator:ac1ee966073630add8e2830bc712c1455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2aacb6d078bb640c30ebc9d28fea0e"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:abe2aacb6d078bb640c30ebc9d28fea0e"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#abe2aacb6d078bb640c30ebc9d28fea0e">operator&gt;&gt;</a> (std::istream &amp;stream, <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; ArrayT &gt; &amp;v)</td></tr>
<tr class="memdesc:abe2aacb6d078bb640c30ebc9d28fea0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">input operator for view  <a href="namespacepni.html#abe2aacb6d078bb640c30ebc9d28fea0e">More...</a><br /></td></tr>
<tr class="separator:abe2aacb6d078bb640c30ebc9d28fea0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b019be5b8618eb651063dce518b0b3"><td class="memTemplParams" colspan="2">template&lt;typename StorageT , typename IndexMapT , typename InplaceArithmeticT &gt; </td></tr>
<tr class="memitem:a58b019be5b8618eb651063dce518b0b3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a58b019be5b8618eb651063dce518b0b3">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt; &amp;a)</td></tr>
<tr class="memdesc:a58b019be5b8618eb651063dce518b0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">output operator  <a href="namespacepni.html#a58b019be5b8618eb651063dce518b0b3">More...</a><br /></td></tr>
<tr class="separator:a58b019be5b8618eb651063dce518b0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af147b4c5c0279534e0e0625695a9fcc3"><td class="memTemplParams" colspan="2">template&lt;typename StorageT , typename IndexMapT , typename InplaceArithmeticT &gt; </td></tr>
<tr class="memitem:af147b4c5c0279534e0e0625695a9fcc3"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#af147b4c5c0279534e0e0625695a9fcc3">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt; &amp;a)</td></tr>
<tr class="memdesc:af147b4c5c0279534e0e0625695a9fcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">input stream operator  <a href="namespacepni.html#af147b4c5c0279534e0e0625695a9fcc3">More...</a><br /></td></tr>
<tr class="separator:af147b4c5c0279534e0e0625695a9fcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96da3356844bf9f27cd2e46370a91e2"><td class="memTemplParams" colspan="2">template&lt;typename StorageT , typename IndexMapT , typename InplaceArithmeticT &gt; </td></tr>
<tr class="memitem:af96da3356844bf9f27cd2e46370a91e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#af96da3356844bf9f27cd2e46370a91e2">operator==</a> (const <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt; &amp;b1, const <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt; &amp;b2)</td></tr>
<tr class="memdesc:af96da3356844bf9f27cd2e46370a91e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">equality comparison operator  <a href="namespacepni.html#af96da3356844bf9f27cd2e46370a91e2">More...</a><br /></td></tr>
<tr class="separator:af96da3356844bf9f27cd2e46370a91e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c268517fc4a4f0d4601a9ce4110c47"><td class="memTemplParams" colspan="2">template&lt;typename StorageT , typename IndexMapT , typename InplaceArithmeticT &gt; </td></tr>
<tr class="memitem:a68c268517fc4a4f0d4601a9ce4110c47"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a68c268517fc4a4f0d4601a9ce4110c47">operator!=</a> (const <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt; &amp;b1, const <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt; &amp;b2)</td></tr>
<tr class="memdesc:a68c268517fc4a4f0d4601a9ce4110c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">inequality comparison operator  <a href="namespacepni.html#a68c268517fc4a4f0d4601a9ce4110c47">More...</a><br /></td></tr>
<tr class="separator:a68c268517fc4a4f0d4601a9ce4110c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ad4bac0c3c4f6e1d2006868f39836c"><td class="memTemplParams" colspan="2">template&lt;typename ElementT &gt; </td></tr>
<tr class="memitem:aa9ad4bac0c3c4f6e1d2006868f39836c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#aa9ad4bac0c3c4f6e1d2006868f39836c">operator==</a> (const <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ElementT &gt; &amp;a, const <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ElementT &gt; &amp;b)</td></tr>
<tr class="memdesc:aa9ad4bac0c3c4f6e1d2006868f39836c"><td class="mdescLeft">&#160;</td><td class="mdescRight">== operator for scalar  <a href="namespacepni.html#aa9ad4bac0c3c4f6e1d2006868f39836c">More...</a><br /></td></tr>
<tr class="separator:aa9ad4bac0c3c4f6e1d2006868f39836c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf004d73858ff6f9b3117e137293c085"><td class="memTemplParams" colspan="2">template&lt;typename ElementT &gt; </td></tr>
<tr class="memitem:acf004d73858ff6f9b3117e137293c085"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#acf004d73858ff6f9b3117e137293c085">operator!=</a> (const <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ElementT &gt; &amp;a, const <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ElementT &gt; &amp;b)</td></tr>
<tr class="memdesc:acf004d73858ff6f9b3117e137293c085"><td class="mdescLeft">&#160;</td><td class="mdescRight">!= operator for scalar  <a href="namespacepni.html#acf004d73858ff6f9b3117e137293c085">More...</a><br /></td></tr>
<tr class="separator:acf004d73858ff6f9b3117e137293c085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6658dd7b214ac22b58b91624966c5b9a"><td class="memTemplParams" colspan="2">template&lt;typename ElementT &gt; </td></tr>
<tr class="memitem:a6658dd7b214ac22b58b91624966c5b9a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a6658dd7b214ac22b58b91624966c5b9a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ElementT &gt; &amp;s)</td></tr>
<tr class="memdesc:a6658dd7b214ac22b58b91624966c5b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">stream output operator  <a href="namespacepni.html#a6658dd7b214ac22b58b91624966c5b9a">More...</a><br /></td></tr>
<tr class="separator:a6658dd7b214ac22b58b91624966c5b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5d3293e77005349a8a4ab1c19eda1f"><td class="memTemplParams" colspan="2">template&lt;typename ElementT &gt; </td></tr>
<tr class="memitem:a9b5d3293e77005349a8a4ab1c19eda1f"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a9b5d3293e77005349a8a4ab1c19eda1f">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ElementT &gt; &amp;s)</td></tr>
<tr class="memdesc:a9b5d3293e77005349a8a4ab1c19eda1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">input strema data  <a href="namespacepni.html#a9b5d3293e77005349a8a4ab1c19eda1f">More...</a><br /></td></tr>
<tr class="separator:a9b5d3293e77005349a8a4ab1c19eda1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7d55842a674e38bc480441ee0a863d"><td class="memTemplParams" colspan="2">template&lt;typename IterableT &gt; </td></tr>
<tr class="memitem:adb7d55842a674e38bc480441ee0a863d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a>&lt; IterableT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#adb7d55842a674e38bc480441ee0a863d">operator+</a> (const <a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a>&lt; IterableT &gt; &amp;a, ssize_t b)</td></tr>
<tr class="memdesc:adb7d55842a674e38bc480441ee0a863d"><td class="mdescLeft">&#160;</td><td class="mdescRight">add scalar to iterator  <a href="namespacepni.html#adb7d55842a674e38bc480441ee0a863d">More...</a><br /></td></tr>
<tr class="separator:adb7d55842a674e38bc480441ee0a863d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca87002e81aa929ff6fd5a8161af95d"><td class="memTemplParams" colspan="2">template&lt;typename IterableT &gt; </td></tr>
<tr class="memitem:a0ca87002e81aa929ff6fd5a8161af95d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a>&lt; IterableT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a0ca87002e81aa929ff6fd5a8161af95d">operator+</a> (ssize_t a, const <a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a>&lt; IterableT &gt; &amp;b)</td></tr>
<tr class="memdesc:a0ca87002e81aa929ff6fd5a8161af95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">add offset to iterator  <a href="namespacepni.html#a0ca87002e81aa929ff6fd5a8161af95d">More...</a><br /></td></tr>
<tr class="separator:a0ca87002e81aa929ff6fd5a8161af95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bb7cab2e23bcb6f983b242ece166ba"><td class="memTemplParams" colspan="2">template&lt;typename IterableT &gt; </td></tr>
<tr class="memitem:a14bb7cab2e23bcb6f983b242ece166ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a>&lt; IterableT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a14bb7cab2e23bcb6f983b242ece166ba">operator-</a> (const <a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a>&lt; IterableT &gt; &amp;a, ssize_t b)</td></tr>
<tr class="memdesc:a14bb7cab2e23bcb6f983b242ece166ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract offset from iterator  <a href="namespacepni.html#a14bb7cab2e23bcb6f983b242ece166ba">More...</a><br /></td></tr>
<tr class="separator:a14bb7cab2e23bcb6f983b242ece166ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f634d852fbd338a554a21ee3c57560"><td class="memTemplParams" colspan="2">template&lt;typename IterableT &gt; </td></tr>
<tr class="memitem:a69f634d852fbd338a554a21ee3c57560"><td class="memTemplItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a69f634d852fbd338a554a21ee3c57560">operator-</a> (const <a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a>&lt; IterableT &gt; &amp;a, const <a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a>&lt; IterableT &gt; &amp;b)</td></tr>
<tr class="memdesc:a69f634d852fbd338a554a21ee3c57560"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract two iterators  <a href="namespacepni.html#a69f634d852fbd338a554a21ee3c57560">More...</a><br /></td></tr>
<tr class="separator:a69f634d852fbd338a554a21ee3c57560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd23126a950b05ee8ad649bcf718888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a3fd23126a950b05ee8ad649bcf718888">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classpni_1_1slice.html">slice</a> &amp;s)</td></tr>
<tr class="memdesc:a3fd23126a950b05ee8ad649bcf718888"><td class="mdescLeft">&#160;</td><td class="mdescRight">output operator  <a href="namespacepni.html#a3fd23126a950b05ee8ad649bcf718888">More...</a><br /></td></tr>
<tr class="separator:a3fd23126a950b05ee8ad649bcf718888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9fd779f21aa8a30cb9968c7c99d6df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a7b9fd779f21aa8a30cb9968c7c99d6df">operator==</a> (const <a class="el" href="classpni_1_1slice.html">slice</a> &amp;lhs, const <a class="el" href="classpni_1_1slice.html">slice</a> &amp;rhs)</td></tr>
<tr class="separator:a7b9fd779f21aa8a30cb9968c7c99d6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bfeaf7ca57d536154a94cd8deb48d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a39bfeaf7ca57d536154a94cd8deb48d2">operator!=</a> (const <a class="el" href="classpni_1_1slice.html">slice</a> &amp;lhs, const <a class="el" href="classpni_1_1slice.html">slice</a> &amp;rhs)</td></tr>
<tr class="separator:a39bfeaf7ca57d536154a94cd8deb48d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20a3d8d51f1c5aee26a971b5fe2cf65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#ab20a3d8d51f1c5aee26a971b5fe2cf65">size</a> (const <a class="el" href="classpni_1_1slice.html">slice</a> &amp;s)</td></tr>
<tr class="memdesc:ab20a3d8d51f1c5aee26a971b5fe2cf65"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute slice size  <a href="namespacepni.html#ab20a3d8d51f1c5aee26a971b5fe2cf65">More...</a><br /></td></tr>
<tr class="separator:ab20a3d8d51f1c5aee26a971b5fe2cf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00094494cfad50d0a67085bec79eb2fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a00094494cfad50d0a67085bec79eb2fd">span</a> (const <a class="el" href="classpni_1_1slice.html">slice</a> &amp;s)</td></tr>
<tr class="memdesc:a00094494cfad50d0a67085bec79eb2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute total elements spanned  <a href="namespacepni.html#a00094494cfad50d0a67085bec79eb2fd">More...</a><br /></td></tr>
<tr class="separator:a00094494cfad50d0a67085bec79eb2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274af90a0c9bf4b3e9b5de4e98759d96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a274af90a0c9bf4b3e9b5de4e98759d96">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classpni_1_1column__info.html">column_info</a> &amp;ci)</td></tr>
<tr class="separator:a274af90a0c9bf4b3e9b5de4e98759d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabaa6b5e16a17cbc7059f9eb7717181b"><td class="memTemplParams" colspan="2">template&lt;typename VectorT &gt; </td></tr>
<tr class="memitem:aabaa6b5e16a17cbc7059f9eb7717181b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#aabaa6b5e16a17cbc7059f9eb7717181b">print_vector</a> (std::ostream &amp;o, const VectorT &amp;v)</td></tr>
<tr class="memdesc:aabaa6b5e16a17cbc7059f9eb7717181b"><td class="mdescLeft">&#160;</td><td class="mdescRight">print vector content  <a href="namespacepni.html#aabaa6b5e16a17cbc7059f9eb7717181b">More...</a><br /></td></tr>
<tr class="separator:aabaa6b5e16a17cbc7059f9eb7717181b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f2d0ee91d2c32f6c2f91812ed3cfd1"><td class="memTemplParams" colspan="2">template&lt;typename ContainerAT , typename ContainerBT &gt; </td></tr>
<tr class="memitem:a49f2d0ee91d2c32f6c2f91812ed3cfd1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a49f2d0ee91d2c32f6c2f91812ed3cfd1">check_equal_size</a> (const ContainerAT &amp;a, const ContainerBT &amp;b)</td></tr>
<tr class="memdesc:a49f2d0ee91d2c32f6c2f91812ed3cfd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if two container have equal size  <a href="namespacepni.html#a49f2d0ee91d2c32f6c2f91812ed3cfd1">More...</a><br /></td></tr>
<tr class="separator:a49f2d0ee91d2c32f6c2f91812ed3cfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf4ebfd00fbbd8e435e32cc61761c15"><td class="memTemplParams" colspan="2">template&lt;typename ContainerAT , typename ContainerBT &gt; </td></tr>
<tr class="memitem:a4cf4ebfd00fbbd8e435e32cc61761c15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a4cf4ebfd00fbbd8e435e32cc61761c15">check_equal_size</a> (const ContainerAT &amp;a, const ContainerBT &amp;b, const <a class="el" href="classpni_1_1exception__record.html">exception_record</a> &amp;i)</td></tr>
<tr class="memdesc:a4cf4ebfd00fbbd8e435e32cc61761c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if two objects have different size  <a href="namespacepni.html#a4cf4ebfd00fbbd8e435e32cc61761c15">More...</a><br /></td></tr>
<tr class="separator:a4cf4ebfd00fbbd8e435e32cc61761c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb0b46606d1afcfdeda8b2929b6e656"><td class="memItemLeft" align="right" valign="top">bool <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a1fb0b46606d1afcfdeda8b2929b6e656">check_index_in_dim</a> (size_t index, size_t dimsize)</td></tr>
<tr class="memdesc:a1fb0b46606d1afcfdeda8b2929b6e656"><td class="mdescLeft">&#160;</td><td class="mdescRight">check index in dim  <a href="namespacepni.html#a1fb0b46606d1afcfdeda8b2929b6e656">More...</a><br /></td></tr>
<tr class="separator:a1fb0b46606d1afcfdeda8b2929b6e656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b92369cc3430b7cc8658dc8f7fb8ae"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a86b92369cc3430b7cc8658dc8f7fb8ae">check_index_in_dim</a> (size_t index, size_t dimsize, const <a class="el" href="classpni_1_1exception__record.html">exception_record</a> &amp;i)</td></tr>
<tr class="memdesc:a86b92369cc3430b7cc8658dc8f7fb8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">check index in dim  <a href="namespacepni.html#a86b92369cc3430b7cc8658dc8f7fb8ae">More...</a><br /></td></tr>
<tr class="separator:a86b92369cc3430b7cc8658dc8f7fb8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c69a33d887b2c551764c28e4cf0df8"><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename ShapeT &gt; </td></tr>
<tr class="memitem:a32c69a33d887b2c551764c28e4cf0df8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a32c69a33d887b2c551764c28e4cf0df8">check_indexes</a> (const IndexT &amp;index, const ShapeT &amp;shape)</td></tr>
<tr class="memdesc:a32c69a33d887b2c551764c28e4cf0df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">check indexes  <a href="namespacepni.html#a32c69a33d887b2c551764c28e4cf0df8">More...</a><br /></td></tr>
<tr class="separator:a32c69a33d887b2c551764c28e4cf0df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051b69e98fd06ec2abb6aecf5dd9372a"><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename ShapeT &gt; </td></tr>
<tr class="memitem:a051b69e98fd06ec2abb6aecf5dd9372a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a051b69e98fd06ec2abb6aecf5dd9372a">check_indexes</a> (const IndexT &amp;index, const ShapeT &amp;shape, const <a class="el" href="classpni_1_1exception__record.html">exception_record</a> &amp;record)</td></tr>
<tr class="memdesc:a051b69e98fd06ec2abb6aecf5dd9372a"><td class="mdescLeft">&#160;</td><td class="mdescRight">check indexes  <a href="namespacepni.html#a051b69e98fd06ec2abb6aecf5dd9372a">More...</a><br /></td></tr>
<tr class="separator:a051b69e98fd06ec2abb6aecf5dd9372a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bc969854c439e9ddf712e98ca50238"><td class="memTemplParams" colspan="2">template&lt;typename ContainerAT , typename ContainerBT &gt; </td></tr>
<tr class="memitem:a94bc969854c439e9ddf712e98ca50238"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a94bc969854c439e9ddf712e98ca50238">check_equal_rank</a> (const ContainerAT &amp;a, const ContainerBT &amp;b)</td></tr>
<tr class="memdesc:a94bc969854c439e9ddf712e98ca50238"><td class="mdescLeft">&#160;</td><td class="mdescRight">check equal rank  <a href="namespacepni.html#a94bc969854c439e9ddf712e98ca50238">More...</a><br /></td></tr>
<tr class="separator:a94bc969854c439e9ddf712e98ca50238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cc23d08b1ad5571daef5dc987f6a8c"><td class="memTemplParams" colspan="2">template&lt;typename ContainerAT , typename ContainerBT &gt; </td></tr>
<tr class="memitem:a57cc23d08b1ad5571daef5dc987f6a8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a57cc23d08b1ad5571daef5dc987f6a8c">check_equal_rank</a> (const ContainerAT &amp;a, const ContainerBT &amp;b, const <a class="el" href="classpni_1_1exception__record.html">exception_record</a> &amp;i)</td></tr>
<tr class="memdesc:a57cc23d08b1ad5571daef5dc987f6a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">check equal rank  <a href="namespacepni.html#a57cc23d08b1ad5571daef5dc987f6a8c">More...</a><br /></td></tr>
<tr class="separator:a57cc23d08b1ad5571daef5dc987f6a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edd1259ff909d680f6a3972da3c1e73"><td class="memTemplParams" colspan="2">template&lt;typename ContainerAT , typename ContainerBT &gt; </td></tr>
<tr class="memitem:a3edd1259ff909d680f6a3972da3c1e73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a3edd1259ff909d680f6a3972da3c1e73">check_equal_shape</a> (const ContainerAT &amp;a, const ContainerBT &amp;b)</td></tr>
<tr class="memdesc:a3edd1259ff909d680f6a3972da3c1e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">check for shape equality  <a href="namespacepni.html#a3edd1259ff909d680f6a3972da3c1e73">More...</a><br /></td></tr>
<tr class="separator:a3edd1259ff909d680f6a3972da3c1e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f9c4c9ac7aee46df3850d7799d205d"><td class="memTemplParams" colspan="2">template&lt;typename ContainerAT , typename ContainerBT &gt; </td></tr>
<tr class="memitem:a98f9c4c9ac7aee46df3850d7799d205d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a98f9c4c9ac7aee46df3850d7799d205d">check_equal_shape</a> (const ContainerAT &amp;a, const ContainerBT &amp;b, const <a class="el" href="classpni_1_1exception__record.html">exception_record</a> &amp;i)</td></tr>
<tr class="memdesc:a98f9c4c9ac7aee46df3850d7799d205d"><td class="mdescLeft">&#160;</td><td class="mdescRight">check shape equality  <a href="namespacepni.html#a98f9c4c9ac7aee46df3850d7799d205d">More...</a><br /></td></tr>
<tr class="separator:a98f9c4c9ac7aee46df3850d7799d205d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0875f5e5b799f33e3cf6b2ef1d8417"><td class="memTemplParams" colspan="2">template&lt;typename ObjectT &gt; </td></tr>
<tr class="memitem:adf0875f5e5b799f33e3cf6b2ef1d8417"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#adf0875f5e5b799f33e3cf6b2ef1d8417">check_allocation_state</a> (const ObjectT &amp;o, const <a class="el" href="classpni_1_1exception__record.html">exception_record</a> &amp;i)</td></tr>
<tr class="memdesc:adf0875f5e5b799f33e3cf6b2ef1d8417"><td class="mdescLeft">&#160;</td><td class="mdescRight">check allocation state  <a href="namespacepni.html#adf0875f5e5b799f33e3cf6b2ef1d8417">More...</a><br /></td></tr>
<tr class="separator:adf0875f5e5b799f33e3cf6b2ef1d8417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb904fc49062ce691c85cf691d36d020"><td class="memTemplParams" colspan="2">template&lt;typename GeneralT &gt; </td></tr>
<tr class="memitem:acb904fc49062ce691c85cf691d36d020"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#acb904fc49062ce691c85cf691d36d020">check_ptr_state</a> (const GeneralT *ptr, const <a class="el" href="classpni_1_1exception__record.html">exception_record</a> &amp;i)</td></tr>
<tr class="memdesc:acb904fc49062ce691c85cf691d36d020"><td class="mdescLeft">&#160;</td><td class="mdescRight">check pointer state  <a href="namespacepni.html#acb904fc49062ce691c85cf691d36d020">More...</a><br /></td></tr>
<tr class="separator:acb904fc49062ce691c85cf691d36d020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c8434813fb9d112b4dec2961b8c09a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#ab3c8434813fb9d112b4dec2961b8c09a">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classpni_1_1exception__record.html">exception_record</a> &amp;rec)</td></tr>
<tr class="memdesc:ab3c8434813fb9d112b4dec2961b8c09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">error record output operator  <a href="namespacepni.html#ab3c8434813fb9d112b4dec2961b8c09a">More...</a><br /></td></tr>
<tr class="separator:ab3c8434813fb9d112b4dec2961b8c09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31f7649c43f7f966c750f61f63bba00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#ad31f7649c43f7f966c750f61f63bba00">format</a> (const <a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">pni::uint8</a> &amp;v)</td></tr>
<tr class="separator:ad31f7649c43f7f966c750f61f63bba00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc53518c4bb1e8c44a7a3407ced0c7db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#acc53518c4bb1e8c44a7a3407ced0c7db">format</a> (const <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">pni::int8</a> &amp;v)</td></tr>
<tr class="separator:acc53518c4bb1e8c44a7a3407ced0c7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c36a76f907d850dc263c5c49c9f7315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a0c36a76f907d850dc263c5c49c9f7315">format</a> (const <a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">pni::uint16</a> &amp;v)</td></tr>
<tr class="separator:a0c36a76f907d850dc263c5c49c9f7315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791b8ee244a27453e29ca5be78579281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a791b8ee244a27453e29ca5be78579281">format</a> (const <a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">pni::int16</a> &amp;v)</td></tr>
<tr class="separator:a791b8ee244a27453e29ca5be78579281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc518e4f3ca7720c168fa85175b7826a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#abc518e4f3ca7720c168fa85175b7826a">format</a> (const <a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">pni::uint32</a> &amp;v)</td></tr>
<tr class="separator:abc518e4f3ca7720c168fa85175b7826a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283d7317b17f946531aa3013f400f1d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a283d7317b17f946531aa3013f400f1d3">format</a> (const <a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">pni::int32</a> &amp;v)</td></tr>
<tr class="separator:a283d7317b17f946531aa3013f400f1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa180a9b08533dfec0d9ded47c6cefad7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#aa180a9b08533dfec0d9ded47c6cefad7">format</a> (const <a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">pni::uint64</a> &amp;v)</td></tr>
<tr class="separator:aa180a9b08533dfec0d9ded47c6cefad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ece436da3f8d78849b3d8ce0925909f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a9ece436da3f8d78849b3d8ce0925909f">format</a> (const <a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">pni::int64</a> &amp;v)</td></tr>
<tr class="separator:a9ece436da3f8d78849b3d8ce0925909f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68a7c09eb138e6490031cb0172f4d53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#ab68a7c09eb138e6490031cb0172f4d53">format</a> (const <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">pni::float32</a> &amp;v)</td></tr>
<tr class="separator:ab68a7c09eb138e6490031cb0172f4d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb633842f14923e37d90afdf684295e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#acdb633842f14923e37d90afdf684295e">format</a> (const <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">pni::float64</a> &amp;v)</td></tr>
<tr class="separator:acdb633842f14923e37d90afdf684295e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b1687bbfff73feef0f297d1aeac573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#ac3b1687bbfff73feef0f297d1aeac573">format</a> (const <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">pni::float128</a> &amp;v)</td></tr>
<tr class="separator:ac3b1687bbfff73feef0f297d1aeac573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb28578c5c5b99f35b9e65f5884f1bf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#adb28578c5c5b99f35b9e65f5884f1bf6">format</a> (const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">pni::complex32</a> &amp;v)</td></tr>
<tr class="separator:adb28578c5c5b99f35b9e65f5884f1bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e5fd864fb8e8d1262bebf7016ee34e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#ab7e5fd864fb8e8d1262bebf7016ee34e">format</a> (const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">pni::complex64</a> &amp;v)</td></tr>
<tr class="separator:ab7e5fd864fb8e8d1262bebf7016ee34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2ce510a0af79530d873e356be05d11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#acd2ce510a0af79530d873e356be05d11">format</a> (const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">pni::complex128</a> &amp;v)</td></tr>
<tr class="separator:acd2ce510a0af79530d873e356be05d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf773f9ac4d4dd75519d24cc671e7aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#accf773f9ac4d4dd75519d24cc671e7aa">format</a> (const <a class="el" href="classpni_1_1bool__t.html">pni::bool_t</a> &amp;v)</td></tr>
<tr class="separator:accf773f9ac4d4dd75519d24cc671e7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a23c1dd62664a34cc6f6cf1bf5b5697"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a4a23c1dd62664a34cc6f6cf1bf5b5697">format</a> (const <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> &amp;s)</td></tr>
<tr class="separator:a4a23c1dd62664a34cc6f6cf1bf5b5697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeef3e541391e2be4925f8be64dd5552"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#afeef3e541391e2be4925f8be64dd5552">format</a> (const <a class="el" href="classpni_1_1value.html">pni::value</a> &amp;v)</td></tr>
<tr class="separator:afeef3e541391e2be4925f8be64dd5552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae999fe3d8becdd764a25a81b4e0beee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#aae999fe3d8becdd764a25a81b4e0beee">format</a> (const <a class="el" href="classpni_1_1value__ref.html">pni::value_ref</a> &amp;v)</td></tr>
<tr class="separator:aae999fe3d8becdd764a25a81b4e0beee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e64b53287aed6f0911f031f5a7ee6ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a8e64b53287aed6f0911f031f5a7ee6ad">format</a> (const hdf5::datatype::EBool &amp;v)</td></tr>
<tr class="separator:a8e64b53287aed6f0911f031f5a7ee6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e45b03e5dae3c4070d990f3ff307e17"><td class="memTemplParams" colspan="2">template&lt;typename ElementT &gt; </td></tr>
<tr class="memitem:a8e45b03e5dae3c4070d990f3ff307e17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a8e45b03e5dae3c4070d990f3ff307e17">format</a> (const std::vector&lt; ElementT &gt; &amp;v, const <a class="el" href="classpni_1_1container__io__config.html">container_io_config</a> &amp;config=<a class="el" href="classpni_1_1container__io__config.html">container_io_config</a>())</td></tr>
<tr class="separator:a8e45b03e5dae3c4070d990f3ff307e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1601f7a91046c7b0af122e3b997bb1ee"><td class="memTemplParams" colspan="2">template&lt;typename ... TemplateParametersT&gt; </td></tr>
<tr class="memitem:a1601f7a91046c7b0af122e3b997bb1ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a1601f7a91046c7b0af122e3b997bb1ee">format</a> (const <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; TemplateParametersT... &gt; &amp;v, const <a class="el" href="classpni_1_1container__io__config.html">container_io_config</a> &amp;config=<a class="el" href="classpni_1_1container__io__config.html">container_io_config</a>())</td></tr>
<tr class="memdesc:a1601f7a91046c7b0af122e3b997bb1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">formatter for mdarray instances  <a href="namespacepni.html#a1601f7a91046c7b0af122e3b997bb1ee">More...</a><br /></td></tr>
<tr class="separator:a1601f7a91046c7b0af122e3b997bb1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b360f7e07437ecde5a88bea7fa08f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a57b360f7e07437ecde5a88bea7fa08f0">format</a> (const <a class="el" href="classpni_1_1array.html">pni::array</a> &amp;v, const <a class="el" href="classpni_1_1container__io__config.html">container_io_config</a> &amp;config=<a class="el" href="classpni_1_1container__io__config.html">container_io_config</a>())</td></tr>
<tr class="separator:a57b360f7e07437ecde5a88bea7fa08f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ad0a8f6bef62f6b08654a35a049d06"><td class="memItemLeft" align="right" valign="top">static const boost::regex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a81ad0a8f6bef62f6b08654a35a049d06">default_int_regexp</a> (&quot;^[+-]?\\d+$&quot;)</td></tr>
<tr class="separator:a81ad0a8f6bef62f6b08654a35a049d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14203ed7eaa2d44db5e56080413e47e6"><td class="memItemLeft" align="right" valign="top">static const boost::regex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a14203ed7eaa2d44db5e56080413e47e6">default_float_regexp</a> (&quot;^[+-]?\\d+\\.(\\d+)?([Ee][+-]?\\d+)?$&quot;)</td></tr>
<tr class="separator:a14203ed7eaa2d44db5e56080413e47e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb6ed847d7d937a5a61516dff59cc15"><td class="memItemLeft" align="right" valign="top">static const boost::regex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a6bb6ed847d7d937a5a61516dff59cc15">default_complex_regexp</a> (&quot;^(?&lt;REALPART&gt;[+-]?\\d+\\.(\\d+)?([Ee][+-]?\\d+)?)?((?&lt;IMAGSIGN&gt;[+-]?[ijI])(?&lt;IMAGPART&gt;[+-]?\\d+\\.(\\d+)?([Ee][+-]?\\d+)?)?)?$&quot;)</td></tr>
<tr class="separator:a6bb6ed847d7d937a5a61516dff59cc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad977e47244b515d817e30d88c14fcdb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#ad977e47244b515d817e30d88c14fcdb7">is_integer</a> (const <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> &amp;input)</td></tr>
<tr class="memdesc:ad977e47244b515d817e30d88c14fcdb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if input is an integer  <a href="namespacepni.html#ad977e47244b515d817e30d88c14fcdb7">More...</a><br /></td></tr>
<tr class="separator:ad977e47244b515d817e30d88c14fcdb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58304836812dfc22cce1ff9cd28a6473"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a58304836812dfc22cce1ff9cd28a6473">is_float</a> (const <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> &amp;input)</td></tr>
<tr class="memdesc:a58304836812dfc22cce1ff9cd28a6473"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if input is a floating pointer number  <a href="namespacepni.html#a58304836812dfc22cce1ff9cd28a6473">More...</a><br /></td></tr>
<tr class="separator:a58304836812dfc22cce1ff9cd28a6473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4c4ec1983e57540216e8fa719641ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a8f4c4ec1983e57540216e8fa719641ca">is_boolean</a> (const <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> &amp;input)</td></tr>
<tr class="memdesc:a8f4c4ec1983e57540216e8fa719641ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if input is a boolean value  <a href="namespacepni.html#a8f4c4ec1983e57540216e8fa719641ca">More...</a><br /></td></tr>
<tr class="separator:a8f4c4ec1983e57540216e8fa719641ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdc4e511290381b5f055ced0b1ad1a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a0bdc4e511290381b5f055ced0b1ad1a8">is_complex</a> (const <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> &amp;input)</td></tr>
<tr class="memdesc:a0bdc4e511290381b5f055ced0b1ad1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if input is a complex value  <a href="namespacepni.html#a0bdc4e511290381b5f055ced0b1ad1a8">More...</a><br /></td></tr>
<tr class="separator:a0bdc4e511290381b5f055ced0b1ad1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcc330cc2ffdd2b7416307e40d7caa1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#adbcc330cc2ffdd2b7416307e40d7caa1">is_slice</a> (const <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> &amp;input)</td></tr>
<tr class="memdesc:adbcc330cc2ffdd2b7416307e40d7caa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if input is a slice value  <a href="namespacepni.html#adbcc330cc2ffdd2b7416307e40d7caa1">More...</a><br /></td></tr>
<tr class="separator:adbcc330cc2ffdd2b7416307e40d7caa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee71063a252b0a6236cc7c62f5c1bf25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#aee71063a252b0a6236cc7c62f5c1bf25">type_id</a> (const <a class="el" href="classpni_1_1array.html">array</a> &amp;a)</td></tr>
<tr class="memdesc:aee71063a252b0a6236cc7c62f5c1bf25"><td class="mdescLeft">&#160;</td><td class="mdescRight">get type id  <a href="namespacepni.html#aee71063a252b0a6236cc7c62f5c1bf25">More...</a><br /></td></tr>
<tr class="separator:aee71063a252b0a6236cc7c62f5c1bf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2774930733701cd69776e8df3b36e025"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a2774930733701cd69776e8df3b36e025"><td class="memTemplItemLeft" align="right" valign="top">const void *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a2774930733701cd69776e8df3b36e025">get_pointer</a> (const ArrayT &amp;a)</td></tr>
<tr class="memdesc:a2774930733701cd69776e8df3b36e025"><td class="mdescLeft">&#160;</td><td class="mdescRight">get array pointer  <a href="namespacepni.html#a2774930733701cd69776e8df3b36e025">More...</a><br /></td></tr>
<tr class="separator:a2774930733701cd69776e8df3b36e025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1193a0d8b3335366197caaed54dca901"><td class="memTemplParams" colspan="2">template&lt;int const_flag&gt; </td></tr>
<tr class="memitem:a1193a0d8b3335366197caaed54dca901"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1array__iterator.html">array_iterator</a>&lt; const_flag &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a1193a0d8b3335366197caaed54dca901">operator+</a> (const <a class="el" href="classpni_1_1array__iterator.html">array_iterator</a>&lt; const_flag &gt; &amp;a, ssize_t b)</td></tr>
<tr class="memdesc:a1193a0d8b3335366197caaed54dca901"><td class="mdescLeft">&#160;</td><td class="mdescRight">add scalar to iterator  <a href="namespacepni.html#a1193a0d8b3335366197caaed54dca901">More...</a><br /></td></tr>
<tr class="separator:a1193a0d8b3335366197caaed54dca901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f31606ae2bcfd4256fcf5d6c8b9a5c4"><td class="memTemplParams" colspan="2">template&lt;int const_flag&gt; </td></tr>
<tr class="memitem:a6f31606ae2bcfd4256fcf5d6c8b9a5c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1array__iterator.html">array_iterator</a>&lt; const_flag &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a6f31606ae2bcfd4256fcf5d6c8b9a5c4">operator+</a> (ssize_t a, const <a class="el" href="classpni_1_1array__iterator.html">array_iterator</a>&lt; const_flag &gt; &amp;b)</td></tr>
<tr class="memdesc:a6f31606ae2bcfd4256fcf5d6c8b9a5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">add offset to iterator  <a href="namespacepni.html#a6f31606ae2bcfd4256fcf5d6c8b9a5c4">More...</a><br /></td></tr>
<tr class="separator:a6f31606ae2bcfd4256fcf5d6c8b9a5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9acfe7195d7134a4ce9aa9b633bb55"><td class="memTemplParams" colspan="2">template&lt;int const_flag&gt; </td></tr>
<tr class="memitem:afd9acfe7195d7134a4ce9aa9b633bb55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1array__iterator.html">array_iterator</a>&lt; const_flag &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#afd9acfe7195d7134a4ce9aa9b633bb55">operator-</a> (const <a class="el" href="classpni_1_1array__iterator.html">array_iterator</a>&lt; const_flag &gt; &amp;a, ssize_t b)</td></tr>
<tr class="memdesc:afd9acfe7195d7134a4ce9aa9b633bb55"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract offset from iterator  <a href="namespacepni.html#afd9acfe7195d7134a4ce9aa9b633bb55">More...</a><br /></td></tr>
<tr class="separator:afd9acfe7195d7134a4ce9aa9b633bb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac753dc36bf766bf821c84b12a8e65f0e"><td class="memTemplParams" colspan="2">template&lt;int const_flag&gt; </td></tr>
<tr class="memitem:ac753dc36bf766bf821c84b12a8e65f0e"><td class="memTemplItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#ac753dc36bf766bf821c84b12a8e65f0e">operator-</a> (const <a class="el" href="classpni_1_1array__iterator.html">array_iterator</a>&lt; const_flag &gt; &amp;a, const <a class="el" href="classpni_1_1array__iterator.html">array_iterator</a>&lt; const_flag &gt; &amp;b)</td></tr>
<tr class="memdesc:ac753dc36bf766bf821c84b12a8e65f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract two iterators  <a href="namespacepni.html#ac753dc36bf766bf821c84b12a8e65f0e">More...</a><br /></td></tr>
<tr class="separator:ac753dc36bf766bf821c84b12a8e65f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac427a052c509018e0f067b7c9dd226d6"><td class="memTemplParams" colspan="2">template&lt;typename ElementT , typename ShapeT &gt; </td></tr>
<tr class="memitem:ac427a052c509018e0f067b7c9dd226d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1array.html">array</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#ac427a052c509018e0f067b7c9dd226d6">make_array</a> (const ShapeT &amp;shape)</td></tr>
<tr class="memdesc:ac427a052c509018e0f067b7c9dd226d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an array  <a href="namespacepni.html#ac427a052c509018e0f067b7c9dd226d6">More...</a><br /></td></tr>
<tr class="separator:ac427a052c509018e0f067b7c9dd226d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2325f4650bec5fe449645a794567ce88"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT &gt; </td></tr>
<tr class="memitem:a2325f4650bec5fe449645a794567ce88"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1array.html">array</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a2325f4650bec5fe449645a794567ce88">make_array</a> (<a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> tid, const ContainerT &amp;shape)</td></tr>
<tr class="memdesc:a2325f4650bec5fe449645a794567ce88"><td class="mdescLeft">&#160;</td><td class="mdescRight">create array  <a href="namespacepni.html#a2325f4650bec5fe449645a794567ce88">More...</a><br /></td></tr>
<tr class="separator:a2325f4650bec5fe449645a794567ce88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27667670141c64f3aa20e0280883c96f"><td class="memTemplParams" colspan="2">template&lt;typename DataT , typename PointerT &gt; </td></tr>
<tr class="memitem:a27667670141c64f3aa20e0280883c96f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1value__holder.html">value_holder</a>&lt; DataT &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a27667670141c64f3aa20e0280883c96f">get_holder_ptr</a> (PointerT &amp;ptr)</td></tr>
<tr class="memdesc:a27667670141c64f3aa20e0280883c96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get pointer to value holder  <a href="namespacepni.html#a27667670141c64f3aa20e0280883c96f">More...</a><br /></td></tr>
<tr class="separator:a27667670141c64f3aa20e0280883c96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77b7a4b02919abedfedcbc34852d421"><td class="memTemplParams" colspan="2">template&lt;typename TargetT , typename SourceT , typename PointerT &gt; </td></tr>
<tr class="memitem:ae77b7a4b02919abedfedcbc34852d421"><td class="memTemplItemLeft" align="right" valign="top">TargetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#ae77b7a4b02919abedfedcbc34852d421">get_value</a> (PointerT holder_ptr)</td></tr>
<tr class="memdesc:ae77b7a4b02919abedfedcbc34852d421"><td class="mdescLeft">&#160;</td><td class="mdescRight">get value from holder  <a href="namespacepni.html#ae77b7a4b02919abedfedcbc34852d421">More...</a><br /></td></tr>
<tr class="separator:ae77b7a4b02919abedfedcbc34852d421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd3514df6b58ef00906322a75c2a265"><td class="memTemplParams" colspan="2">template&lt;typename TargetT , typename SourceT , typename PointerT &gt; </td></tr>
<tr class="memitem:addd3514df6b58ef00906322a75c2a265"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#addd3514df6b58ef00906322a75c2a265">set_value</a> (PointerT holder_ptr, const SourceT &amp;v)</td></tr>
<tr class="memdesc:addd3514df6b58ef00906322a75c2a265"><td class="mdescLeft">&#160;</td><td class="mdescRight">set value to holder  <a href="namespacepni.html#addd3514df6b58ef00906322a75c2a265">More...</a><br /></td></tr>
<tr class="separator:addd3514df6b58ef00906322a75c2a265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e20eb9ab4a6d4d22e70b58392a918c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#ab1e20eb9ab4a6d4d22e70b58392a918c">type_id</a> (const <a class="el" href="classpni_1_1value.html">value</a> &amp;rv)</td></tr>
<tr class="memdesc:ab1e20eb9ab4a6d4d22e70b58392a918c"><td class="mdescLeft">&#160;</td><td class="mdescRight">get type ID  <a href="namespacepni.html#ab1e20eb9ab4a6d4d22e70b58392a918c">More...</a><br /></td></tr>
<tr class="separator:ab1e20eb9ab4a6d4d22e70b58392a918c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6f536120b44e60b2362e5c26837ba6"><td class="memTemplParams" colspan="2">template&lt;typename RequestedT &gt; </td></tr>
<tr class="memitem:abf6f536120b44e60b2362e5c26837ba6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1value.html">value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#abf6f536120b44e60b2362e5c26837ba6">make_value</a> ()</td></tr>
<tr class="memdesc:abf6f536120b44e60b2362e5c26837ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">create value  <a href="namespacepni.html#abf6f536120b44e60b2362e5c26837ba6">More...</a><br /></td></tr>
<tr class="separator:abf6f536120b44e60b2362e5c26837ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f80e9a3461926f85c082425d23e34c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="classpni_1_1value.html">value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a05f80e9a3461926f85c082425d23e34c">make_value</a> (<a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> tid)</td></tr>
<tr class="memdesc:a05f80e9a3461926f85c082425d23e34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">create value  <a href="namespacepni.html#a05f80e9a3461926f85c082425d23e34c">More...</a><br /></td></tr>
<tr class="separator:a05f80e9a3461926f85c082425d23e34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb98fd17978c46e9a143d5fc88539d6e"><td class="memTemplParams" colspan="2">template&lt;typename GeneralT &gt; </td></tr>
<tr class="memitem:abb98fd17978c46e9a143d5fc88539d6e"><td class="memTemplItemLeft" align="right" valign="top">GeneralT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#abb98fd17978c46e9a143d5fc88539d6e">get_ref</a> (GeneralT &amp;v) noexcept</td></tr>
<tr class="memdesc:abb98fd17978c46e9a143d5fc88539d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return reference  <a href="namespacepni.html#abb98fd17978c46e9a143d5fc88539d6e">More...</a><br /></td></tr>
<tr class="separator:abb98fd17978c46e9a143d5fc88539d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043017853e1d28b8dcad8dad17c6a4d0"><td class="memTemplParams" colspan="2">template&lt;typename PrimitiveT &gt; </td></tr>
<tr class="memitem:a043017853e1d28b8dcad8dad17c6a4d0"><td class="memTemplItemLeft" align="right" valign="top">const PrimitiveT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a043017853e1d28b8dcad8dad17c6a4d0">get_const_ref</a> (const PrimitiveT &amp;v) noexcept</td></tr>
<tr class="memdesc:a043017853e1d28b8dcad8dad17c6a4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return const reference  <a href="namespacepni.html#a043017853e1d28b8dcad8dad17c6a4d0">More...</a><br /></td></tr>
<tr class="separator:a043017853e1d28b8dcad8dad17c6a4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb512bdbdc0777543dafb35a1d1b7f8"><td class="memTemplParams" colspan="2">template&lt;typename GeneralT &gt; </td></tr>
<tr class="memitem:a1eb512bdbdc0777543dafb35a1d1b7f8"><td class="memTemplItemLeft" align="right" valign="top">GeneralT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a1eb512bdbdc0777543dafb35a1d1b7f8">get_ref</a> (std::reference_wrapper&lt; GeneralT &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:a1eb512bdbdc0777543dafb35a1d1b7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return reference  <a href="namespacepni.html#a1eb512bdbdc0777543dafb35a1d1b7f8">More...</a><br /></td></tr>
<tr class="separator:a1eb512bdbdc0777543dafb35a1d1b7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e26a795d616a8d98d4522f8cd0c841"><td class="memTemplParams" colspan="2">template&lt;typename GeneralT &gt; </td></tr>
<tr class="memitem:a10e26a795d616a8d98d4522f8cd0c841"><td class="memTemplItemLeft" align="right" valign="top">const GeneralT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a10e26a795d616a8d98d4522f8cd0c841">get_const_ref</a> (const std::reference_wrapper&lt; GeneralT &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:a10e26a795d616a8d98d4522f8cd0c841"><td class="mdescLeft">&#160;</td><td class="mdescRight">return const reference  <a href="namespacepni.html#a10e26a795d616a8d98d4522f8cd0c841">More...</a><br /></td></tr>
<tr class="separator:a10e26a795d616a8d98d4522f8cd0c841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c717ca89e487ad64a06d46c5a66b7cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="classpni_1_1value.html">value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a6c717ca89e487ad64a06d46c5a66b7cc">to_value</a> (const <a class="el" href="classpni_1_1value__ref.html">value_ref</a> &amp;v)</td></tr>
<tr class="memdesc:a6c717ca89e487ad64a06d46c5a66b7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">conversion function to value  <a href="namespacepni.html#a6c717ca89e487ad64a06d46c5a66b7cc">More...</a><br /></td></tr>
<tr class="separator:a6c717ca89e487ad64a06d46c5a66b7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e84e156126ee18585bde2da4fefa2c"><td class="memTemplParams" colspan="2">template&lt;typename NativeT &gt; </td></tr>
<tr class="memitem:a60e84e156126ee18585bde2da4fefa2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a60e84e156126ee18585bde2da4fefa2c">operator+</a> (const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;a, const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;b)=delete</td></tr>
<tr class="memdesc:a60e84e156126ee18585bde2da4fefa2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary addition is deleted for BinaryType&lt;NativeT&gt;  <a href="namespacepni.html#a60e84e156126ee18585bde2da4fefa2c">More...</a><br /></td></tr>
<tr class="separator:a60e84e156126ee18585bde2da4fefa2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0a3e529d9ec13029b8589c853498a2"><td class="memTemplParams" colspan="2">template&lt;typename NativeT &gt; </td></tr>
<tr class="memitem:afe0a3e529d9ec13029b8589c853498a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#afe0a3e529d9ec13029b8589c853498a2">operator-</a> (const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;a, const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;b)=delete</td></tr>
<tr class="memdesc:afe0a3e529d9ec13029b8589c853498a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary subtraction is deleted for BinaryType&lt;NativeT&gt;  <a href="namespacepni.html#afe0a3e529d9ec13029b8589c853498a2">More...</a><br /></td></tr>
<tr class="separator:afe0a3e529d9ec13029b8589c853498a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a9c81b86c6ac1ecbccee9fa73c655f"><td class="memTemplParams" colspan="2">template&lt;typename NativeT &gt; </td></tr>
<tr class="memitem:a98a9c81b86c6ac1ecbccee9fa73c655f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a98a9c81b86c6ac1ecbccee9fa73c655f">operator*</a> (const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;a, const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;b)=delete</td></tr>
<tr class="memdesc:a98a9c81b86c6ac1ecbccee9fa73c655f"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary multiplication is deleted for binary_t&lt;NativeT&gt;  <a href="namespacepni.html#a98a9c81b86c6ac1ecbccee9fa73c655f">More...</a><br /></td></tr>
<tr class="separator:a98a9c81b86c6ac1ecbccee9fa73c655f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3501629e3965d184155e3a5a13862a93"><td class="memTemplParams" colspan="2">template&lt;typename NativeT &gt; </td></tr>
<tr class="memitem:a3501629e3965d184155e3a5a13862a93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a3501629e3965d184155e3a5a13862a93">operator/</a> (const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;a, const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;b)=delete</td></tr>
<tr class="memdesc:a3501629e3965d184155e3a5a13862a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary division is deleted for binary_t&lt;NativeT&gt;  <a href="namespacepni.html#a3501629e3965d184155e3a5a13862a93">More...</a><br /></td></tr>
<tr class="separator:a3501629e3965d184155e3a5a13862a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62d81b395f0abab9dc37fac6a767c06d"><td class="memTemplParams" colspan="2">template&lt;typename NativeT &gt; </td></tr>
<tr class="memitem:ga62d81b395f0abab9dc37fac6a767c06d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga62d81b395f0abab9dc37fac6a767c06d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;o)</td></tr>
<tr class="memdesc:ga62d81b395f0abab9dc37fac6a767c06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">output stream operator for binary data  <a href="group__type__classes.html#ga62d81b395f0abab9dc37fac6a767c06d">More...</a><br /></td></tr>
<tr class="separator:ga62d81b395f0abab9dc37fac6a767c06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf64ab25a88b0ab80bf64b3351f28454f"><td class="memTemplParams" colspan="2">template&lt;typename NativeT &gt; </td></tr>
<tr class="memitem:gaf64ab25a88b0ab80bf64b3351f28454f"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gaf64ab25a88b0ab80bf64b3351f28454f">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;o)</td></tr>
<tr class="memdesc:gaf64ab25a88b0ab80bf64b3351f28454f"><td class="mdescLeft">&#160;</td><td class="mdescRight">input stream operator for binary data  <a href="group__type__classes.html#gaf64ab25a88b0ab80bf64b3351f28454f">More...</a><br /></td></tr>
<tr class="separator:gaf64ab25a88b0ab80bf64b3351f28454f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca9bb2620f3528c2240d61b93de1fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a5ca9bb2620f3528c2240d61b93de1fb5">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classpni_1_1bool__t.html">bool_t</a> &amp;b)</td></tr>
<tr class="memdesc:a5ca9bb2620f3528c2240d61b93de1fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">output operator for <a class="el" href="classpni_1_1bool__t.html" title="boolean type">bool_t</a>  <a href="namespacepni.html#a5ca9bb2620f3528c2240d61b93de1fb5">More...</a><br /></td></tr>
<tr class="separator:a5ca9bb2620f3528c2240d61b93de1fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0127c98150b1380e9c3c153c4a05fe30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a0127c98150b1380e9c3c153c4a05fe30">operator&gt;&gt;</a> (std::istream &amp;stream, <a class="el" href="classpni_1_1bool__t.html">bool_t</a> &amp;b)</td></tr>
<tr class="memdesc:a0127c98150b1380e9c3c153c4a05fe30"><td class="mdescLeft">&#160;</td><td class="mdescRight">input operator for <a class="el" href="classpni_1_1bool__t.html" title="boolean type">bool_t</a>  <a href="namespacepni.html#a0127c98150b1380e9c3c153c4a05fe30">More...</a><br /></td></tr>
<tr class="separator:a0127c98150b1380e9c3c153c4a05fe30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0887774263fc1221b266d79d1568d162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a0887774263fc1221b266d79d1568d162">operator&gt;&gt;</a> (std::istream &amp;stream, hdf5::datatype::EBool &amp;b)</td></tr>
<tr class="memdesc:a0887774263fc1221b266d79d1568d162"><td class="mdescLeft">&#160;</td><td class="mdescRight">input operator for EBool  <a href="namespacepni.html#a0887774263fc1221b266d79d1568d162">More...</a><br /></td></tr>
<tr class="separator:a0887774263fc1221b266d79d1568d162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ded422a6016144bd88da6fa9737689c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a2ded422a6016144bd88da6fa9737689c">operator==</a> (const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &amp;a, const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &amp;b)</td></tr>
<tr class="memdesc:a2ded422a6016144bd88da6fa9737689c"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex number equality operator  <a href="namespacepni.html#a2ded422a6016144bd88da6fa9737689c">More...</a><br /></td></tr>
<tr class="separator:a2ded422a6016144bd88da6fa9737689c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13be3245115f4233dea78522fc8af691"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a13be3245115f4233dea78522fc8af691">operator==</a> (const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &amp;a, const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &amp;b)</td></tr>
<tr class="memdesc:a13be3245115f4233dea78522fc8af691"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex number equality operator  <a href="namespacepni.html#a13be3245115f4233dea78522fc8af691">More...</a><br /></td></tr>
<tr class="separator:a13be3245115f4233dea78522fc8af691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66e18e84085bf3e30dc25624d305693"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#ae66e18e84085bf3e30dc25624d305693">operator==</a> (const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &amp;a, const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &amp;b)</td></tr>
<tr class="memdesc:ae66e18e84085bf3e30dc25624d305693"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex number equality operator  <a href="namespacepni.html#ae66e18e84085bf3e30dc25624d305693">More...</a><br /></td></tr>
<tr class="separator:ae66e18e84085bf3e30dc25624d305693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae189254b51c42519b2cc29afcb557e51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#ae189254b51c42519b2cc29afcb557e51">operator==</a> (const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &amp;a, const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &amp;b)</td></tr>
<tr class="memdesc:ae189254b51c42519b2cc29afcb557e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex number equality operator  <a href="namespacepni.html#ae189254b51c42519b2cc29afcb557e51">More...</a><br /></td></tr>
<tr class="separator:ae189254b51c42519b2cc29afcb557e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd9d973064d0d2c88c15f6c5f0a61e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a7fd9d973064d0d2c88c15f6c5f0a61e6">operator==</a> (const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &amp;a, const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &amp;b)</td></tr>
<tr class="memdesc:a7fd9d973064d0d2c88c15f6c5f0a61e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex number equality operator  <a href="namespacepni.html#a7fd9d973064d0d2c88c15f6c5f0a61e6">More...</a><br /></td></tr>
<tr class="separator:a7fd9d973064d0d2c88c15f6c5f0a61e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7528a060d3d6fb4a7dad065c573337"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a8e7528a060d3d6fb4a7dad065c573337">operator==</a> (const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &amp;a, const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &amp;b)</td></tr>
<tr class="memdesc:a8e7528a060d3d6fb4a7dad065c573337"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex number equality operator  <a href="namespacepni.html#a8e7528a060d3d6fb4a7dad065c573337">More...</a><br /></td></tr>
<tr class="separator:a8e7528a060d3d6fb4a7dad065c573337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0c21f8838f51f7722558679728083f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#aeb0c21f8838f51f7722558679728083f">operator!=</a> (const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &amp;a, const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &amp;b)</td></tr>
<tr class="memdesc:aeb0c21f8838f51f7722558679728083f"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex number inequality operator  <a href="namespacepni.html#aeb0c21f8838f51f7722558679728083f">More...</a><br /></td></tr>
<tr class="separator:aeb0c21f8838f51f7722558679728083f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215775f74dc0fc480e1ab3b86aa354ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a215775f74dc0fc480e1ab3b86aa354ac">operator!=</a> (const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &amp;a, const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &amp;b)</td></tr>
<tr class="memdesc:a215775f74dc0fc480e1ab3b86aa354ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex number inequality operator  <a href="namespacepni.html#a215775f74dc0fc480e1ab3b86aa354ac">More...</a><br /></td></tr>
<tr class="separator:a215775f74dc0fc480e1ab3b86aa354ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8c0c3f0ef9917ad95fecc35736ee0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a4b8c0c3f0ef9917ad95fecc35736ee0b">operator!=</a> (const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &amp;a, const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &amp;b)</td></tr>
<tr class="memdesc:a4b8c0c3f0ef9917ad95fecc35736ee0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex number inequality operator  <a href="namespacepni.html#a4b8c0c3f0ef9917ad95fecc35736ee0b">More...</a><br /></td></tr>
<tr class="separator:a4b8c0c3f0ef9917ad95fecc35736ee0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb439fed10c39768f3ab549272e4d94a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#aeb439fed10c39768f3ab549272e4d94a">operator!=</a> (const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &amp;a, const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &amp;b)</td></tr>
<tr class="memdesc:aeb439fed10c39768f3ab549272e4d94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex number inequality operator  <a href="namespacepni.html#aeb439fed10c39768f3ab549272e4d94a">More...</a><br /></td></tr>
<tr class="separator:aeb439fed10c39768f3ab549272e4d94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5141a5d9de1862763aa31eab2e553e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#ad5141a5d9de1862763aa31eab2e553e3">operator!=</a> (const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &amp;a, const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &amp;b)</td></tr>
<tr class="memdesc:ad5141a5d9de1862763aa31eab2e553e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex number inequality operator  <a href="namespacepni.html#ad5141a5d9de1862763aa31eab2e553e3">More...</a><br /></td></tr>
<tr class="separator:ad5141a5d9de1862763aa31eab2e553e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af135173a612f5e3440dfb16a8fd88388"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#af135173a612f5e3440dfb16a8fd88388">operator!=</a> (const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &amp;a, const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &amp;b)</td></tr>
<tr class="memdesc:af135173a612f5e3440dfb16a8fd88388"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex number inequality operator  <a href="namespacepni.html#af135173a612f5e3440dfb16a8fd88388">More...</a><br /></td></tr>
<tr class="separator:af135173a612f5e3440dfb16a8fd88388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4fc50e24b34c39cd5e5bc0eab4ec58"><td class="memTemplParams" colspan="2">template&lt;typename TargetT , typename SourceT &gt; </td></tr>
<tr class="memitem:a8f4fc50e24b34c39cd5e5bc0eab4ec58"><td class="memTemplItemLeft" align="right" valign="top">TargetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a8f4fc50e24b34c39cd5e5bc0eab4ec58">convert</a> (const SourceT &amp;source)</td></tr>
<tr class="memdesc:a8f4fc50e24b34c39cd5e5bc0eab4ec58"><td class="mdescLeft">&#160;</td><td class="mdescRight">type conversion function template  <a href="namespacepni.html#a8f4fc50e24b34c39cd5e5bc0eab4ec58">More...</a><br /></td></tr>
<tr class="separator:a8f4fc50e24b34c39cd5e5bc0eab4ec58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73bdb8ed778470ebcbfccda9ecf4001c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga73bdb8ed778470ebcbfccda9ecf4001c">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="structpni_1_1none.html">none</a> &amp;n)</td></tr>
<tr class="memdesc:ga73bdb8ed778470ebcbfccda9ecf4001c"><td class="mdescLeft">&#160;</td><td class="mdescRight">output stream for none  <a href="group__type__classes.html#ga73bdb8ed778470ebcbfccda9ecf4001c">More...</a><br /></td></tr>
<tr class="separator:ga73bdb8ed778470ebcbfccda9ecf4001c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed999ca8bafe7e4028123834e6a163ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gaed999ca8bafe7e4028123834e6a163ae">operator&gt;&gt;</a> (std::istream &amp;stream, <a class="el" href="structpni_1_1none.html">none</a> &amp;n)</td></tr>
<tr class="memdesc:gaed999ca8bafe7e4028123834e6a163ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">input stream for none  <a href="group__type__classes.html#gaed999ca8bafe7e4028123834e6a163ae">More...</a><br /></td></tr>
<tr class="separator:gaed999ca8bafe7e4028123834e6a163ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf05b9b0fa6d3b2841056c5c2d4404eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gacf05b9b0fa6d3b2841056c5c2d4404eb">operator==</a> (const <a class="el" href="structpni_1_1none.html">none</a> &amp;a, const <a class="el" href="structpni_1_1none.html">none</a> &amp;b)</td></tr>
<tr class="memdesc:gacf05b9b0fa6d3b2841056c5c2d4404eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">equality operator for none  <a href="group__type__classes.html#gacf05b9b0fa6d3b2841056c5c2d4404eb">More...</a><br /></td></tr>
<tr class="separator:gacf05b9b0fa6d3b2841056c5c2d4404eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7e3e9f567bd2819c1644b9e519b11cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gaa7e3e9f567bd2819c1644b9e519b11cb">operator!=</a> (const <a class="el" href="structpni_1_1none.html">none</a> &amp;a, const <a class="el" href="structpni_1_1none.html">none</a> &amp;b)</td></tr>
<tr class="memdesc:gaa7e3e9f567bd2819c1644b9e519b11cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">inquality operator for none  <a href="group__type__classes.html#gaa7e3e9f567bd2819c1644b9e519b11cb">More...</a><br /></td></tr>
<tr class="separator:gaa7e3e9f567bd2819c1644b9e519b11cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dc46b894c5262ed43d7bdeec105a91e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga9dc46b894c5262ed43d7bdeec105a91e">is_numeric</a> (<a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> tid)</td></tr>
<tr class="memdesc:ga9dc46b894c5262ed43d7bdeec105a91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">check numeric type  <a href="group__type__classes.html#ga9dc46b894c5262ed43d7bdeec105a91e">More...</a><br /></td></tr>
<tr class="separator:ga9dc46b894c5262ed43d7bdeec105a91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac78b039a87a88888a5b1a0acf26a4f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gac78b039a87a88888a5b1a0acf26a4f70">is_integer</a> (<a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> tid)</td></tr>
<tr class="memdesc:gac78b039a87a88888a5b1a0acf26a4f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">check integer type  <a href="group__type__classes.html#gac78b039a87a88888a5b1a0acf26a4f70">More...</a><br /></td></tr>
<tr class="separator:gac78b039a87a88888a5b1a0acf26a4f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5aaa37c930a9d1f0407cce48f0115cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gae5aaa37c930a9d1f0407cce48f0115cc">is_complex</a> (<a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> tid)</td></tr>
<tr class="memdesc:gae5aaa37c930a9d1f0407cce48f0115cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">check complex type  <a href="group__type__classes.html#gae5aaa37c930a9d1f0407cce48f0115cc">More...</a><br /></td></tr>
<tr class="separator:gae5aaa37c930a9d1f0407cce48f0115cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd69134dd1bf43aa064f9a33ea8dde32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gafd69134dd1bf43aa064f9a33ea8dde32">is_float</a> (<a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> tid)</td></tr>
<tr class="memdesc:gafd69134dd1bf43aa064f9a33ea8dde32"><td class="mdescLeft">&#160;</td><td class="mdescRight">check float type  <a href="group__type__classes.html#gafd69134dd1bf43aa064f9a33ea8dde32">More...</a><br /></td></tr>
<tr class="separator:gafd69134dd1bf43aa064f9a33ea8dde32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3687c344d76e9bacd58d9291963947b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gaa3687c344d76e9bacd58d9291963947b">is_unchecked_convertible</a> (<a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> source_tid, <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> target_tid)</td></tr>
<tr class="memdesc:gaa3687c344d76e9bacd58d9291963947b"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if two types are unchecked convertible  <a href="group__type__classes.html#gaa3687c344d76e9bacd58d9291963947b">More...</a><br /></td></tr>
<tr class="separator:gaa3687c344d76e9bacd58d9291963947b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2757078f2804201c182045700d3c150a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga2757078f2804201c182045700d3c150a">is_checked_convertible</a> (<a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> source_tid, <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> target_tid)</td></tr>
<tr class="memdesc:ga2757078f2804201c182045700d3c150a"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if two types are checked convertible  <a href="group__type__classes.html#ga2757078f2804201c182045700d3c150a">More...</a><br /></td></tr>
<tr class="separator:ga2757078f2804201c182045700d3c150a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacae1092dd40556ecdb80eed479f3f0af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gacae1092dd40556ecdb80eed479f3f0af">is_convertible</a> (<a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> source_tid, <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> target_tid)</td></tr>
<tr class="memdesc:gacae1092dd40556ecdb80eed479f3f0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if two types are unchecked convertible  <a href="group__type__classes.html#gacae1092dd40556ecdb80eed479f3f0af">More...</a><br /></td></tr>
<tr class="separator:gacae1092dd40556ecdb80eed479f3f0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65609eb7408d16944918eabc68b006b1"><td class="memTemplParams" colspan="2">template&lt;typename GeneralT &gt; </td></tr>
<tr class="memitem:a65609eb7408d16944918eabc68b006b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a65609eb7408d16944918eabc68b006b1">get_type_id</a> (const std::complex&lt; GeneralT &gt; &amp;)</td></tr>
<tr class="memdesc:a65609eb7408d16944918eabc68b006b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_type_id version for complex numbers  <a href="namespacepni.html#a65609eb7408d16944918eabc68b006b1">More...</a><br /></td></tr>
<tr class="separator:a65609eb7408d16944918eabc68b006b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8729e0dea6b27251d576cdb142107ed2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a8729e0dea6b27251d576cdb142107ed2">get_type_id</a> (const <a class="el" href="group__type__classes.html#gab80fde605a35ad90da1651d7d3c67893">binary</a> &amp;v)</td></tr>
<tr class="memdesc:a8729e0dea6b27251d576cdb142107ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_type_id overload for binary data  <a href="namespacepni.html#a8729e0dea6b27251d576cdb142107ed2">More...</a><br /></td></tr>
<tr class="separator:a8729e0dea6b27251d576cdb142107ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a8a832b647d5e03dfbffd5b0f6765e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a61a8a832b647d5e03dfbffd5b0f6765e">get_type_id</a> (const <a class="el" href="classpni_1_1bool__t.html">bool_t</a> &amp;v)</td></tr>
<tr class="memdesc:a61a8a832b647d5e03dfbffd5b0f6765e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_type_id overload for <a class="el" href="classpni_1_1bool__t.html" title="boolean type">bool_t</a> data  <a href="namespacepni.html#a61a8a832b647d5e03dfbffd5b0f6765e">More...</a><br /></td></tr>
<tr class="separator:a61a8a832b647d5e03dfbffd5b0f6765e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60567aab430d75f07d3f3e40c8e0880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#ac60567aab430d75f07d3f3e40c8e0880">get_type_id</a> (const hdf5::datatype::EBool &amp;v)</td></tr>
<tr class="memdesc:ac60567aab430d75f07d3f3e40c8e0880"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_type_id overload for EBool data  <a href="namespacepni.html#ac60567aab430d75f07d3f3e40c8e0880">More...</a><br /></td></tr>
<tr class="separator:ac60567aab430d75f07d3f3e40c8e0880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9024e2de3cbf10d6e4f40234a906ebf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepni.html#a9024e2de3cbf10d6e4f40234a906ebf5">get_type_id</a> (const <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">string</a> &amp;v)</td></tr>
<tr class="memdesc:a9024e2de3cbf10d6e4f40234a906ebf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_type_id overload for string data  <a href="namespacepni.html#a9024e2de3cbf10d6e4f40234a906ebf5">More...</a><br /></td></tr>
<tr class="separator:a9024e2de3cbf10d6e4f40234a906ebf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4ce480369576207d02b82b1c24de83"><td class="memTemplParams" colspan="2">template&lt;typename GeneralT &gt; </td></tr>
<tr class="memitem:aab4ce480369576207d02b82b1c24de83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#aab4ce480369576207d02b82b1c24de83">get_type_id</a> (const GeneralT &amp;, <a class="el" href="namespacepni.html#aec9ea31f62e69214bab4247566bc40b3">enable_if</a>&lt; <a class="el" href="namespacepni.html#aeb2fe59951e962490d8ba70db87bccb4">is_pod</a>&lt; GeneralT &gt;&gt; *=0)</td></tr>
<tr class="memdesc:aab4ce480369576207d02b82b1c24de83"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_type_id for POD data  <a href="namespacepni.html#aab4ce480369576207d02b82b1c24de83">More...</a><br /></td></tr>
<tr class="separator:aab4ce480369576207d02b82b1c24de83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f3093cb5ed1984fce5369367c3566a"><td class="memTemplParams" colspan="2">template&lt;typename GeneralT &gt; </td></tr>
<tr class="memitem:a67f3093cb5ed1984fce5369367c3566a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a67f3093cb5ed1984fce5369367c3566a">get_type_id</a> (const GeneralT &amp;, <a class="el" href="namespacepni.html#aec9ea31f62e69214bab4247566bc40b3">enable_if</a>&lt; <a class="el" href="structpni_1_1not__t.html">not_t</a>&lt; <a class="el" href="namespacepni.html#aeb2fe59951e962490d8ba70db87bccb4">is_pod</a>&lt; GeneralT &gt;&gt;&gt; *=0)</td></tr>
<tr class="memdesc:a67f3093cb5ed1984fce5369367c3566a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_type_id for containers  <a href="namespacepni.html#a67f3093cb5ed1984fce5369367c3566a">More...</a><br /></td></tr>
<tr class="separator:a67f3093cb5ed1984fce5369367c3566a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e9d1dd5f5654e103f9dc31e9d68de16"><td class="memTemplParams" colspan="2">template&lt;typename GeneralT &gt; </td></tr>
<tr class="memitem:ga3e9d1dd5f5654e103f9dc31e9d68de16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga3e9d1dd5f5654e103f9dc31e9d68de16">type_id</a> (const GeneralT &amp;)</td></tr>
<tr class="memdesc:ga3e9d1dd5f5654e103f9dc31e9d68de16"><td class="mdescLeft">&#160;</td><td class="mdescRight">get type id of an object  <a href="group__type__classes.html#ga3e9d1dd5f5654e103f9dc31e9d68de16">More...</a><br /></td></tr>
<tr class="separator:ga3e9d1dd5f5654e103f9dc31e9d68de16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab184958f9dfbd01a2bc687d0e09a6944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gab184958f9dfbd01a2bc687d0e09a6944">type_id_from_str</a> (const <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">string</a> &amp;s)</td></tr>
<tr class="memdesc:gab184958f9dfbd01a2bc687d0e09a6944"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a type ID from a string  <a href="group__type__classes.html#gab184958f9dfbd01a2bc687d0e09a6944">More...</a><br /></td></tr>
<tr class="separator:gab184958f9dfbd01a2bc687d0e09a6944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeedd118d2eb933e54e989eea4d85528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#gadeedd118d2eb933e54e989eea4d85528">str_from_type_id</a> (<a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> id)</td></tr>
<tr class="memdesc:gadeedd118d2eb933e54e989eea4d85528"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the string rep. for a type  <a href="group__type__classes.html#gadeedd118d2eb933e54e989eea4d85528">More...</a><br /></td></tr>
<tr class="separator:gadeedd118d2eb933e54e989eea4d85528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73b873733f07704f8ddd93f6695cf9cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__classes.html#ga73b873733f07704f8ddd93f6695cf9cc">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> &amp;tid)</td></tr>
<tr class="memdesc:ga73b873733f07704f8ddd93f6695cf9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">output operator for type_id_t  <a href="group__type__classes.html#ga73b873733f07704f8ddd93f6695cf9cc">More...</a><br /></td></tr>
<tr class="separator:ga73b873733f07704f8ddd93f6695cf9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc25815126216a8c42fc75ddc8483fe"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename SourceT &gt; </td></tr>
<tr class="memitem:a8fc25815126216a8c42fc75ddc8483fe"><td class="memTemplItemLeft" align="right" valign="top">ContainerT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a8fc25815126216a8c42fc75ddc8483fe">build_type_id_container</a> ()</td></tr>
<tr class="separator:a8fc25815126216a8c42fc75ddc8483fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5d083de7da82d07c903954e50a53b1"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename MapT &gt; </td></tr>
<tr class="memitem:abe5d083de7da82d07c903954e50a53b1"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>, <a class="el" href="namespacepni.html#a92a619e389a5e7f8600cf10857da88db">type_id_vector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#abe5d083de7da82d07c903954e50a53b1">generate_map_element</a> ()</td></tr>
<tr class="memdesc:abe5d083de7da82d07c903954e50a53b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate type map pairs  <a href="namespacepni.html#abe5d083de7da82d07c903954e50a53b1">More...</a><br /></td></tr>
<tr class="separator:abe5d083de7da82d07c903954e50a53b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a872948fa1c3299ee5d37127faa3d4"><td class="memTemplParams" colspan="2">template&lt;typename IterableT &gt; </td></tr>
<tr class="memitem:a39a872948fa1c3299ee5d37127faa3d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1container__iterator.html">container_iterator</a>&lt; IterableT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a39a872948fa1c3299ee5d37127faa3d4">operator+</a> (const <a class="el" href="classpni_1_1container__iterator.html">container_iterator</a>&lt; IterableT &gt; &amp;a, ssize_t b)</td></tr>
<tr class="memdesc:a39a872948fa1c3299ee5d37127faa3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">add scalar to iterator  <a href="namespacepni.html#a39a872948fa1c3299ee5d37127faa3d4">More...</a><br /></td></tr>
<tr class="separator:a39a872948fa1c3299ee5d37127faa3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6a4b2ed8c3c6bfc559d672ffed6142"><td class="memTemplParams" colspan="2">template&lt;typename IterableT &gt; </td></tr>
<tr class="memitem:a0d6a4b2ed8c3c6bfc559d672ffed6142"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1container__iterator.html">container_iterator</a>&lt; IterableT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a0d6a4b2ed8c3c6bfc559d672ffed6142">operator+</a> (ssize_t a, const <a class="el" href="classpni_1_1container__iterator.html">container_iterator</a>&lt; IterableT &gt; &amp;b)</td></tr>
<tr class="memdesc:a0d6a4b2ed8c3c6bfc559d672ffed6142"><td class="mdescLeft">&#160;</td><td class="mdescRight">add offset to iterator  <a href="namespacepni.html#a0d6a4b2ed8c3c6bfc559d672ffed6142">More...</a><br /></td></tr>
<tr class="separator:a0d6a4b2ed8c3c6bfc559d672ffed6142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5161eae5a68184423fb2024811b7ce38"><td class="memTemplParams" colspan="2">template&lt;typename IterableT &gt; </td></tr>
<tr class="memitem:a5161eae5a68184423fb2024811b7ce38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpni_1_1container__iterator.html">container_iterator</a>&lt; IterableT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a5161eae5a68184423fb2024811b7ce38">operator-</a> (const <a class="el" href="classpni_1_1container__iterator.html">container_iterator</a>&lt; IterableT &gt; &amp;a, ssize_t b)</td></tr>
<tr class="memdesc:a5161eae5a68184423fb2024811b7ce38"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract offset from iterator  <a href="namespacepni.html#a5161eae5a68184423fb2024811b7ce38">More...</a><br /></td></tr>
<tr class="separator:a5161eae5a68184423fb2024811b7ce38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310f0edd92fc0287d78cbc16d807917f"><td class="memTemplParams" colspan="2">template&lt;typename IterableT &gt; </td></tr>
<tr class="memitem:a310f0edd92fc0287d78cbc16d807917f"><td class="memTemplItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a310f0edd92fc0287d78cbc16d807917f">operator-</a> (const <a class="el" href="classpni_1_1container__iterator.html">container_iterator</a>&lt; IterableT &gt; &amp;a, const <a class="el" href="classpni_1_1container__iterator.html">container_iterator</a>&lt; IterableT &gt; &amp;b)</td></tr>
<tr class="memdesc:a310f0edd92fc0287d78cbc16d807917f"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract two iterators  <a href="namespacepni.html#a310f0edd92fc0287d78cbc16d807917f">More...</a><br /></td></tr>
<tr class="separator:a310f0edd92fc0287d78cbc16d807917f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb022f9ad595b350b2cfd80da9ec140"><td class="memTemplParams" colspan="2">template&lt;typename ShapeT &gt; </td></tr>
<tr class="memitem:addb022f9ad595b350b2cfd80da9ec140"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#addb022f9ad595b350b2cfd80da9ec140">check_size</a> (ShapeT)</td></tr>
<tr class="separator:addb022f9ad595b350b2cfd80da9ec140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b2cf61bdb829876ee6720acf183a9c"><td class="memTemplParams" colspan="2">template&lt;typename ShapeT , typename ContainerT , typename ... ContainersT&gt; </td></tr>
<tr class="memitem:a76b2cf61bdb829876ee6720acf183a9c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#a76b2cf61bdb829876ee6720acf183a9c">check_size</a> (ShapeT s, const ContainerT &amp;c, const ContainersT &amp;...cs)</td></tr>
<tr class="separator:a76b2cf61bdb829876ee6720acf183a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8794c4afa1ff0af09f207a23a3c3cdd"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ... ContainersT&gt; </td></tr>
<tr class="memitem:ac8794c4afa1ff0af09f207a23a3c3cdd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepni.html#ac8794c4afa1ff0af09f207a23a3c3cdd">check_equal_size</a> (const ContainerT &amp;c, const ContainersT &amp;...cs)</td></tr>
<tr class="memdesc:ac8794c4afa1ff0af09f207a23a3c3cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">check container sizes  <a href="namespacepni.html#ac8794c4afa1ff0af09f207a23a3c3cdd">More...</a><br /></td></tr>
<tr class="separator:ac8794c4afa1ff0af09f207a23a3c3cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>(c) Copyright 2011 DESY, Eugen Wintersberger <a href="#" onclick="location.href='mai'+'lto:'+'eug'+'en'+'.wi'+'nt'+'ers'+'be'+'rge'+'r@'+'des'+'y.'+'de'; return false;">eugen<span style="display: none;">.nosp@m.</span>.win<span style="display: none;">.nosp@m.</span>tersb<span style="display: none;">.nosp@m.</span>erge<span style="display: none;">.nosp@m.</span>r@des<span style="display: none;">.nosp@m.</span>y.de</a></p>
<p>This file is part of libpninexus.</p>
<p>libpninexus is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 2 of the License, or (at your option) any later version.</p>
<p>libpninexus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with libpninexus. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<hr  />
<p>Created on: May 22, 2012 Author: Eugen Wintersberger <a href="#" onclick="location.href='mai'+'lto:'+'eug'+'en'+'.wi'+'nt'+'ers'+'be'+'rge'+'r@'+'des'+'y.'+'de'; return false;">eugen<span style="display: none;">.nosp@m.</span>.win<span style="display: none;">.nosp@m.</span>tersb<span style="display: none;">.nosp@m.</span>erge<span style="display: none;">.nosp@m.</span>r@des<span style="display: none;">.nosp@m.</span>y.de</a> /</p>
<p>(c) Copyright 2013 DESY, Eugen Wintersberger <a href="#" onclick="location.href='mai'+'lto:'+'eug'+'en'+'.wi'+'nt'+'ers'+'be'+'rge'+'r@'+'des'+'y.'+'de'; return false;">eugen<span style="display: none;">.nosp@m.</span>.win<span style="display: none;">.nosp@m.</span>tersb<span style="display: none;">.nosp@m.</span>erge<span style="display: none;">.nosp@m.</span>r@des<span style="display: none;">.nosp@m.</span>y.de</a></p>
<p>This file is part of libpninexus.</p>
<p>libpninexus is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 2 of the License, or (at your option) any later version.</p>
<p>libpninexus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with libpninexus. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<hr  />
<p>Created on: Oct 22, 2013 Author: Eugen Wintersberger <a href="#" onclick="location.href='mai'+'lto:'+'eug'+'en'+'.wi'+'nt'+'ers'+'be'+'rge'+'r@'+'des'+'y.'+'de'; return false;">eugen<span style="display: none;">.nosp@m.</span>.win<span style="display: none;">.nosp@m.</span>tersb<span style="display: none;">.nosp@m.</span>erge<span style="display: none;">.nosp@m.</span>r@des<span style="display: none;">.nosp@m.</span>y.de</a></p>
<p>(c) Copyright 2013 DESY, Eugen Wintersberger <a href="#" onclick="location.href='mai'+'lto:'+'eug'+'en'+'.wi'+'nt'+'ers'+'be'+'rge'+'r@'+'des'+'y.'+'de'; return false;">eugen<span style="display: none;">.nosp@m.</span>.win<span style="display: none;">.nosp@m.</span>tersb<span style="display: none;">.nosp@m.</span>erge<span style="display: none;">.nosp@m.</span>r@des<span style="display: none;">.nosp@m.</span>y.de</a></p>
<p>This file is part of libpninexus.</p>
<p>libpninexus is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 2 of the License, or (at your option) any later version.</p>
<p>libpninexus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with libpninexus. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<hr  />
<p>Created on: Oct 25, 2013 Author: Eugen Wintersberger <a href="#" onclick="location.href='mai'+'lto:'+'eug'+'en'+'.wi'+'nt'+'ers'+'be'+'rge'+'r@'+'des'+'y.'+'de'; return false;">eugen<span style="display: none;">.nosp@m.</span>.win<span style="display: none;">.nosp@m.</span>tersb<span style="display: none;">.nosp@m.</span>erge<span style="display: none;">.nosp@m.</span>r@des<span style="display: none;">.nosp@m.</span>y.de</a> </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a471ed8f87fcfdf66db099a21b5e6d7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471ed8f87fcfdf66db099a21b5e6d7cc">&#9670;&nbsp;</a></span>checked_type_vectors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::mpl::map&lt; boost::mpl::pair&lt;<a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>,boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>,<a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>,<a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>,<a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>, <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>,<a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>,<a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>,<a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>,<a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>, <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>,<a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>,<a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>,<a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>,<a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>,<a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>,<a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>,<a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>,<a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>,<a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>,<a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>,<a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>,<a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>,<a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>,<a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>,<a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>,<a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>,<a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>,<a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>,<a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>&gt; &gt;, boost::mpl::pair&lt;<a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>,boost::mpl::vector&lt;&gt; &gt;, boost::mpl::pair&lt;<a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>,boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>,<a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>&gt; &gt;, boost::mpl::pair&lt;<a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>,boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>,<a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>,<a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>&gt; &gt;, boost::mpl::pair&lt;<a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>,boost::mpl::vector&lt;&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>&gt; &gt;, boost::mpl::pair&lt;<a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>,boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>,<a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>&gt; &gt;, boost::mpl::pair&lt;<a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">string</a>,boost::mpl::vector&lt;&gt; &gt;, boost::mpl::pair&lt;<a class="el" href="group__type__classes.html#gab80fde605a35ad90da1651d7d3c67893">binary</a>,boost::mpl::vector&lt;&gt; &gt;, boost::mpl::pair&lt;hdf5::datatype::EBool,boost::mpl::vector&lt;&gt; &gt;, boost::mpl::pair&lt;<a class="el" href="classpni_1_1bool__t.html">bool_t</a>,boost::mpl::vector&lt;&gt; &gt; &gt; <a class="el" href="namespacepni.html#a471ed8f87fcfdf66db099a21b5e6d7cc">pni::checked_type_vectors</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This map provides for each type a list of types to which this type can be converted only with range checking. <br  />
 </p>

</div>
</div>
<a id="adfa0215db65153bfad1d6e8ea655bf4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa0215db65153bfad1d6e8ea655bf4c">&#9670;&nbsp;</a></span>dynamic_array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#adfa0215db65153bfad1d6e8ea655bf4c">pni::dynamic_array</a> = typedef <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt;std::vector&lt;ElementT&gt;,<a class="el" href="namespacepni.html#ace3faaeeab1697a73b1c67aa3207b7a5">dynamic_cindex_map</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This template creates a fully dynamic array type. Its rank as well as its number of elements along each dimension (the shape) can be created dynamically. Use this type if all decisions have to be made at runtime.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> dynamic_array&lt;float64&gt; array_type; </div>
<div class="line"> </div>
<div class="line">array_type a = ...;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ElementT</td><td>element type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace3faaeeab1697a73b1c67aa3207b7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3faaeeab1697a73b1c67aa3207b7a5">&#9670;&nbsp;</a></span>dynamic_cindex_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpni_1_1index__map.html">index_map</a>&lt;std::vector&lt;size_t&gt;,<a class="el" href="classpni_1_1c__index__map__imp.html">c_index_map_imp</a>&gt; <a class="el" href="namespacepni.html#ace3faaeeab1697a73b1c67aa3207b7a5">pni::dynamic_cindex_map</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type definition of a fully dynamic C index map. The structure of the map can be fully determined at runtime. The structure of an array. </p>

</div>
</div>
<a id="a2d92927e138276c273cdc7e98c6f09bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d92927e138276c273cdc7e98c6f09bb">&#9670;&nbsp;</a></span>enable_element_cont</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#a2d92927e138276c273cdc7e98c6f09bb">pni::enable_element_cont</a> = typedef std::enable_if&lt;!<a class="el" href="structpni_1_1is__index__type.html">is_index_type</a>&lt;ContainerT&gt;::<a class="el" href="classpni_1_1value.html">value</a> &amp;&amp; !<a class="el" href="structpni_1_1is__view__cont.html">is_view_cont</a>&lt;ContainerT&gt;::<a class="el" href="classpni_1_1value.html">value</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec9ea31f62e69214bab4247566bc40b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9ea31f62e69214bab4247566bc40b3">&#9670;&nbsp;</a></span>enable_if</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeneralT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#aec9ea31f62e69214bab4247566bc40b3">pni::enable_if</a> = typedef <a class="el" href="namespacepni.html#aaf5ed7f9b2316a8c64ff063f59271574">invoke</a>&lt;std::enable_if&lt;GeneralT::value&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f21710a0fe72bfafff2547b716f0cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f21710a0fe72bfafff2547b716f0cba">&#9670;&nbsp;</a></span>enable_valid_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... IndicesT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#a9f21710a0fe72bfafff2547b716f0cba">pni::enable_valid_index</a> = typedef std::enable_if&lt;<a class="el" href="structpni_1_1is__index__types.html">is_index_types</a>&lt;IndicesT...&gt;::<a class="el" href="classpni_1_1value.html">value</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaecfeacffc28b66bbbdd7e27af38113b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaecfeacffc28b66bbbdd7e27af38113b">&#9670;&nbsp;</a></span>enable_view_cont</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#aaecfeacffc28b66bbbdd7e27af38113b">pni::enable_view_cont</a> = typedef std::enable_if&lt;!<a class="el" href="structpni_1_1is__index__type.html">is_index_type</a>&lt;ContainerT&gt;::<a class="el" href="classpni_1_1value.html">value</a> &amp;&amp; <a class="el" href="structpni_1_1is__view__cont.html">is_view_cont</a>&lt;ContainerT&gt;::<a class="el" href="classpni_1_1value.html">value</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f3aea22461538ee4d1f82521b4959c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3aea22461538ee4d1f82521b4959c3">&#9670;&nbsp;</a></span>fixed_dim_array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t TDimN&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#a1f3aea22461538ee4d1f82521b4959c3">pni::fixed_dim_array</a> = typedef <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt;std::vector&lt;ElementT&gt;,<a class="el" href="namespacepni.html#a7ce756fde1af52ab903eb6791b25953f">fixed_dim_cindex_map</a>&lt;TDimN&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This array template fixes the number of dimensions for an array type at compile time. It will be the appropriate type for most applications. The following code defines an image type (we know that images have always 2 dimensions):</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> fixed_dim_array&lt;uint32,2&gt; image_type;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ElementT</td><td>element data type </td></tr>
    <tr><td class="paramname">TDimN</td><td>number of dimensions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ce756fde1af52ab903eb6791b25953f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce756fde1af52ab903eb6791b25953f">&#9670;&nbsp;</a></span>fixed_dim_cindex_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t TDimN&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#a7ce756fde1af52ab903eb6791b25953f">pni::fixed_dim_cindex_map</a> = typedef <a class="el" href="classpni_1_1index__map.html">index_map</a>&lt;std::array&lt;size_t,TDimN&gt;,<a class="el" href="classpni_1_1c__index__map__imp.html">c_index_map_imp</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For such a map the number of elements along each dimension can be changed, however the total size (rank) of the map cannot be changed once the concrete type has been defined.</p>
<p>A typical example would be to define a map for an image which has always a rank of 2 like this</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> fixed_dim_cindex_map&lt;2&gt; image_map; </div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDimN</td><td>number of dimensions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf5ed7f9b2316a8c64ff063f59271574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5ed7f9b2316a8c64ff063f59271574">&#9670;&nbsp;</a></span>invoke</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetafunctionT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#aaf5ed7f9b2316a8c64ff063f59271574">pni::invoke</a> = typedef typename MetafunctionT::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Metafunction to retrieve the result type of another metafunction.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MetafunctionT</td><td>metafunction type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bf6c4315f702282de1f3d497da35bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf6c4315f702282de1f3d497da35bdc">&#9670;&nbsp;</a></span>ipa_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeneralT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">pni::ipa_type</a> = typedef typename GeneralT::inplace_arithmetic</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55b31ab9efef75d51b135757e7f80f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b31ab9efef75d51b135757e7f80f74">&#9670;&nbsp;</a></span>is_cmplx</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeneralT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#a55b31ab9efef75d51b135757e7f80f74">pni::is_cmplx</a> = typedef <a class="el" href="structpni_1_1is__complex__type.html">is_complex_type</a>&lt;GeneralT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb2fe59951e962490d8ba70db87bccb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2fe59951e962490d8ba70db87bccb4">&#9670;&nbsp;</a></span>is_pod</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeneralT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#aeb2fe59951e962490d8ba70db87bccb4">pni::is_pod</a> = typedef std::is_pod&lt;GeneralT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d78931b0153c505233cf06f62a77958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d78931b0153c505233cf06f62a77958">&#9670;&nbsp;</a></span>is_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeneralT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#a3d78931b0153c505233cf06f62a77958">pni::is_ptr</a> = typedef std::is_pointer&lt;GeneralT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5cc1016cb8fd406cb452d43404b3d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cc1016cb8fd406cb452d43404b3d92">&#9670;&nbsp;</a></span>map_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeneralT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">pni::map_type</a> = typedef typename GeneralT::map_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e71c9ac38fabb17416cef2f0e1b3d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e71c9ac38fabb17416cef2f0e1b3d33">&#9670;&nbsp;</a></span>ref_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeneralT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#a3e71c9ac38fabb17416cef2f0e1b3d33">pni::ref_type</a> = typedef std::reference_wrapper&lt;GeneralT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple alias for the std::reference_wrapper template to reduce typing work.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GeneralT</td><td>type of the reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b5c35e86d7bd211daf1b949d3e3fc8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5c35e86d7bd211daf1b949d3e3fc8e">&#9670;&nbsp;</a></span>shape_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;size_t&gt; <a class="el" href="namespacepni.html#a5b5c35e86d7bd211daf1b949d3e3fc8e">pni::shape_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb4d2e0269b02f54bd50ef1524bbd5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4d2e0269b02f54bd50ef1524bbd5ce">&#9670;&nbsp;</a></span>shape_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;size_t&gt; <a class="el" href="namespacepni.html#aeb4d2e0269b02f54bd50ef1524bbd5ce">pni::shape_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7e1a86e625a986d556f76ccdfc64c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e1a86e625a986d556f76ccdfc64c39">&#9670;&nbsp;</a></span>static_array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t... TDimsN&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#ab7e1a86e625a986d556f76ccdfc64c39">pni::static_array</a> = typedef <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt;std::array&lt;ElementT,boost::mpl::times&lt; boost::mpl::size_t&lt;1&gt;, boost::mpl::size_t&lt;TDimsN&gt;... &gt;::<a class="el" href="classpni_1_1value.html">value</a> &gt;, <a class="el" href="namespacepni.html#a1c1a82e22b12383c82b3999ea22ee743">static_cindex_map</a>&lt;TDimsN...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This template can be used for static array types. These are types where the number of dimensions as well as the total number of elements along each dimension are known at compile time. A typical application would be matrices and vectors for 3D operations.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> static_array&lt;float64,3&gt; vector_type;</div>
<div class="line"><span class="keyword">typedef</span> static_array&lt;float64,3,3&gt; matrix_type; </div>
<div class="line"><span class="keyword">typedef</span> static_array&lt;float64,6,6&gt; elasticity_tensor;</div>
</div><!-- fragment --><p>Instances of such types usually reside on the stack which makes access to their data elements extremely fast.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ElementT</td><td>element data type </td></tr>
    <tr><td class="paramname">TDimsN</td><td>number of elements along each dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c1a82e22b12383c82b3999ea22ee743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1a82e22b12383c82b3999ea22ee743">&#9670;&nbsp;</a></span>static_cindex_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t... TDimsN&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#a1c1a82e22b12383c82b3999ea22ee743">pni::static_cindex_map</a> = typedef <a class="el" href="classpni_1_1static__index__map.html">static_index_map</a>&lt;<a class="el" href="classpni_1_1c__index__map__imp.html">c_index_map_imp</a>,TDimsN...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A template alias for a static index map with c ordering. To define the index map for a 3x3 matrix use something like this</p>
<div class="fragment"><div class="line">static_cindex_map&lt;3,3&gt; matrix_map; </div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDimsN</td><td>number of elements along each dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08ee4ed2a773d68844b7d9d68fc94066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ee4ed2a773d68844b7d9d68fc94066">&#9670;&nbsp;</a></span>strategy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT , typename SourceT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#a08ee4ed2a773d68844b7d9d68fc94066">pni::strategy</a> = typedef <a class="el" href="structpni_1_1value__converter.html">value_converter</a>&lt;TargetT,SourceT,<a class="el" href="structpni_1_1convertible.html">convertible</a>&lt;SourceT,TargetT&gt;::<a class="el" href="classpni_1_1value.html">value</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92a619e389a5e7f8600cf10857da88db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a619e389a5e7f8600cf10857da88db">&#9670;&nbsp;</a></span>type_id_vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>&gt; <a class="el" href="namespacepni.html#a92a619e389a5e7f8600cf10857da88db">pni::type_id_vector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42d0bf11cc81f22d64c89a44a5143858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d0bf11cc81f22d64c89a44a5143858">&#9670;&nbsp;</a></span>unchecked_type_vectors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::mpl::map&lt; boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">uint8</a>,<a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>,<a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>,<a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, <a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>,<a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>,<a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>,<a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>,<a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>,<a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>,<a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">uint16</a>,<a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>,<a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, <a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>,<a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>,<a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>,<a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>,<a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>,<a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">uint32</a>,<a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, <a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>,<a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>,<a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>,<a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>,<a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">uint64</a>, <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>,<a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>,<a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>,<a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>,<a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">int8</a>,<a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>,<a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>,<a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>,<a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>,<a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>,<a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>,<a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">int16</a>,<a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>,<a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>,<a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>,<a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>,<a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>,<a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">int32</a>,<a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>,<a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>,<a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>,<a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>,<a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">int64</a>, <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>,<a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>,<a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>,<a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>,<a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a>,<a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>,<a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>, <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>,<a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>,<a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a>,<a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>,<a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>&gt; &gt;, boost::mpl::pair&lt;<a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>,boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">float128</a>,<a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a>,<a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>,<a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>&gt; &gt;, boost::mpl::pair&lt; <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>, boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a>,<a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>&gt; &gt;, boost::mpl::pair&lt;<a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>,boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a>&gt; &gt;, boost::mpl::pair&lt;<a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">string</a>,boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">string</a>&gt; &gt;, boost::mpl::pair&lt;<a class="el" href="classpni_1_1bool__t.html">bool_t</a>,boost::mpl::vector&lt;<a class="el" href="classpni_1_1bool__t.html">bool_t</a>,hdf5::datatype::EBool&gt; &gt;, boost::mpl::pair&lt;hdf5::datatype::EBool,boost::mpl::vector&lt;<a class="el" href="classpni_1_1bool__t.html">bool_t</a>,hdf5::datatype::EBool&gt; &gt;, boost::mpl::pair&lt;<a class="el" href="group__type__classes.html#gab80fde605a35ad90da1651d7d3c67893">binary</a>,boost::mpl::vector&lt;<a class="el" href="group__type__classes.html#gab80fde605a35ad90da1651d7d3c67893">binary</a>&gt; &gt; &gt; <a class="el" href="namespacepni.html#a42d0bf11cc81f22d64c89a44a5143858">pni::unchecked_type_vectors</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This map provides for each type a list of types to which this type can be converted without range checking. <br  />
 </p>

</div>
</div>
<a id="ab2add101c915d69fa25c2910e928ec64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2add101c915d69fa25c2910e928ec64">&#9670;&nbsp;</a></span>view_type_trait</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT , typename ... IndicesT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepni.html#ab2add101c915d69fa25c2910e928ec64">pni::view_type_trait</a> = typedef <a class="el" href="structpni_1_1array__view__trait.html">array_view_trait</a>&lt;ArrayT, <a class="el" href="structpni_1_1is__view__index.html">is_view_index</a>&lt;IndicesT...&gt;::<a class="el" href="classpni_1_1value.html">value</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8fc25815126216a8c42fc75ddc8483fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc25815126216a8c42fc75ddc8483fe">&#9670;&nbsp;</a></span>build_type_id_container()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename SourceT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ContainerT pni::build_type_id_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf0875f5e5b799f33e3cf6b2ef1d8417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0875f5e5b799f33e3cf6b2ef1d8417">&#9670;&nbsp;</a></span>check_allocation_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pni::check_allocation_state </td>
          <td>(</td>
          <td class="paramtype">const ObjectT &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1exception__record.html">exception_record</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the allocation state of an allocateable object. If the object is not allocated an exception will be thrown. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1memory__not__allocated__error.html" title="memory not allocated error">memory_not_allocated_error</a></td><td>if object not allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>object to check </td></tr>
    <tr><td class="paramname">i</td><td><a class="el" href="classpni_1_1exception__record.html" title="exception record">exception_record</a> for the location where to perform the check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94bc969854c439e9ddf712e98ca50238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bc969854c439e9ddf712e98ca50238">&#9670;&nbsp;</a></span>check_equal_rank() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerAT , typename ContainerBT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pni::check_equal_rank </td>
          <td>(</td>
          <td class="paramtype">const ContainerAT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerBT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true of the two array like objects have an equal number of dimensions. In any other case return false.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerAT</td><td>first array type </td></tr>
    <tr><td class="paramname">ContainerBT</td><td>second array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>reference to an instance of ContainerAT </td></tr>
    <tr><td class="paramname">b</td><td>reference to an instance of ContainerBT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a and b have equal rank, false otherwise </dd></dl>

</div>
</div>
<a id="a57cc23d08b1ad5571daef5dc987f6a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cc23d08b1ad5571daef5dc987f6a8c">&#9670;&nbsp;</a></span>check_equal_rank() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerAT , typename ContainerBT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pni::check_equal_rank </td>
          <td>(</td>
          <td class="paramtype">const ContainerAT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerBT &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1exception__record.html">exception_record</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Throwing version of check_equal_rank.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1shape__mismatch__error.html" title="Shape mismatch error.">shape_mismatch_error</a></td><td>if a and b have different rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerAT</td><td>first array type </td></tr>
    <tr><td class="paramname">ContainerBT</td><td>second array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>reference to an instance of ContainerAT </td></tr>
    <tr><td class="paramname">b</td><td>reference to an instance of ContainerBT </td></tr>
    <tr><td class="paramname">i</td><td>exception record of the calling function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3edd1259ff909d680f6a3972da3c1e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3edd1259ff909d680f6a3972da3c1e73">&#9670;&nbsp;</a></span>check_equal_shape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerAT , typename ContainerBT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pni::check_equal_shape </td>
          <td>(</td>
          <td class="paramtype">const ContainerAT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerBT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98f9c4c9ac7aee46df3850d7799d205d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f9c4c9ac7aee46df3850d7799d205d">&#9670;&nbsp;</a></span>check_equal_shape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerAT , typename ContainerBT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pni::check_equal_shape </td>
          <td>(</td>
          <td class="paramtype">const ContainerAT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerBT &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1exception__record.html">exception_record</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if two Shape objects are equal and throws an exception if they are not.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerAT</td><td>container type for the first shape </td></tr>
    <tr><td class="paramname">ContainerBT</td><td>container type for the second shape </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1size__mismatch__error.html" title="Size mismatch error.">size_mismatch_error</a></td><td>if array sizes do not match </td></tr>
    <tr><td class="paramname"><a class="el" href="classpni_1_1shape__mismatch__error.html" title="Shape mismatch error.">shape_mismatch_error</a></td><td>if shapes do not match </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first shape </td></tr>
    <tr><td class="paramname">b</td><td>second shape </td></tr>
    <tr><td class="paramname">i</td><td><a class="el" href="classpni_1_1exception__record.html" title="exception record">exception_record</a> for the location where to perform the check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49f2d0ee91d2c32f6c2f91812ed3cfd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f2d0ee91d2c32f6c2f91812ed3cfd1">&#9670;&nbsp;</a></span>check_equal_size() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerAT , typename ContainerBT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pni::check_equal_size </td>
          <td>(</td>
          <td class="paramtype">const ContainerAT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerBT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This helper function checks if two container instances have equal size and returns true if this is the case. Otherwise false will be returned. Both container types have to provide a <a class="el" href="namespacepni.html#ab20a3d8d51f1c5aee26a971b5fe2cf65" title="compute slice size">size()</a> method returning the number of elements the container can hold.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerAT</td><td>first container type </td></tr>
    <tr><td class="paramname">ContainerBT</td><td>second container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>reference to an instance of ContainerAT </td></tr>
    <tr><td class="paramname">b</td><td>reference to an instance of ContainerBT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a and b have same size, false otherwise </dd></dl>

</div>
</div>
<a id="a4cf4ebfd00fbbd8e435e32cc61761c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf4ebfd00fbbd8e435e32cc61761c15">&#9670;&nbsp;</a></span>check_equal_size() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerAT , typename ContainerBT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pni::check_equal_size </td>
          <td>(</td>
          <td class="paramtype">const ContainerAT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerBT &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1exception__record.html">exception_record</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This utilty function can be used to check for the equality of the size of two objects. It is typically used to compare the size of a shape and a buffer or any other container object. If the sizes do not match an exception is thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1size__mismatch__error.html" title="Size mismatch error.">size_mismatch_error</a></td><td>if sizes do not match </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerAT</td><td>first container type </td></tr>
    <tr><td class="paramname">ContainerBT</td><td>second container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>instance of container type ContainerAT </td></tr>
    <tr><td class="paramname">b</td><td>instance of container type ContainerBT </td></tr>
    <tr><td class="paramname">i</td><td><a class="el" href="classpni_1_1exception__record.html" title="exception record">exception_record</a> for the location where to perform the check performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8794c4afa1ff0af09f207a23a3c3cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8794c4afa1ff0af09f207a23a3c3cdd">&#9670;&nbsp;</a></span>check_equal_size() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ... ContainersT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pni::check_equal_size </td>
          <td>(</td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainersT &amp;...&#160;</td>
          <td class="paramname"><em>cs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This variadic function compares the sizes of all the containers passed its arguments. If they are all equal true is returend, false otherwise.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> ... vector_type;</div>
<div class="line"><span class="keyword">typedef</span> ... list_type;</div>
<div class="line"><span class="keyword">typedef</span> std::vector&lt;size_t,10&gt; array_type;</div>
<div class="line"> </div>
<div class="line">vector_type v1(100);</div>
<div class="line">list_type   l1(100);</div>
<div class="line">array_type  a1;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespacepni.html#a49f2d0ee91d2c32f6c2f91812ed3cfd1">check_equal_size</a>(v1,l1); <span class="comment">//returns true</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespacepni.html#a49f2d0ee91d2c32f6c2f91812ed3cfd1">check_equal_size</a>(v1,l1,a1); <span class="comment">//returns false</span></div>
<div class="ttc" id="anamespacepni_html_a49f2d0ee91d2c32f6c2f91812ed3cfd1"><div class="ttname"><a href="namespacepni.html#a49f2d0ee91d2c32f6c2f91812ed3cfd1">pni::check_equal_size</a></div><div class="ttdeci">bool check_equal_size(const ContainerAT &amp;a, const ContainerBT &amp;b)</div><div class="ttdoc">check if two container have equal size</div><div class="ttdef"><b>Definition:</b> exception_utils.hpp:79</div></div>
</div><!-- fragment --><p> ! </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>container type of first argument </td></tr>
    <tr><td class="paramname">ContainersT</td><td>residual arguments types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>first container instance </td></tr>
    <tr><td class="paramname">cs</td><td>residual containers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all of samme size, false otherwise </dd></dl>

</div>
</div>
<a id="a1fb0b46606d1afcfdeda8b2929b6e656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb0b46606d1afcfdeda8b2929b6e656">&#9670;&nbsp;</a></span>check_index_in_dim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::check_index_in_dim </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if an index resides within a dimension range. The index must be than the size of the dimension. If the index is within the dimension size true is returned. false otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index to check </td></tr>
    <tr><td class="paramname">dimsize</td><td>size of the dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if index&lt;dimsize, flase otherwise </dd></dl>

</div>
</div>
<a id="a86b92369cc3430b7cc8658dc8f7fb8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b92369cc3430b7cc8658dc8f7fb8ae">&#9670;&nbsp;</a></span>check_index_in_dim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::check_index_in_dim </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1exception__record.html">exception_record</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Throwing version of check_index_in_dim. Throws an <a class="el" href="classpni_1_1index__error.html" title="index error">index_error</a> exception if the index is not within the dimension range.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1index__error.html" title="index error">index_error</a></td><td>if i exceeds dimsize </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>actual index </td></tr>
    <tr><td class="paramname">dimsize</td><td>dimension size </td></tr>
    <tr><td class="paramname">i</td><td><a class="el" href="classpni_1_1exception__record.html" title="exception record">exception_record</a> for the location where to perform the check performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32c69a33d887b2c551764c28e4cf0df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c69a33d887b2c551764c28e4cf0df8">&#9670;&nbsp;</a></span>check_indexes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexT , typename ShapeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pni::check_indexes </td>
          <td>(</td>
          <td class="paramtype">const IndexT &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ShapeT &amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if all index values stored in a container do not exceed their dimensions limits.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexT</td><td>index container type </td></tr>
    <tr><td class="paramname">ShapeT</td><td>shape container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>reference to an index container </td></tr>
    <tr><td class="paramname">shape</td><td>reference to a shape container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all indexes are in their bounds </dd></dl>

</div>
</div>
<a id="a051b69e98fd06ec2abb6aecf5dd9372a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051b69e98fd06ec2abb6aecf5dd9372a">&#9670;&nbsp;</a></span>check_indexes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexT , typename ShapeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pni::check_indexes </td>
          <td>(</td>
          <td class="paramtype">const IndexT &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ShapeT &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1exception__record.html">exception_record</a> &amp;&#160;</td>
          <td class="paramname"><em>record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if all indexes stored in a container lie within a given range determined by the shape. In addition the function checks if the number of indexes matches the number of elements in the shape.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1index__error.html" title="index error">index_error</a></td><td>if one of the indexes exceeds the number of elements in its dimension </td></tr>
    <tr><td class="paramname"><a class="el" href="classpni_1_1shape__mismatch__error.html" title="Shape mismatch error.">shape_mismatch_error</a></td><td>if the number of indexes does not match the number of dimensions (elements in the shape) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexT</td><td>index container type </td></tr>
    <tr><td class="paramname">ShapeT</td><td>shape container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>container with index data </td></tr>
    <tr><td class="paramname">shape</td><td>container with shape data </td></tr>
    <tr><td class="paramname">record</td><td>the exception record of the calling function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb904fc49062ce691c85cf691d36d020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb904fc49062ce691c85cf691d36d020">&#9670;&nbsp;</a></span>check_ptr_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeneralT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pni::check_ptr_state </td>
          <td>(</td>
          <td class="paramtype">const GeneralT *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1exception__record.html">exception_record</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a pointer is nullptr or not and throws an exception if it is. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1memory__not__allocated__error.html" title="memory not allocated error">memory_not_allocated_error</a></td><td>if pointer is a nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to check </td></tr>
    <tr><td class="paramname">i</td><td><a class="el" href="classpni_1_1exception__record.html" title="exception record">exception_record</a> for the location where to perform the check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76b2cf61bdb829876ee6720acf183a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b2cf61bdb829876ee6720acf183a9c">&#9670;&nbsp;</a></span>check_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ShapeT , typename ContainerT , typename ... ContainersT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pni::check_size </td>
          <td>(</td>
          <td class="paramtype">ShapeT&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainersT &amp;...&#160;</td>
          <td class="paramname"><em>cs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="addb022f9ad595b350b2cfd80da9ec140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb022f9ad595b350b2cfd80da9ec140">&#9670;&nbsp;</a></span>check_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ShapeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pni::check_size </td>
          <td>(</td>
          <td class="paramtype">ShapeT&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab2d54fea440036b011cb36507d021bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2d54fea440036b011cb36507d021bf">&#9670;&nbsp;</a></span>clip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pni::clip </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ArrayT::value_type&#160;</td>
          <td class="paramname"><em>minth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ArrayT::value_type&#160;</td>
          <td class="paramname"><em>maxth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt;&gt;</p>
<p>Set values greater or equal maxth to maxth and those smaller or equal minth to minth. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>array which to clip </td></tr>
    <tr><td class="paramname">minth</td><td>minimum threshold </td></tr>
    <tr><td class="paramname">maxth</td><td>maximum threshold </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8eed1f1233d443621d7b9990651cf14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eed1f1233d443621d7b9990651cf14c">&#9670;&nbsp;</a></span>clip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pni::clip </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ArrayT::value_type&#160;</td>
          <td class="paramname"><em>minth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ArrayT::value_type&#160;</td>
          <td class="paramname"><em>maxth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ArrayT::value_type&#160;</td>
          <td class="paramname"><em>minval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ArrayT::value_type&#160;</td>
          <td class="paramname"><em>maxval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt;&gt;</p>
<p>Set values greater or equal maxth to maxval and those smaller or equal minth to minval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>array which to clip </td></tr>
    <tr><td class="paramname">minth</td><td>minimum threshold </td></tr>
    <tr><td class="paramname">maxth</td><td>maximum threshold </td></tr>
    <tr><td class="paramname">minval</td><td>value to which values small minth will be set </td></tr>
    <tr><td class="paramname">maxval</td><td>value to which values larger maxth will be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f4fc50e24b34c39cd5e5bc0eab4ec58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4fc50e24b34c39cd5e5bc0eab4ec58">&#9670;&nbsp;</a></span>convert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT , typename SourceT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TargetT pni::convert </td>
          <td>(</td>
          <td class="paramtype">const SourceT &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function template finally performs the type conversion. Several static asserts are performed which ensure the two cases of conversions will not even compile: conversion from a floating point number of an integer value and conversion from a complex value to a non-complex type.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1range__error.html" title="data range error">range_error</a></td><td>if u does not fit in the range covered by T </td></tr>
    <tr><td class="paramname"><a class="el" href="classpni_1_1type__error.html" title="data type error">type_error</a></td><td>in case of all other errors</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TargetT</td><td>target type </td></tr>
    <tr><td class="paramname">S</td><td>source type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>value of type S </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of u converted to TargetT </dd></dl>

</div>
</div>
<a id="a6bb6ed847d7d937a5a61516dff59cc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb6ed847d7d937a5a61516dff59cc15">&#9670;&nbsp;</a></span>default_complex_regexp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const boost::regex pni::default_complex_regexp </td>
          <td>(</td>
          <td class="paramtype">&quot;^(?&lt;REALPART&gt;[+-]?\\d+\\.(\\d+)?([Ee][+-]?\\d+)?)?((?&lt;IMAGSIGN&gt;[+-]?[ijI])(?&lt;IMAGPART&gt;[+-]?\\d+\\.(\\d+)?([Ee][+-]?\\d+)?)?)?$&quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14203ed7eaa2d44db5e56080413e47e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14203ed7eaa2d44db5e56080413e47e6">&#9670;&nbsp;</a></span>default_float_regexp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const boost::regex pni::default_float_regexp </td>
          <td>(</td>
          <td class="paramtype">&quot;^?\\d+\\.(\\d+)?([Ee][+-]?\\d+)?$&quot;&#160;</td>
          <td class="paramname">[+-]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81ad0a8f6bef62f6b08654a35a049d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ad0a8f6bef62f6b08654a35a049d06">&#9670;&nbsp;</a></span>default_int_regexp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const boost::regex pni::default_int_regexp </td>
          <td>(</td>
          <td class="paramtype">&quot;^?\\d+$&quot;&#160;</td>
          <td class="paramname">[+-]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e64b53287aed6f0911f031f5a7ee6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e64b53287aed6f0911f031f5a7ee6ad">&#9670;&nbsp;</a></span>format() <span class="overload">[1/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const hdf5::datatype::EBool &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57b360f7e07437ecde5a88bea7fa08f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b360f7e07437ecde5a88bea7fa08f0">&#9670;&nbsp;</a></span>format() <span class="overload">[2/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array.html">pni::array</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1container__io__config.html">container_io_config</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="classpni_1_1container__io__config.html">container_io_config</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="accf773f9ac4d4dd75519d24cc671e7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf773f9ac4d4dd75519d24cc671e7aa">&#9670;&nbsp;</a></span>format() <span class="overload">[3/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1bool__t.html">pni::bool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd2ce510a0af79530d873e356be05d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2ce510a0af79530d873e356be05d11">&#9670;&nbsp;</a></span>format() <span class="overload">[4/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">pni::complex128</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb28578c5c5b99f35b9e65f5884f1bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb28578c5c5b99f35b9e65f5884f1bf6">&#9670;&nbsp;</a></span>format() <span class="overload">[5/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">pni::complex32</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7e5fd864fb8e8d1262bebf7016ee34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e5fd864fb8e8d1262bebf7016ee34e">&#9670;&nbsp;</a></span>format() <span class="overload">[6/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">pni::complex64</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3b1687bbfff73feef0f297d1aeac573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b1687bbfff73feef0f297d1aeac573">&#9670;&nbsp;</a></span>format() <span class="overload">[7/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga8196c51301aa89481579aa2486d34e28">pni::float128</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab68a7c09eb138e6490031cb0172f4d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68a7c09eb138e6490031cb0172f4d53">&#9670;&nbsp;</a></span>format() <span class="overload">[8/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">pni::float32</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdb633842f14923e37d90afdf684295e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb633842f14923e37d90afdf684295e">&#9670;&nbsp;</a></span>format() <span class="overload">[9/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">pni::float64</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a791b8ee244a27453e29ca5be78579281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791b8ee244a27453e29ca5be78579281">&#9670;&nbsp;</a></span>format() <span class="overload">[10/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gad97af124f0e4bca840c4b81c7c6f2bf9">pni::int16</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a283d7317b17f946531aa3013f400f1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283d7317b17f946531aa3013f400f1d3">&#9670;&nbsp;</a></span>format() <span class="overload">[11/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gadaecf8173ee4a475c2bff223970df70a">pni::int32</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ece436da3f8d78849b3d8ce0925909f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ece436da3f8d78849b3d8ce0925909f">&#9670;&nbsp;</a></span>format() <span class="overload">[12/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga92b286022d3b0449bce9604e3fda1041">pni::int64</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc53518c4bb1e8c44a7a3407ced0c7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc53518c4bb1e8c44a7a3407ced0c7db">&#9670;&nbsp;</a></span>format() <span class="overload">[13/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gadc41483281916729dac71199de27a884">pni::int8</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1601f7a91046c7b0af122e3b997bb1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1601f7a91046c7b0af122e3b997bb1ee">&#9670;&nbsp;</a></span>format() <span class="overload">[14/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... TemplateParametersT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1mdarray.html">pni::mdarray</a>&lt; TemplateParametersT... &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1container__io__config.html">container_io_config</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="classpni_1_1container__io__config.html">container_io_config</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization of the formatter template for instances of the mdarray template.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TemplateParametersT</td><td>template parameters for mdarray </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a23c1dd62664a34cc6f6cf1bf5b5697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a23c1dd62664a34cc6f6cf1bf5b5697">&#9670;&nbsp;</a></span>format() <span class="overload">[15/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c36a76f907d850dc263c5c49c9f7315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c36a76f907d850dc263c5c49c9f7315">&#9670;&nbsp;</a></span>format() <span class="overload">[16/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gaf02f3cfedbee1cd96303e05dfbd05071">pni::uint16</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc518e4f3ca7720c168fa85175b7826a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc518e4f3ca7720c168fa85175b7826a">&#9670;&nbsp;</a></span>format() <span class="overload">[17/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga10d54cdbcb0882e67496d0febe62a8f2">pni::uint32</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa180a9b08533dfec0d9ded47c6cefad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa180a9b08533dfec0d9ded47c6cefad7">&#9670;&nbsp;</a></span>format() <span class="overload">[18/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga06fcb67ea94591221414d48df372aa2b">pni::uint64</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad31f7649c43f7f966c750f61f63bba00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31f7649c43f7f966c750f61f63bba00">&#9670;&nbsp;</a></span>format() <span class="overload">[19/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gaa09dcc7c9c6d956f63dc58e69b63beef">pni::uint8</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afeef3e541391e2be4925f8be64dd5552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeef3e541391e2be4925f8be64dd5552">&#9670;&nbsp;</a></span>format() <span class="overload">[20/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1value.html">pni::value</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae999fe3d8becdd764a25a81b4e0beee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae999fe3d8becdd764a25a81b4e0beee">&#9670;&nbsp;</a></span>format() <span class="overload">[21/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> <a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1value__ref.html">pni::value_ref</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e45b03e5dae3c4070d990f3ff307e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e45b03e5dae3c4070d990f3ff307e17">&#9670;&nbsp;</a></span>format() <span class="overload">[22/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> pni::format </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; ElementT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1container__io__config.html">container_io_config</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="classpni_1_1container__io__config.html">container_io_config</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe5d083de7da82d07c903954e50a53b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5d083de7da82d07c903954e50a53b1">&#9670;&nbsp;</a></span>generate_map_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename MapT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>,<a class="el" href="namespacepni.html#a92a619e389a5e7f8600cf10857da88db">type_id_vector</a>&gt; pni::generate_map_element </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td>key type </td></tr>
    <tr><td class="paramname">MapT</td><td>MPL map type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a043017853e1d28b8dcad8dad17c6a4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043017853e1d28b8dcad8dad17c6a4d0">&#9670;&nbsp;</a></span>get_const_ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PrimitiveT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const PrimitiveT&amp; pni::get_const_ref </td>
          <td>(</td>
          <td class="paramtype">const PrimitiveT &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a const reference from a primitive type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PrimitiveT</td><td>primitive type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>const reference to the primitive type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const reference to PrimitiveT </dd></dl>

</div>
</div>
<a id="a10e26a795d616a8d98d4522f8cd0c841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e26a795d616a8d98d4522f8cd0c841">&#9670;&nbsp;</a></span>get_const_ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeneralT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const GeneralT&amp; pni::get_const_ref </td>
          <td>(</td>
          <td class="paramtype">const std::reference_wrapper&lt; GeneralT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a const reference stored in a std::reference_wrapper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type wrapped by std::reference_wrapper </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>const reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the argument </dd></dl>

</div>
</div>
<a id="a27667670141c64f3aa20e0280883c96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27667670141c64f3aa20e0280883c96f">&#9670;&nbsp;</a></span>get_holder_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , typename PointerT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1value__holder.html">value_holder</a>&lt;DataT&gt;* pni::get_holder_ptr </td>
          <td>(</td>
          <td class="paramtype">PointerT &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the pointer to a concrete value holder instance. The value class only stores a pointer to <a class="el" href="classpni_1_1value__holder__interface.html" title="abstract interface for data holder">value_holder_interface</a>. However, to retrieve typed data the pointer to the particular holder instance is required. This template function performs the cast based on the original data type T (which can be obtained from the type ID of the value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataT</td><td>erased data type </td></tr>
    <tr><td class="paramname">PointerT</td><td>interface pointer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>reference to the interface pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer of value_holder&lt;T&gt; type </dd></dl>

</div>
</div>
<a id="a2774930733701cd69776e8df3b36e025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2774930733701cd69776e8df3b36e025">&#9670;&nbsp;</a></span>get_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const void* pni::get_pointer </td>
          <td>(</td>
          <td class="paramtype">const ArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt;&gt;</p>
<p>Return a pointer to the data stored in an array. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayT</td><td>array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>instance of ArrayT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to array data </dd></dl>

</div>
</div>
<a id="abb98fd17978c46e9a143d5fc88539d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb98fd17978c46e9a143d5fc88539d6e">&#9670;&nbsp;</a></span>get_ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeneralT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GeneralT&amp; pni::get_ref </td>
          <td>(</td>
          <td class="paramtype">GeneralT &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the reference to its argument. This function template produces no code. It just passes the reference through.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GeneralT</td><td>type of the reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>input reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the argument </dd></dl>

</div>
</div>
<a id="a1eb512bdbdc0777543dafb35a1d1b7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb512bdbdc0777543dafb35a1d1b7f8">&#9670;&nbsp;</a></span>get_ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeneralT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GeneralT&amp; pni::get_ref </td>
          <td>(</td>
          <td class="paramtype">std::reference_wrapper&lt; GeneralT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the reference stored in a std::reference_wrapper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GeneralT</td><td>type wrapped by std::reference_wrapper </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>input reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the argument </dd></dl>

</div>
</div>
<a id="a8729e0dea6b27251d576cdb142107ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8729e0dea6b27251d576cdb142107ed2">&#9670;&nbsp;</a></span>get_type_id() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> pni::get_type_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gab80fde605a35ad90da1651d7d3c67893">binary</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloaded version of get_type_id for binary data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>binary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type ID for binary </dd></dl>

</div>
</div>
<a id="a61a8a832b647d5e03dfbffd5b0f6765e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a8a832b647d5e03dfbffd5b0f6765e">&#9670;&nbsp;</a></span>get_type_id() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> pni::get_type_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1bool__t.html">bool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>boolean data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>typeID for <a class="el" href="classpni_1_1bool__t.html" title="boolean type">bool_t</a> </dd></dl>

</div>
</div>
<a id="aab4ce480369576207d02b82b1c24de83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4ce480369576207d02b82b1c24de83">&#9670;&nbsp;</a></span>get_type_id() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeneralT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> pni::get_type_id </td>
          <td>(</td>
          <td class="paramtype">const GeneralT &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepni.html#aec9ea31f62e69214bab4247566bc40b3">enable_if</a>&lt; <a class="el" href="namespacepni.html#aeb2fe59951e962490d8ba70db87bccb4">is_pod</a>&lt; GeneralT &gt;&gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This version of get_type_id is used for POD (Plain Old Data).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GeneralT</td><td>data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type ID of GeneralT </dd></dl>

</div>
</div>
<a id="a67f3093cb5ed1984fce5369367c3566a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f3093cb5ed1984fce5369367c3566a">&#9670;&nbsp;</a></span>get_type_id() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeneralT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> pni::get_type_id </td>
          <td>(</td>
          <td class="paramtype">const GeneralT &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepni.html#aec9ea31f62e69214bab4247566bc40b3">enable_if</a>&lt; <a class="el" href="structpni_1_1not__t.html">not_t</a>&lt; <a class="el" href="namespacepni.html#aeb2fe59951e962490d8ba70db87bccb4">is_pod</a>&lt; GeneralT &gt;&gt;&gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In the case of continaer types get_type_id returns the type ID of of the value_type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GeneralT</td><td>container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type ID of GeneralT::value_type </dd></dl>

</div>
</div>
<a id="ac60567aab430d75f07d3f3e40c8e0880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60567aab430d75f07d3f3e40c8e0880">&#9670;&nbsp;</a></span>get_type_id() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> pni::get_type_id </td>
          <td>(</td>
          <td class="paramtype">const hdf5::datatype::EBool &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>boolean data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>typeID for EBool </dd></dl>

</div>
</div>
<a id="a65609eb7408d16944918eabc68b006b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65609eb7408d16944918eabc68b006b1">&#9670;&nbsp;</a></span>get_type_id() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeneralT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> pni::get_type_id </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; GeneralT &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloaded version of get_type_id for complex numbers.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GeneralT</td><td>base type for std::complex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type ID of the complex type </dd></dl>

</div>
</div>
<a id="a9024e2de3cbf10d6e4f40234a906ebf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9024e2de3cbf10d6e4f40234a906ebf5">&#9670;&nbsp;</a></span>get_type_id() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> pni::get_type_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">string</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloaded version of get_type_id for string data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>string data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type ID for string type </dd></dl>

</div>
</div>
<a id="ae77b7a4b02919abedfedcbc34852d421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77b7a4b02919abedfedcbc34852d421">&#9670;&nbsp;</a></span>get_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT , typename SourceT , typename PointerT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TargetT pni::get_value </td>
          <td>(</td>
          <td class="paramtype">PointerT&#160;</td>
          <td class="paramname"><em>holder_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value stored in a particular holder as an instance of a user requested type T.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1range__error.html" title="data range error">range_error</a></td><td>if the value stored in the holder does not fit in the range of the requested target type T </td></tr>
    <tr><td class="paramname"><a class="el" href="classpni_1_1type__error.html" title="data type error">type_error</a></td><td>in case of any other type related error</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TargetT</td><td>target type </td></tr>
    <tr><td class="paramname">SourceT</td><td>source type (the original type) </td></tr>
    <tr><td class="paramname">PointerT</td><td>holder pointer type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">holder_ptr</td><td>pointer to the original holder </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value as an instance of type T </dd></dl>

</div>
</div>
<a id="a8f4c4ec1983e57540216e8fa719641ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4c4ec1983e57540216e8fa719641ca">&#9670;&nbsp;</a></span>is_boolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pni::is_boolean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the input string could be interpreted as a single boolean value. If this is the case the function returns true, false otherwise. The function assumes that the input string is trimmed, meaning that all leading and trailing white-space charachters have been removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input string to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if boolean, false otherwise </dd></dl>

</div>
</div>
<a id="a0bdc4e511290381b5f055ced0b1ad1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bdc4e511290381b5f055ced0b1ad1a8">&#9670;&nbsp;</a></span>is_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pni::is_complex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the input string could be interpreted as a complex number. If this is the case the function returns true, false otherwise. The function assumes that the input string is trimmed, meaning that all leading and trailing white-space charachters have been removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input string to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if complex, false otherwise </dd></dl>

</div>
</div>
<a id="a50c13016075a9210809a9c8bf866b214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c13016075a9210809a9c8bf866b214">&#9670;&nbsp;</a></span>is_contiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pni::is_contiguous </td>
          <td>(</td>
          <td class="paramtype">const MapT &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array__selection.html">array_selection</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns true if a selection is continuous within a index map. A selection is considered as contiguous if the number of it spans in the original array is equal to the size of the selection.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MapT</td><td>index map type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>reference to the index mape </td></tr>
    <tr><td class="paramname">s</td><td>reerence to the selection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contiguous, false otherwise </dd></dl>

</div>
</div>
<a id="a58304836812dfc22cce1ff9cd28a6473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58304836812dfc22cce1ff9cd28a6473">&#9670;&nbsp;</a></span>is_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pni::is_float </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the input string could be interpreted as a single float number. If this is the case the function returns true, false otherwise. The function assumes that the input string is trimmed, meaning that all leading and trailing white-space charachters have been removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input string to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if float, false otherwise </dd></dl>

</div>
</div>
<a id="ad977e47244b515d817e30d88c14fcdb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad977e47244b515d817e30d88c14fcdb7">&#9670;&nbsp;</a></span>is_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pni::is_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the input string could be interpreted as a single integer number. If this is the case the function returns true, false otherwise. The function assumes that the input string is trimmed, meaning that all leading and trailing white-space charachters have been removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input string to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if integer, false otherwise </dd></dl>

</div>
</div>
<a id="adbcc330cc2ffdd2b7416307e40d7caa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcc330cc2ffdd2b7416307e40d7caa1">&#9670;&nbsp;</a></span>is_slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pni::is_slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gae86d1ac54b7b94227f4e32f2129bb534">pni::string</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the input string could be interpreted as a slice. If this is the case the function returns true, false otherwise. The function assumes that the input string is trimmed, meaning that all leading and trailing white-space charachters have been removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input string to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if slice, false otherwise </dd></dl>

</div>
</div>
<a id="a93b5f93cbfde86db957f65e220d84980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b5f93cbfde86db957f65e220d84980">&#9670;&nbsp;</a></span>last_offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t pni::last_offset </td>
          <td>(</td>
          <td class="paramtype">const MapT &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array__selection.html">array_selection</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the linear offset in the original array for the last element in a selection.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MapT</td><td>index map type of the original array </td></tr>
    <tr><td class="paramname">IndexT</td><td>index type of the array selection </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>reference to the original index map </td></tr>
    <tr><td class="paramname">s</td><td>reference to the selection object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>offset of the last element </dd></dl>

</div>
</div>
<a id="ac427a052c509018e0f067b7c9dd226d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac427a052c509018e0f067b7c9dd226d6">&#9670;&nbsp;</a></span>make_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , typename ShapeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1array.html">array</a> pni::make_array </td>
          <td>(</td>
          <td class="paramtype">const ShapeT &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an array of a particular shape and type. The type is determined at compile time via a template parameters. The underlying mdarray specialization is dynamic_array.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ElementT</td><td>data type of the elements </td></tr>
    <tr><td class="paramname">ShapeT</td><td>shape type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>number of elements along each dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>instance of array </dd></dl>

</div>
</div>
<a id="a2325f4650bec5fe449645a794567ce88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2325f4650bec5fe449645a794567ce88">&#9670;&nbsp;</a></span>make_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1array.html">array</a> pni::make_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an array of a particular type and shape. The type is determined by an argument and thus can be set at runtime.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1type__error.html" title="data type error">type_error</a></td><td>if the passed data type cannot be handled </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>container type for the shape </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tid</td><td>type id for the array </td></tr>
    <tr><td class="paramname">shape</td><td>number of elements along each dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>instance of array </dd></dl>

</div>
</div>
<a id="abf6f536120b44e60b2362e5c26837ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6f536120b44e60b2362e5c26837ba6">&#9670;&nbsp;</a></span>make_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RequestedT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1value.html">value</a> pni::make_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a value instance for a particular type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RequestedT</td><td>requested type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>instance of value holding a value of RequestedT </dd></dl>

</div>
</div>
<a id="a05f80e9a3461926f85c082425d23e34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f80e9a3461926f85c082425d23e34c">&#9670;&nbsp;</a></span>make_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="classpni_1_1value.html">value</a> pni::make_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a>&#160;</td>
          <td class="paramname"><em>tid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a value instance for a particular type. Here the type is entirely determined by its type ID.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1type__error.html" title="data type error">type_error</a></td><td>if the type ID is now known </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tid</td><td>type ID of the requested type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>instance of value holding data of type tid <br  />
 </dd></dl>

</div>
</div>
<a id="aab6051257c3e8f5fd56df8983d6b294c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6051257c3e8f5fd56df8983d6b294c">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArrayT::value_type pni::max </td>
          <td>(</td>
          <td class="paramtype">const ArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the larges value in an array type object. The result is of same type as the elements in the array type. This function does not work for arrays of complex numbers as there are no order relations for complex numbers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>array for which to determine the maximum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type T </dd></dl>

</div>
</div>
<a id="a4657cf3b2ef437b8c75652a3e4bc2cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4657cf3b2ef437b8c75652a3e4bc2cc0">&#9670;&nbsp;</a></span>max_clip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pni::max_clip </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ArrayT::value_type&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set values larger or equal than threshold to threshold. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>array to clip </td></tr>
    <tr><td class="paramname">threshold</td><td>threshold value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fbb029e5f23318f938e75904855eb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbb029e5f23318f938e75904855eb3d">&#9670;&nbsp;</a></span>max_clip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pni::max_clip </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ArrayT::value_type&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ArrayT::value_type&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt;&gt;</p>
<p>Set values larger or equal than threshold to valuer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>array to clip </td></tr>
    <tr><td class="paramname">threshold</td><td>threshold value </td></tr>
    <tr><td class="paramname">value</td><td>value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8851ae21594f631fe0ec5b80563efe0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8851ae21594f631fe0ec5b80563efe0a">&#9670;&nbsp;</a></span>max_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ContainerT pni::max_index </td>
          <td>(</td>
          <td class="paramtype">const ArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the multidimensional index of the maximum value in the array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>array where to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index in a container format requested by the user </dd></dl>

</div>
</div>
<a id="a7a0c5c8e113fd09cc3afb46172652080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0c5c8e113fd09cc3afb46172652080">&#9670;&nbsp;</a></span>max_offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t pni::max_offset </td>
          <td>(</td>
          <td class="paramtype">const ArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the linear offset of the maximum value in the array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>array object to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>linear offset of maximum value </dd></dl>

</div>
</div>
<a id="af247befacee5f08f154a57549d49a024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af247befacee5f08f154a57549d49a024">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArrayT::value_type pni::min </td>
          <td>(</td>
          <td class="paramtype">const ArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the minimum value stored in an array type. The result is of the same type as the array elements. This function does not work for array types with complex numbers as their elements as there are no order relations defined for complex numbers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type T </dd></dl>

</div>
</div>
<a id="a22c0c01cb831e072fd113cf21f7a7240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c0c01cb831e072fd113cf21f7a7240">&#9670;&nbsp;</a></span>min_clip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pni::min_clip </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ArrayT::value_type&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set values smaller or equal than threshold to threshold. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>array which to clip </td></tr>
    <tr><td class="paramname">threshold</td><td>threshold value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdc04f66da0ae02e5fa0862264ac2f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc04f66da0ae02e5fa0862264ac2f72">&#9670;&nbsp;</a></span>min_clip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pni::min_clip </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ArrayT::value_type&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ArrayT::value_type&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set values smaller or equal than threshold to value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>array which to clip </td></tr>
    <tr><td class="paramname">threshold</td><td>threshold value </td></tr>
    <tr><td class="paramname">value</td><td>the value to which to set data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b3bbd86477799cabaed10cf9bff143b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3bbd86477799cabaed10cf9bff143b">&#9670;&nbsp;</a></span>min_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ContainerT pni::min_index </td>
          <td>(</td>
          <td class="paramtype">const ArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the multidimensional index of the minimum value in the array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>array where to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index in a container format requested by the user </dd></dl>

</div>
</div>
<a id="a93e878bd8d1bab28d03548793ffc257d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e878bd8d1bab28d03548793ffc257d">&#9670;&nbsp;</a></span>min_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structpni_1_1min__max.html">pni::min_max</a> </td>
          <td>(</td>
          <td class="paramtype">const ArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ArrayT::value_type &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ArrayT::value_type &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt;&gt;</p>
<p>Return the minimunm and maximum values appearing in an array type. This function will not work on arrays with complex elements as there are no order relations for complex numbers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>array object </td></tr>
    <tr><td class="paramname">min</td><td>minimum value </td></tr>
    <tr><td class="paramname">max</td><td>maximum value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaec01a7ab6eb54ec96fa29ab98acc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaec01a7ab6eb54ec96fa29ab98acc49">&#9670;&nbsp;</a></span>min_offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t pni::min_offset </td>
          <td>(</td>
          <td class="paramtype">const ArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the linear offset of the minimum value in the array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>array object to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>linear offset of minimum value </dd></dl>

</div>
</div>
<a id="ae7a1ebbf6e5ba0b68ea3d9a523ed2228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a1ebbf6e5ba0b68ea3d9a523ed2228">&#9670;&nbsp;</a></span>offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapT , typename ContainerT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t pni::offset </td>
          <td>(</td>
          <td class="paramtype">const MapT &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array__selection.html">array_selection</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the offset of a selection element in the original array. The original array is not required but only its index map. The index is expected to have the effective size of the selection. This means that its rank can be smaller than that of the map.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MapT</td><td>map type of the original array </td></tr>
    <tr><td class="paramname">ContainerT</td><td>index type for the selection index </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>reference to the original index map </td></tr>
    <tr><td class="paramname">s</td><td>reference to the selection object </td></tr>
    <tr><td class="paramname">index</td><td>reference to the selection index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>linear offset of the element in the original array </dd></dl>

</div>
</div>
<a id="a31fc6717e6275e8bedb48e8f0b1b37a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fc6717e6275e8bedb48e8f0b1b37a7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pni::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; ArrayT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; ArrayT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns false if all elements in a an b are equal. a and b must have equal size, otherwise a <a class="el" href="classpni_1_1size__mismatch__error.html" title="Size mismatch error.">size_mismatch_error</a> exception is thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayT</td><td>array type for the view </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>lhs value of the operator </td></tr>
    <tr><td class="paramname">b</td><td>rhs value of the operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if all values are equal, true otherwise </dd></dl>

</div>
</div>
<a id="ad5141a5d9de1862763aa31eab2e553e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5141a5d9de1862763aa31eab2e553e3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool pni::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison of 128- and 32-Bit complex numbers. The operator returns true if either real or imaginary part or both of the two numbers differ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-Bit complex value </td></tr>
    <tr><td class="paramname">b</td><td>32-Bit complex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if equal. </dd></dl>

</div>
</div>
<a id="af135173a612f5e3440dfb16a8fd88388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af135173a612f5e3440dfb16a8fd88388">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool pni::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison of 128- and 64-Bit complex numbers. The operator returns true if either real or imaginary part or both of the two numbers differ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-Bit complex value </td></tr>
    <tr><td class="paramname">b</td><td>64-Bit complex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if equal. </dd></dl>

</div>
</div>
<a id="a215775f74dc0fc480e1ab3b86aa354ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215775f74dc0fc480e1ab3b86aa354ac">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool pni::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison of 32- and 128-Bit complex numbers. The operator returns true if either real or imaginary part or both of the two numbers differ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>32-Bit complex value </td></tr>
    <tr><td class="paramname">b</td><td>128-Bit complex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if equal. </dd></dl>

</div>
</div>
<a id="aeb0c21f8838f51f7722558679728083f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0c21f8838f51f7722558679728083f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool pni::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison of 32- and 64-Bit complex numbers. The operator returns true if either real or imaginary part or both of the two numbers differ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>32-Bit complex value </td></tr>
    <tr><td class="paramname">b</td><td>64-Bit complex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if equal. </dd></dl>

</div>
</div>
<a id="aeb439fed10c39768f3ab549272e4d94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb439fed10c39768f3ab549272e4d94a">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool pni::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison of 64- and 128-Bit complex numbers. The operator returns true if either real or imaginary part or both of the two numbers differ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>64-Bit complex value </td></tr>
    <tr><td class="paramname">b</td><td>128-Bit complex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if equal. </dd></dl>

</div>
</div>
<a id="a4b8c0c3f0ef9917ad95fecc35736ee0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8c0c3f0ef9917ad95fecc35736ee0b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool pni::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison of 64- and 32-Bit complex numbers. The operator returns true if either real or imaginary part or both of the two numbers differ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>64-Bit complex value </td></tr>
    <tr><td class="paramname">b</td><td>32-Bit complex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if equal. </dd></dl>

</div>
</div>
<a id="a68c268517fc4a4f0d4601a9ce4110c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c268517fc4a4f0d4601a9ce4110c47">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT , typename InplaceArithmeticT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pni::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if thwo arrays are not equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b1</td><td>array on the lhs of the comparison </td></tr>
    <tr><td class="paramname">b2</td><td>array on the rhs of the comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if not equal, false otherwise </dd></dl>

</div>
</div>
<a id="acf004d73858ff6f9b3117e137293c085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf004d73858ff6f9b3117e137293c085">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pni::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ElementT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ElementT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the two value of a and b are not equal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ElementT</td><td>data type for the scalar instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>lhs value of the operator </td></tr>
    <tr><td class="paramname">b</td><td>rhs value of the operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if both are equal, true otherwise </dd></dl>

</div>
</div>
<a id="a39bfeaf7ca57d536154a94cd8deb48d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bfeaf7ca57d536154a94cd8deb48d2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool pni::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98a9c81b86c6ac1ecbccee9fa73c655f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a9c81b86c6ac1ecbccee9fa73c655f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NativeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt;NativeT&gt; pni::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0340474c3b874c46d329f1effabc67a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0340474c3b874c46d329f1effabc67a3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSArrayT , typename RHSArrayT , typename  = enable_if&lt;and_t&lt;is_array&lt;LHSArrayT&gt;,is_array&lt;RHSArrayT&gt; &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt;<a class="el" href="classpni_1_1mult__op.html">mult_op</a>&lt;LHSArrayT,RHSArrayT&gt;,<a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt;LHSArrayT&gt;,<a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt;LHSArrayT&gt; &gt; pni::operator* </td>
          <td>(</td>
          <td class="paramtype">const LHSArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RHSArrayT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication between two array type instances </p><div class="fragment"><div class="line">mdarray&lt;...&gt; a = ...;</div>
<div class="line">mdarray&lt;...&gt; b = ...;</div>
<div class="line">mdarray&lt;...&gt; c = ...;</div>
<div class="line">c = a * b;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSArrayT</td><td>left hand side array type </td></tr>
    <tr><td class="paramname">RHSArrayT</td><td>right hand side array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>left operand </td></tr>
    <tr><td class="paramname">b</td><td>right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return mdarray instance with expression template </dd></dl>

</div>
</div>
<a id="a144f6659404172ea695d92e195feed98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144f6659404172ea695d92e195feed98">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSArrayT , typename ScalarT , typename  = enable_if&lt;and_t&lt;                        is_array&lt;LHSArrayT&gt;,not_t&lt;is_array&lt;ScalarT&gt;&gt;                        &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt;<a class="el" href="classpni_1_1mult__op.html">mult_op</a>&lt;LHSArrayT,<a class="el" href="classpni_1_1scalar.html">scalar</a>&lt;ScalarT&gt; &gt;,<a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt;LHSArrayT&gt;,<a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt;LHSArrayT&gt; &gt; pni::operator* </td>
          <td>(</td>
          <td class="paramtype">const LHSArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication between an array and a scalar </p><div class="fragment"><div class="line">dynamic_array&lt;float32&gt; a = ...;</div>
<div class="line">dynamic_array&lt;float32&gt; c = ...;</div>
<div class="line"><a class="code" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a> b = 200;</div>
<div class="line"> </div>
<div class="line">c = a * b;</div>
<div class="ttc" id="agroup__type__classes_html_gad937fd925b713d62317701414eb68508"><div class="ttname"><a href="group__type__classes.html#gad937fd925b713d62317701414eb68508">pni::float32</a></div><div class="ttdeci">float float32</div><div class="ttdoc">32Bit IEEE floating point type</div><div class="ttdef"><b>Definition:</b> types/types.hpp:64</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSArrayT</td><td>left hand side array type </td></tr>
    <tr><td class="paramname">ScalarT</td><td>right hand scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>left operand </td></tr>
    <tr><td class="paramname">b</td><td>right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mdarray with the expression template </dd></dl>

</div>
</div>
<a id="a2aed25b24d6de34dd371ce47ea916086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aed25b24d6de34dd371ce47ea916086">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarT , typename RHSArrayT , typename  = enable_if&lt;and_t&lt;                        not_t&lt;is_array&lt;ScalarT&gt;&gt;,is_array&lt;RHSArrayT&gt;                        &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt;<a class="el" href="classpni_1_1mult__op.html">mult_op</a>&lt;<a class="el" href="classpni_1_1scalar.html">scalar</a>&lt;ScalarT&gt;,RHSArrayT&gt;,<a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt;RHSArrayT&gt;,<a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt;RHSArrayT&gt; &gt; pni::operator* </td>
          <td>(</td>
          <td class="paramtype">const ScalarT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RHSArrayT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication between an array and a scalar </p><div class="fragment"><div class="line">dynamic_array&lt;float32&gt; a = ...;</div>
<div class="line">dynamic_array&lt;float32&gt; c = ...;</div>
<div class="line"><a class="code" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a> b = 200;</div>
<div class="line"> </div>
<div class="line">c = b * a;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScalarT</td><td>left hand side scalar type </td></tr>
    <tr><td class="paramname">RHSArrayT</td><td>right hand side array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>left operand </td></tr>
    <tr><td class="paramname">b</td><td>right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mdarray with the expression template </dd></dl>

</div>
</div>
<a id="a1193a0d8b3335366197caaed54dca901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1193a0d8b3335366197caaed54dca901">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int const_flag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1array__iterator.html">array_iterator</a>&lt;const_flag&gt; pni::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array__iterator.html">array_iterator</a>&lt; const_flag &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an offset to the iterator and thus increment its internal state by this offset.</p>
<div class="fragment"><div class="line">array_iterator&lt;...&gt; iter = ...<span class="stringliteral">&#39;</span></div>
<div class="line"><span class="stringliteral">array_iteator&lt;...&gt; iter2 = iter+2;</span></div>
</div><!-- fragment --><p> ! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>original iterator </td></tr>
    <tr><td class="paramname">b</td><td>offset to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new iterator </dd></dl>

</div>
</div>
<a id="a60e84e156126ee18585bde2da4fefa2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e84e156126ee18585bde2da4fefa2c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NativeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt;NativeT&gt; pni::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39a872948fa1c3299ee5d37127faa3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a872948fa1c3299ee5d37127faa3d4">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterableT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1container__iterator.html">container_iterator</a>&lt;IterableT&gt; pni::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1container__iterator.html">container_iterator</a>&lt; IterableT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an offset to the iterator and thus increment its internal state by this offset.</p>
<div class="fragment"><div class="line">Iteartor&lt;...&gt; iter = ...<span class="stringliteral">&#39;</span></div>
<div class="line"><span class="stringliteral">Iteartor&lt;...&gt; iter2 = iter+2;</span></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IterableT</td><td>iterable type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>original iterator </td></tr>
    <tr><td class="paramname">b</td><td>offset to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new iterator </dd></dl>

</div>
</div>
<a id="a0b6c5498471b2c76b348ab3f7706c65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6c5498471b2c76b348ab3f7706c65c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSArrayT , typename RHSArrayT , typename  = enable_if&lt;and_t&lt;is_array&lt;LHSArrayT&gt;,is_array&lt;RHSArrayT&gt;&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt;<a class="el" href="classpni_1_1add__op.html">add_op</a>&lt;LHSArrayT,RHSArrayT&gt;,<a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt;LHSArrayT&gt;,<a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt;LHSArrayT&gt; &gt; pni::operator+ </td>
          <td>(</td>
          <td class="paramtype">const LHSArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RHSArrayT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition between two instaces of array like objects.</p>
<div class="fragment"><div class="line">mdarray&lt;...&gt; a = ...;</div>
<div class="line">mdarray&lt;...&gt; b = ...;</div>
<div class="line">mdarray&lt;...&gt; c = ...;</div>
<div class="line"> </div>
<div class="line">c = a+b;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSArrayT</td><td>left hand side array type </td></tr>
    <tr><td class="paramname">RHSArrayT</td><td>right hand side array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>left operand instance </td></tr>
    <tr><td class="paramname">b</td><td>right operand instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mdarray with the expression template </dd></dl>

</div>
</div>
<a id="afd82bb004077c2d8e8b659f8c785ab95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd82bb004077c2d8e8b659f8c785ab95">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSArrayT , typename ScalarT , typename  = enable_if&lt;and_t&lt;                        is_array&lt;LHSArrayT&gt;,not_t&lt;is_array&lt;ScalarT&gt;&gt;                         &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt;<a class="el" href="classpni_1_1add__op.html">add_op</a>&lt;LHSArrayT,<a class="el" href="classpni_1_1scalar.html">scalar</a>&lt;ScalarT&gt; &gt;,<a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt;LHSArrayT&gt;,<a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt;LHSArrayT&gt; &gt; pni::operator+ </td>
          <td>(</td>
          <td class="paramtype">const LHSArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition operator between an array type object and a scalar. </p><div class="fragment"><div class="line">dynamic_array&lt;float32&gt; a = ....;</div>
<div class="line">dynamic_array&lt;float32&gt; c = ....;</div>
<div class="line"><a class="code" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a> d = ...;</div>
<div class="line"> </div>
<div class="line">c = a+d;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSArrayT</td><td>left hand side array type </td></tr>
    <tr><td class="paramname">ScalarT</td><td>scalar data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>reference to LHSArrayT operand </td></tr>
    <tr><td class="paramname">b</td><td>reference to RHSArrayT operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mdarray with the expression template </dd></dl>

</div>
</div>
<a id="adb7d55842a674e38bc480441ee0a863d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7d55842a674e38bc480441ee0a863d">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterableT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a>&lt;IterableT&gt; pni::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a>&lt; IterableT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an offset to the iterator and thus increment its internal state by this offset.</p>
<div class="fragment"><div class="line">Iteartor&lt;...&gt; iter = ...<span class="stringliteral">&#39;</span></div>
<div class="line"><span class="stringliteral">Iteartor&lt;...&gt; iter2 = iter+2;</span></div>
</div><!-- fragment --><p> ! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>original iterator </td></tr>
    <tr><td class="paramname">b</td><td>offset to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new iterator </dd></dl>

</div>
</div>
<a id="aab2971f852e11c1816a17c185639f317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2971f852e11c1816a17c185639f317">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarT , typename RHSArrayT , typename  = enable_if&lt;and_t&lt;                        not_t&lt;is_array&lt;ScalarT&gt;&gt;,is_array&lt;RHSArrayT&gt;                        &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt;<a class="el" href="classpni_1_1add__op.html">add_op</a>&lt;<a class="el" href="classpni_1_1scalar.html">scalar</a>&lt;ScalarT&gt;,RHSArrayT&gt;,<a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt;RHSArrayT&gt;,<a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt;RHSArrayT&gt; &gt; pni::operator+ </td>
          <td>(</td>
          <td class="paramtype">const ScalarT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RHSArrayT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition operator between an array type object and a scalar. </p><div class="fragment"><div class="line">dynamic_array&lt;float32&gt; a = ....;</div>
<div class="line">dynamic_array&lt;float32&gt; c = ....;</div>
<div class="line"><a class="code" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a> d = ...;</div>
<div class="line"> </div>
<div class="line">c = d+a;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScalarT</td><td>data type of the scalar operand </td></tr>
    <tr><td class="paramname">RHSArrayT</td><td>data type of the right hand side operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>scalar value </td></tr>
    <tr><td class="paramname">b</td><td>instance of an RHSArrayT array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mdarray instance with the expression template </dd></dl>

</div>
</div>
<a id="a6f31606ae2bcfd4256fcf5d6c8b9a5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f31606ae2bcfd4256fcf5d6c8b9a5c4">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int const_flag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1array__iterator.html">array_iterator</a>&lt;const_flag&gt; pni::operator+ </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array__iterator.html">array_iterator</a>&lt; const_flag &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an offset to the iterator and thus increment its internal state by this offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>offset to add </td></tr>
    <tr><td class="paramname">b</td><td>original iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new iterator </dd></dl>

</div>
</div>
<a id="a0d6a4b2ed8c3c6bfc559d672ffed6142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6a4b2ed8c3c6bfc559d672ffed6142">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterableT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1container__iterator.html">container_iterator</a>&lt;IterableT&gt; pni::operator+ </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1container__iterator.html">container_iterator</a>&lt; IterableT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an offset to the iterator and thus increment its internal state by this offset.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IterableT</td><td>iterable type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>offset to add </td></tr>
    <tr><td class="paramname">b</td><td>original iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new iterator </dd></dl>

</div>
</div>
<a id="a0ca87002e81aa929ff6fd5a8161af95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca87002e81aa929ff6fd5a8161af95d">&#9670;&nbsp;</a></span>operator+() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterableT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a>&lt;IterableT&gt; pni::operator+ </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a>&lt; IterableT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an offset to the iterator and thus increment its internal state by this offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>offset to add </td></tr>
    <tr><td class="paramname">b</td><td>original iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new iterator </dd></dl>

</div>
</div>
<a id="ac753dc36bf766bf821c84b12a8e65f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac753dc36bf766bf821c84b12a8e65f0e">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int const_flag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ssize_t pni::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array__iterator.html">array_iterator</a>&lt; const_flag &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array__iterator.html">array_iterator</a>&lt; const_flag &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract to iterators and return the offset difference between this two iterators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first iterator </td></tr>
    <tr><td class="paramname">b</td><td>second iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>offset difference </dd></dl>

</div>
</div>
<a id="afd9acfe7195d7134a4ce9aa9b633bb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9acfe7195d7134a4ce9aa9b633bb55">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int const_flag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1array__iterator.html">array_iterator</a>&lt;const_flag&gt; pni::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array__iterator.html">array_iterator</a>&lt; const_flag &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract an integer offset from the iterator and thus decrement the internal state of the iterator by this value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>original iterator </td></tr>
    <tr><td class="paramname">b</td><td>offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new iterator to new position </dd></dl>

</div>
</div>
<a id="afe0a3e529d9ec13029b8589c853498a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0a3e529d9ec13029b8589c853498a2">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NativeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt;NativeT&gt; pni::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a310f0edd92fc0287d78cbc16d807917f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310f0edd92fc0287d78cbc16d807917f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterableT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ssize_t pni::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1container__iterator.html">container_iterator</a>&lt; IterableT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1container__iterator.html">container_iterator</a>&lt; IterableT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract to iterators and return the offset difference between this two iterators.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IterableT</td><td>iterable type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first iterator </td></tr>
    <tr><td class="paramname">b</td><td>second iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>offset difference </dd></dl>

</div>
</div>
<a id="a5161eae5a68184423fb2024811b7ce38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5161eae5a68184423fb2024811b7ce38">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterableT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1container__iterator.html">container_iterator</a>&lt;IterableT&gt; pni::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1container__iterator.html">container_iterator</a>&lt; IterableT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract an integer offset from the iterator and thus decrement the internal state of the iterator by this value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IterableT</td><td>iterable type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>original iterator </td></tr>
    <tr><td class="paramname">b</td><td>offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new iterator to new position </dd></dl>

</div>
</div>
<a id="aab4359c75e22f6fbbf9276931208487a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4359c75e22f6fbbf9276931208487a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSArrayT , typename RHSArrayT , typename  = enable_if&lt;and_t&lt;is_array&lt;LHSArrayT&gt;,is_array&lt;RHSArrayT&gt;&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt;<a class="el" href="classpni_1_1sub__op.html">sub_op</a>&lt;LHSArrayT,RHSArrayT &gt;,<a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt;LHSArrayT&gt;,<a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt;LHSArrayT&gt; &gt; pni::operator- </td>
          <td>(</td>
          <td class="paramtype">const LHSArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RHSArrayT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtraction between two array like objects.</p>
<div class="fragment"><div class="line">mdarray&lt;...&gt; a = ...;</div>
<div class="line">mdarray&lt;...&gt; b = ...;</div>
<div class="line">mdarray&lt;...&gt; c = ...;</div>
<div class="line"> </div>
<div class="line">c = a - b;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSArrayT</td><td>left hand side operator type </td></tr>
    <tr><td class="paramname">RHSArrayT</td><td>right hand side operator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>left operand </td></tr>
    <tr><td class="paramname">b</td><td>right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mdarray with the expression template </dd></dl>

</div>
</div>
<a id="a1fa81e3e021e6bea1485dfbd89766c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa81e3e021e6bea1485dfbd89766c16">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSArrayT , typename ScalarT , typename  = enable_if&lt;and_t&lt;                      is_array&lt;LHSArrayT&gt;,not_t&lt;is_array&lt;ScalarT&gt;&gt;                      &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt;<a class="el" href="classpni_1_1sub__op.html">sub_op</a>&lt;LHSArrayT,<a class="el" href="classpni_1_1scalar.html">scalar</a>&lt;ScalarT&gt; &gt;,<a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt;LHSArrayT&gt;,<a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt;LHSArrayT&gt; &gt; pni::operator- </td>
          <td>(</td>
          <td class="paramtype">const LHSArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtracting a scalar type from an array type. </p><div class="fragment"><div class="line">dynamic_array&lt;float32&gt; a = ...;</div>
<div class="line">dynamic_array&lt;float32&gt; c = ...;</div>
<div class="line"><a class="code" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a> b = ...;</div>
<div class="line"> </div>
<div class="line">c = a - b; </div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSArrayT</td><td>left hand side array type </td></tr>
    <tr><td class="paramname">ScalarT</td><td>right handside scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>left operand </td></tr>
    <tr><td class="paramname">b</td><td>right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mdarray instance with the expression template </dd></dl>

</div>
</div>
<a id="a69f634d852fbd338a554a21ee3c57560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f634d852fbd338a554a21ee3c57560">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterableT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ssize_t pni::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a>&lt; IterableT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a>&lt; IterableT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract to iterators and return the offset difference between this two iterators. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first iterator </td></tr>
    <tr><td class="paramname">b</td><td>second iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>offset difference </dd></dl>

</div>
</div>
<a id="a14bb7cab2e23bcb6f983b242ece166ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bb7cab2e23bcb6f983b242ece166ba">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterableT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a>&lt;IterableT&gt; pni::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1scalar__iterator.html">scalar_iterator</a>&lt; IterableT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract an integer offset from the iterator and thus decrement the internal state of the iterator by this value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>original iterator </td></tr>
    <tr><td class="paramname">b</td><td>offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new iterator to new position </dd></dl>

</div>
</div>
<a id="aab1256ade88c32b279d334180817271e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1256ade88c32b279d334180817271e">&#9670;&nbsp;</a></span>operator-() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarT , typename RHSArrayT , typename  = enable_if&lt;and_t&lt;                        not_t&lt;is_array&lt;ScalarT&gt;&gt;,is_array&lt;RHSArrayT&gt;                         &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt;<a class="el" href="classpni_1_1sub__op.html">sub_op</a>&lt;<a class="el" href="classpni_1_1scalar.html">scalar</a>&lt;ScalarT&gt;,RHSArrayT&gt;,<a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt;RHSArrayT&gt;,<a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt;RHSArrayT&gt; &gt; pni::operator- </td>
          <td>(</td>
          <td class="paramtype">const ScalarT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RHSArrayT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtracting an array from a scalar </p><div class="fragment"><div class="line"><a class="code" href="group__type__classes.html#gad937fd925b713d62317701414eb68508">float32</a> b = ...;</div>
<div class="line">dynamic_array&lt;float32&gt; a = ...;</div>
<div class="line">dynamic_array&lt;float32&gt; c = ...;</div>
<div class="line"> </div>
<div class="line">c = b - a;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScalarT</td><td>scalar right handside type </td></tr>
    <tr><td class="paramname">RHSArrayT</td><td>right hand side array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>scalar value </td></tr>
    <tr><td class="paramname">b</td><td>array like right handside </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>instance of NumArray with an expression template </dd></dl>

</div>
</div>
<a id="a3501629e3965d184155e3a5a13862a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3501629e3965d184155e3a5a13862a93">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NativeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt;NativeT&gt; pni::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1binary__t.html">binary_t</a>&lt; NativeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1120ede515181be0e98425a74066ff59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1120ede515181be0e98425a74066ff59">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSArrayT , typename RHSArrayT , typename  = enable_if&lt;and_t&lt;is_array&lt;LHSArrayT&gt;,is_array&lt;RHSArrayT&gt;&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt;<a class="el" href="classpni_1_1div__op.html">div_op</a>&lt;LHSArrayT,RHSArrayT&gt;,<a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt;LHSArrayT&gt;,<a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt;LHSArrayT&gt; &gt; pni::operator/ </td>
          <td>(</td>
          <td class="paramtype">const LHSArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RHSArrayT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary division between two array objects</p>
<div class="fragment"><div class="line">mdarray&lt;...&gt; a = ...;</div>
<div class="line">mdarray&lt;...&gt; b = ...;</div>
<div class="line">mdarray&lt;...&gt; c = ...;</div>
<div class="line">c = a / b;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSArrayT</td><td>left hand side array type </td></tr>
    <tr><td class="paramname">RHSArrayT</td><td>right hand side array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>left operand </td></tr>
    <tr><td class="paramname">b</td><td>right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mdarray with the expression template </dd></dl>

</div>
</div>
<a id="ab7a5647b79b9095fb4fe5c7fab77f09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a5647b79b9095fb4fe5c7fab77f09e">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSArrayT , typename ScalarT , typename  = enable_if&lt;and_t&lt;                        is_array&lt;LHSArrayT&gt;,not_t&lt;is_array&lt;ScalarT&gt;&gt;                        &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt;<a class="el" href="classpni_1_1div__op.html">div_op</a>&lt;LHSArrayT,<a class="el" href="classpni_1_1scalar.html">scalar</a>&lt;ScalarT&gt; &gt;,<a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt;LHSArrayT&gt;,<a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt;LHSArrayT&gt; &gt; pni::operator/ </td>
          <td>(</td>
          <td class="paramtype">const LHSArrayT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Division of an array type by a scalar type </p><div class="fragment"><div class="line">mdarray&lt;...&gt; a = ...;</div>
<div class="line">mdarray&lt;...&gt; c = ...;</div>
<div class="line"><a class="code" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a> b = ...;</div>
<div class="line"> </div>
<div class="line">c = a/b;</div>
<div class="ttc" id="agroup__type__classes_html_ga297fd4128dac28f23f2febf84de403d2"><div class="ttname"><a href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">pni::float64</a></div><div class="ttdeci">double float64</div><div class="ttdoc">64Bit IEEE floating point type</div><div class="ttdef"><b>Definition:</b> types/types.hpp:63</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSArrayT</td><td>left hand side array type </td></tr>
    <tr><td class="paramname">ScalarT</td><td>right hand side scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>left operand </td></tr>
    <tr><td class="paramname">b</td><td>right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mdarray with the expression template </dd></dl>

</div>
</div>
<a id="af7bd9762cc8ca7d0fa0d8577700cba07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bd9762cc8ca7d0fa0d8577700cba07">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarT , typename RHSArrayT , typename  = enable_if&lt;and_t&lt;                        not_t&lt;is_array&lt;ScalarT&gt;&gt;,is_array&lt;RHSArrayT&gt;                        &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt;<a class="el" href="classpni_1_1div__op.html">div_op</a>&lt;<a class="el" href="classpni_1_1scalar.html">scalar</a>&lt;ScalarT&gt;,RHSArrayT&gt;,<a class="el" href="namespacepni.html#aa5cc1016cb8fd406cb452d43404b3d92">map_type</a>&lt;RHSArrayT&gt;,<a class="el" href="namespacepni.html#a2bf6c4315f702282de1f3d497da35bdc">ipa_type</a>&lt;RHSArrayT&gt; &gt; pni::operator/ </td>
          <td>(</td>
          <td class="paramtype">const ScalarT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RHSArrayT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Division of a scalar by an array type </p><div class="fragment"><div class="line">mdarray&lt;...&gt; a = ...;</div>
<div class="line">mdarray&lt;...&gt; c = ...;</div>
<div class="line"><a class="code" href="group__type__classes.html#ga297fd4128dac28f23f2febf84de403d2">float64</a> b = ...;</div>
<div class="line"> </div>
<div class="line">c = b / a;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScalarT</td><td>left hand side scalar type </td></tr>
    <tr><td class="paramname">RHSArrayT</td><td>right hand side array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>scalar value </td></tr>
    <tr><td class="paramname">b</td><td>array instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mdarray with the expression template </dd></dl>

</div>
</div>
<a id="a274af90a0c9bf4b3e9b5de4e98759d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274af90a0c9bf4b3e9b5de4e98759d96">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> std::ostream&amp; pni::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1column__info.html">column_info</a> &amp;&#160;</td>
          <td class="paramname"><em>ci</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3c8434813fb9d112b4dec2961b8c09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c8434813fb9d112b4dec2961b8c09a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> std::ostream&amp; pni::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1exception__record.html">exception_record</a> &amp;&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58b019be5b8618eb651063dce518b0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b019be5b8618eb651063dce518b0b3">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT , typename InplaceArithmeticT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pni::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes content of a DArray to an output stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>output stream </td></tr>
    <tr><td class="paramname">a</td><td>array to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream </dd></dl>

</div>
</div>
<a id="a3fd23126a950b05ee8ad649bcf718888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd23126a950b05ee8ad649bcf718888">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> std::ostream&amp; pni::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6658dd7b214ac22b58b91624966c5b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6658dd7b214ac22b58b91624966c5b9a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pni::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ElementT &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write content to output stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramname">s</td><td>scalar value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to output stream </dd></dl>

</div>
</div>
<a id="ac1ee966073630add8e2830bc712c1455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ee966073630add8e2830bc712c1455">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pni::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; ArrayT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output a view instance to a stream.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayT</td><td>array type of the view </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>reference to output stream </td></tr>
    <tr><td class="paramname">v</td><td>view instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified stream </dd></dl>

</div>
</div>
<a id="a5ca9bb2620f3528c2240d61b93de1fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca9bb2620f3528c2240d61b93de1fb5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> std::ostream&amp; pni::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1bool__t.html">bool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30c943c72378fafdd22174b5fd7562a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c943c72378fafdd22174b5fd7562a7">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pni::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; ArrayT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; ArrayT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if all elements of a an b are equal. The two views must have equal size. Otherwise a size_mismatch_excpetion is thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayT</td><td>array type for the view </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>lhs value of the operator </td></tr>
    <tr><td class="paramname">b</td><td>rhs value of the operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all elements are equal, flase otherwise </dd></dl>

</div>
</div>
<a id="a7fd9d973064d0d2c88c15f6c5f0a61e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd9d973064d0d2c88c15f6c5f0a61e6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool pni::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison of 128- and 32-Bit complex numbers. The operator returns true if real and imaginary part of the two numbers are equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-Bit complex value </td></tr>
    <tr><td class="paramname">b</td><td>32-Bit complex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if equal. </dd></dl>

</div>
</div>
<a id="a8e7528a060d3d6fb4a7dad065c573337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7528a060d3d6fb4a7dad065c573337">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool pni::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison of 128- and 64-Bit complex numbers. The operator returns true if real and imaginary part of the two numbers are equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>128-Bit complex value </td></tr>
    <tr><td class="paramname">b</td><td>64-Bit complex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if equal. </dd></dl>

</div>
</div>
<a id="a13be3245115f4233dea78522fc8af691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13be3245115f4233dea78522fc8af691">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool pni::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison of 32- and 128-Bit complex numbers. The operator returns true if real and imaginary part of the two numbers are equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>32-Bit complex value </td></tr>
    <tr><td class="paramname">b</td><td>128-Bit complex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if equal. </dd></dl>

</div>
</div>
<a id="a2ded422a6016144bd88da6fa9737689c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ded422a6016144bd88da6fa9737689c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool pni::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison of 32- and 64-Bit complex numbers. The operator returns true if real and imaginary part of the two numbers are equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>32-Bit complex value </td></tr>
    <tr><td class="paramname">b</td><td>64-Bit complex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if equal. </dd></dl>

</div>
</div>
<a id="ae189254b51c42519b2cc29afcb557e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae189254b51c42519b2cc29afcb557e51">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool pni::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga93af677cfc058639b20efe51e82b0226">complex128</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison of 64- and 128-Bit complex numbers. The operator returns true if real and imaginary part of the two numbers are equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>64-Bit complex value </td></tr>
    <tr><td class="paramname">b</td><td>128-Bit complex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if equal. </dd></dl>

</div>
</div>
<a id="ae66e18e84085bf3e30dc25624d305693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66e18e84085bf3e30dc25624d305693">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool pni::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#ga196dbc1a828935ea6fa75ff419f52686">complex64</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__classes.html#gaf4f3e309490ff7ed71029d40375c5e46">complex32</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison of 64- and 32-Bit complex numbers. The operator returns true if real and imaginary part of the two numbers are equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>64-Bit complex value </td></tr>
    <tr><td class="paramname">b</td><td>32-Bit complex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if equal. </dd></dl>

</div>
</div>
<a id="af96da3356844bf9f27cd2e46370a91e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96da3356844bf9f27cd2e46370a91e2">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT , typename InplaceArithmeticT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pni::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if thwo arrays are equal. This is the case when all element stored in the arrays are equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b1</td><td>array on the lhs of the comparison </td></tr>
    <tr><td class="paramname">b2</td><td>array on the rhs of the comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all elements are equal, false otherwise </dd></dl>

</div>
</div>
<a id="aa9ad4bac0c3c4f6e1d2006868f39836c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ad4bac0c3c4f6e1d2006868f39836c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pni::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ElementT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ElementT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the two value of a and b are equal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ElementT</td><td>data type for the scalar instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>lhs value of the operator </td></tr>
    <tr><td class="paramname">b</td><td>rhs value of the operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both are equal, false otherwise </dd></dl>

</div>
</div>
<a id="a7b9fd779f21aa8a30cb9968c7c99d6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9fd779f21aa8a30cb9968c7c99d6df">&#9670;&nbsp;</a></span>operator==() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> bool pni::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af147b4c5c0279534e0e0625695a9fcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af147b4c5c0279534e0e0625695a9fcc3">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageT , typename IndexMapT , typename InplaceArithmeticT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; pni::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpni_1_1mdarray.html">mdarray</a>&lt; StorageT, IndexMapT, InplaceArithmeticT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from an input stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream </td></tr>
    <tr><td class="paramname">a</td><td>array where to store the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to input stream </dd></dl>

</div>
</div>
<a id="a9b5d3293e77005349a8a4ab1c19eda1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5d3293e77005349a8a4ab1c19eda1f">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; pni::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpni_1_1scalar.html">scalar</a>&lt; ElementT &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read content from input stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream </td></tr>
    <tr><td class="paramname">s</td><td>scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to input stream </dd></dl>

</div>
</div>
<a id="abe2aacb6d078bb640c30ebc9d28fea0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2aacb6d078bb640c30ebc9d28fea0e">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; pni::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpni_1_1array__view.html">array_view</a>&lt; ArrayT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data from a stream to a view.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayT</td><td>array type of the view </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>reference to the input stream </td></tr>
    <tr><td class="paramname">v</td><td>reference to the view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified input stream </dd></dl>

</div>
</div>
<a id="a0127c98150b1380e9c3c153c4a05fe30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0127c98150b1380e9c3c153c4a05fe30">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> std::istream&amp; pni::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpni_1_1bool__t.html">bool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0887774263fc1221b266d79d1568d162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0887774263fc1221b266d79d1568d162">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> std::istream&amp; pni::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hdf5::datatype::EBool &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aabaa6b5e16a17cbc7059f9eb7717181b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabaa6b5e16a17cbc7059f9eb7717181b">&#9670;&nbsp;</a></span>print_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pni::print_vector </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorT &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the content of an interable as a vector. The output is <br  />
 embraced by () and each element is separated by a comma. <br  />
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorT</td><td>container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>output stream </td></tr>
    <tr><td class="paramname">v</td><td>iterable instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addd3514df6b58ef00906322a75c2a265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd3514df6b58ef00906322a75c2a265">&#9670;&nbsp;</a></span>set_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT , typename SourceT , typename PointerT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pni::set_value </td>
          <td>(</td>
          <td class="paramtype">PointerT&#160;</td>
          <td class="paramname"><em>holder_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceT &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a value of type T and store it to a <a class="el" href="classpni_1_1value__holder.html" title="implementation of the holder interface">value_holder</a> of type S. If S and T are not equal a type conversion is performed.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1range__error.html" title="data range error">range_error</a></td><td>if v does not fit in the range provided by S </td></tr>
    <tr><td class="paramname"><a class="el" href="classpni_1_1type__error.html" title="data type error">type_error</a></td><td>in case of any other type related error</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TargetT</td><td>target type (the holder type) </td></tr>
    <tr><td class="paramname">SourceT</td><td>source type (provided by the user) </td></tr>
    <tr><td class="paramname">PointerT</td><td>holder pointer type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">holder_ptr</td><td>pointer to the typed <a class="el" href="classpni_1_1value__holder.html" title="implementation of the holder interface">value_holder</a> </td></tr>
    <tr><td class="paramname">v</td><td>reference to the value of type T </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab20a3d8d51f1c5aee26a971b5fe2cf65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20a3d8d51f1c5aee26a971b5fe2cf65">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> size_t pni::size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt;&gt;</p>
<p>Computes the number of elements spanned by a slice. <br  />
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ size=\frac{last-first+stride-1}{stride} \]" src="form_0.png" width="175" height="28"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>slice object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of spanned elements </dd></dl>

</div>
</div>
<a id="a00094494cfad50d0a67085bec79eb2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00094494cfad50d0a67085bec79eb2fd">&#9670;&nbsp;</a></span>span()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> size_t pni::span </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the total number of elements spanned by the slice. <br  />
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ span = last-first \]" src="form_1.png" width="108" height="13"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>slice for which to compute the span </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total number of elements </dd></dl>

</div>
</div>
<a id="ab01896ba81995c4540b4230baa6e13cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01896ba81995c4540b4230baa6e13cc">&#9670;&nbsp;</a></span>start_offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t pni::start_offset </td>
          <td>(</td>
          <td class="paramtype">const MapT &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array__selection.html">array_selection</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the offset in the original array of the first element in the selection.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MapT</td><td>original index map type </td></tr>
    <tr><td class="paramname">IndexT</td><td>index type of the selection </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>reference to the original index map </td></tr>
    <tr><td class="paramname">s</td><td>reference to the selection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>offset of the first selection element </dd></dl>

</div>
</div>
<a id="a6c717ca89e487ad64a06d46c5a66b7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c717ca89e487ad64a06d46c5a66b7cc">&#9670;&nbsp;</a></span>to_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="classpni_1_1value.html">value</a> pni::to_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1value__ref.html">value_ref</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function extracts the value stored in the variable referenced by <a class="el" href="classpni_1_1value__ref.html" title="type erasure for references to POD data">value_ref</a> and stores it in a new instance of value.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpni_1_1memory__not__allocated__error.html" title="memory not allocated error">memory_not_allocated_error</a></td><td>if the reference is not set </td></tr>
    <tr><td class="paramname"><a class="el" href="classpni_1_1type__error.html" title="data type error">type_error</a></td><td>if the type of the variable referenced by <a class="el" href="classpni_1_1value__ref.html" title="type erasure for references to POD data">value_ref</a> is unknown</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>reference to <a class="el" href="classpni_1_1value__ref.html" title="type erasure for references to POD data">value_ref</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>instance of value with the content of <a class="el" href="classpni_1_1value__ref.html" title="type erasure for references to POD data">value_ref</a> </dd></dl>

</div>
</div>
<a id="aee71063a252b0a6236cc7c62f5c1bf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee71063a252b0a6236cc7c62f5c1bf25">&#9670;&nbsp;</a></span>type_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> pni::type_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1array.html">array</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the type ID of the array stored in an array type erasure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>reference to the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type ID </dd></dl>

</div>
</div>
<a id="ab1e20eb9ab4a6d4d22e70b58392a918c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e20eb9ab4a6d4d22e70b58392a918c">&#9670;&nbsp;</a></span>type_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_8hpp.html#abcc7ce29ca8863e31e7945d1905a72f6">PNINEXUS_EXPORT</a> <a class="el" href="group__type__classes.html#ga2c8ca0de37c42914554a1a9e500b31cd">type_id_t</a> pni::type_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpni_1_1value.html">value</a> &amp;&#160;</td>
          <td class="paramname"><em>rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of type_id to obtain the type ID of the element stored in the type erasure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rv</td><td>reference to value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type ID of the erased type </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepni.html">pni</a></li>
    <li class="footer">Generated on Mon Feb 20 2023 13:36:36 for PNI NeXus Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
